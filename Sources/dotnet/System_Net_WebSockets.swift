// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
// System.Net
// System.Net.WebSockets
extension System.Net.WebSockets {
// type: System.Net.WebSockets.ValueWebSocketReceiveResult
// boxed value type
    /**
    Represents the result of performing a single  operation on a .

    */
public final class ValueWebSocketReceiveResult
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_ValueWebSocketReceiveResult_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the number of bytes that the  received.

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets whether the message has been received completely.

    */
    public var EndOfMessage : Bool {
        get {
            return try! get_EndOfMessage();
        }
    }
    /**
    Gets the type of the current message.

    */
    public var MessageType : dotnet.System.Net.WebSockets.WebSocketMessageType {
        get {
            return try! get_MessageType();
        }
    }
    // .ctor(System.Int32, System.Net.WebSockets.WebSocketMessageType, bool)
// docid: M:System.Net.WebSockets.ValueWebSocketReceiveResult.#ctor(System.Int32,System.Net.WebSockets.WebSocketMessageType,System.Boolean)
    /**
    Initializes a new instance of the  struct. An instance of this struct represents the result of performing a single ReceiveAsync operation on a .

    - Parameter count: The number of bytes that the  received.
    - Parameter messageType: One of the enumeration values that indicates whether the current message is a UTF-8 message or a binary message.
    - Parameter endOfMessage: 
         to indicate the messsage has been received completely; otherwise, .
    */
    public init(count : Swift.Int32, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, endOfMessage : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_ValueWebSocketReceiveResult_ctor_0__3__i32_WebSocketMessageType_bool(&__thrown, count, messageType.get_value(), Swift.Int32(endOfMessage ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Net_WebSockets_ValueWebSocketReceiveResult_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Net.WebSockets.ValueWebSocketReceiveResult.get_Count
    public func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ValueWebSocketReceiveResult_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_EndOfMessage()
// docid: M:System.Net.WebSockets.ValueWebSocketReceiveResult.get_EndOfMessage
    public func get_EndOfMessage() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ValueWebSocketReceiveResult_bool__get_EndOfMessage_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.WebSockets.WebSocketMessageType get_MessageType()
// docid: M:System.Net.WebSockets.ValueWebSocketReceiveResult.get_MessageType
    public func get_MessageType() throws -> dotnet.System.Net.WebSockets.WebSocketMessageType {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ValueWebSocketReceiveResult_WebSocketMessageType__get_MessageType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocketMessageType(val: __return);
        }
    }
} // ValueWebSocketReceiveResult


// type: System.Net.WebSockets.WebSocket
    /**
    The WebSocket class allows applications to send and receive data after the WebSocket upgrade has completed.

    */
open class WebSocket
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocket_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Abort()
// docid: M:System.Net.WebSockets.WebSocket.Abort
    /**
    Aborts the WebSocket connection and cancels any pending IO operations.

    */
    open func Abort() throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocket_void__Abort_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task CloseAsync(System.Net.WebSockets.WebSocketCloseStatus, System.String, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.WebSocket.CloseAsync(System.Net.WebSockets.WebSocketCloseStatus,System.String,System.Threading.CancellationToken)
    /**
    Closes the WebSocket connection as an asynchronous operation using the close handshake defined in the WebSocket protocol specification section 7.

    - Parameter closeStatus: Indicates the reason for closing the WebSocket connection.
    - Parameter statusDescription: Specifies a human readable explanation as to why the connection is closed.
    - Parameter cancellationToken: The token that can be used to propagate notification that operations should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func CloseAsync(closeStatus : dotnet.System.Net.WebSockets.WebSocketCloseStatus, statusDescription : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_Task__CloseAsync_0__3__WebSocketCloseStatus_String_CancellationToken(&__thrown, self.get_handle(), closeStatus.get_value(), statusDescription?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.Task CloseOutputAsync(System.Net.WebSockets.WebSocketCloseStatus, System.String, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.WebSocket.CloseOutputAsync(System.Net.WebSockets.WebSocketCloseStatus,System.String,System.Threading.CancellationToken)
    /**
    Initiates or completes the close handshake defined in the WebSocket protocol specification section 7.

    - Parameter closeStatus: Indicates the reason for closing the WebSocket connection.
    - Parameter statusDescription: Allows applications to specify a human readable explanation as to why the connection is closed.
    - Parameter cancellationToken: The token that can be used to propagate notification that operations should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func CloseOutputAsync(closeStatus : dotnet.System.Net.WebSockets.WebSocketCloseStatus, statusDescription : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_Task__CloseOutputAsync_0__3__WebSocketCloseStatus_String_CancellationToken(&__thrown, self.get_handle(), closeStatus.get_value(), statusDescription?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.ArraySegment<System.Byte> CreateClientBuffer(System.Int32, System.Int32)
// docid: M:System.Net.WebSockets.WebSocket.CreateClientBuffer(System.Int32,System.Int32)
    /**
    Create client buffers to use with this  instance.

    - Parameter receiveBufferSize: The size, in bytes, of the client receive buffer.
    - Parameter sendBufferSize: The size, in bytes, of the send buffer.
    - Returns: An array with the client buffers.

    */
    open class func CreateClientBuffer(receiveBufferSize : Swift.Int32, sendBufferSize : Swift.Int32) throws -> dotnet.System.ArraySegment_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_System_ArraySegment_u8___CreateClientBuffer_0__2__i32_i32(&__thrown, receiveBufferSize, sendBufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ArraySegment_1(hndl : __return);
        }
    }
    // System.Net.WebSockets.WebSocket CreateClientWebSocket(System.IO.Stream, System.String, System.Int32, System.Int32, System.TimeSpan, bool, System.ArraySegment<System.Byte>)
// docid: M:System.Net.WebSockets.WebSocket.CreateClientWebSocket(System.IO.Stream,System.String,System.Int32,System.Int32,System.TimeSpan,System.Boolean,System.ArraySegment{System.Byte})
    /**
    Allows callers to create a client side WebSocket class which will use the WSPC for framing purposes.

    - Parameter innerStream: The connection to be used for IO operations.
    - Parameter subProtocol: The subprotocol accepted by the client.
    - Parameter receiveBufferSize: The size in bytes of the client WebSocket receive buffer.
    - Parameter sendBufferSize: The size in bytes of the client WebSocket send buffer.
    - Parameter keepAliveInterval: Determines how regularly a frame is sent over the connection as a keep-alive. Applies only when the connection is idle.
    - Parameter useZeroMaskingKey: Indicates whether a random key or a static key (just zeros) should be used for the WebSocket masking.
    - Parameter internalBuffer: Will be used as the internal buffer in the WPC. The size has to be at least 2 (ASTERISK) ReceiveBufferSize + SendBufferSize + 256 + 20 (16 on 32-bit).
    - Returns: Returns .

    */
    open class func CreateClientWebSocket(innerStream : dotnet.System.IO.Stream, subProtocol : Optional<dotnet.System.String>, receiveBufferSize : Swift.Int32, sendBufferSize : Swift.Int32, keepAliveInterval : dotnet.System.TimeSpan, useZeroMaskingKey : Bool, internalBuffer : dotnet.System.ArraySegment_1<Swift.UInt8>) throws -> dotnet.System.Net.WebSockets.WebSocket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_WebSocket__CreateClientWebSocket_0__7__Stream_String_i32_i32_TimeSpan_bool_System_ArraySegment_u8_(&__thrown, innerStream.get_handle(), subProtocol?.get_handle() ?? nil, receiveBufferSize, sendBufferSize, keepAliveInterval.get_handle(), Swift.Int32(useZeroMaskingKey ? 1 : 0), internalBuffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocket(hndl : __return);
        }
    }
    // System.Net.WebSockets.WebSocket CreateFromStream(System.IO.Stream, bool, System.String, System.TimeSpan)
// docid: M:System.Net.WebSockets.WebSocket.CreateFromStream(System.IO.Stream,System.Boolean,System.String,System.TimeSpan)
    /**
    Creates a new  object that operates on the specified stream, which represents a web socket connection.

    - Parameter stream: The stream for the connection.
    - Parameter isServer: 
         to indicate it's the server-side of the connection;  if it's the client-side.
    - Parameter subProtocol: The agreed upon sub-protocol that was used when creating the connection.
    - Parameter keepAliveInterval: The keep-alive interval to use, or  to disable keep-alives.
    - Returns: The new web socket.

    */
    open class func CreateFromStream(stream : dotnet.System.IO.Stream, isServer : Bool, subProtocol : Optional<dotnet.System.String>, keepAliveInterval : dotnet.System.TimeSpan) throws -> dotnet.System.Net.WebSockets.WebSocket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_WebSocket__CreateFromStream_0__4__Stream_bool_String_TimeSpan(&__thrown, stream.get_handle(), Swift.Int32(isServer ? 1 : 0), subProtocol?.get_handle() ?? nil, keepAliveInterval.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocket(hndl : __return);
        }
    }
    // System.Net.WebSockets.WebSocket CreateFromStream(System.IO.Stream, System.Net.WebSockets.WebSocketCreationOptions)
// docid: M:System.Net.WebSockets.WebSocket.CreateFromStream(System.IO.Stream,System.Net.WebSockets.WebSocketCreationOptions)
    /**
    Creates a  that operates on a  representing a web socket connection.

    - Parameter stream: The  for the connection.
    - Parameter options: The options with which the websocket must be created.
    - Returns: The created web socket.

    */
    open class func CreateFromStream(stream : dotnet.System.IO.Stream, options : dotnet.System.Net.WebSockets.WebSocketCreationOptions) throws -> dotnet.System.Net.WebSockets.WebSocket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_WebSocket__CreateFromStream_0__2__Stream_WebSocketCreationOptions(&__thrown, stream.get_handle(), options.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocket(hndl : __return);
        }
    }
    // System.ArraySegment<System.Byte> CreateServerBuffer(System.Int32)
// docid: M:System.Net.WebSockets.WebSocket.CreateServerBuffer(System.Int32)
    /**
    Creates a WebSocket server buffer.

    - Parameter receiveBufferSize: The size, in bytes, of the desired buffer.
    - Returns: Returns .

    */
    open class func CreateServerBuffer(receiveBufferSize : Swift.Int32) throws -> dotnet.System.ArraySegment_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_System_ArraySegment_u8___CreateServerBuffer_0__1__i32(&__thrown, receiveBufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ArraySegment_1(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Net.WebSockets.WebSocket.Dispose
    /**
    Used to clean up unmanaged resources for ASP.NET and self-hosted implementations.

    */
    open func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocket_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool IsApplicationTargeting45()
// docid: M:System.Net.WebSockets.WebSocket.IsApplicationTargeting45
    /**
    Returns a value that indicates if the WebSocket instance is targeting .NET Framework 4.5.

    - Returns: 
         if the  is targeting .NET Framework 4.5; otherwise, .

    */
    open class func IsApplicationTargeting45() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_bool__IsApplicationTargeting45_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Threading.Tasks.Task<System.Net.WebSockets.WebSocketReceiveResult> ReceiveAsync(System.ArraySegment<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.WebSocket.ReceiveAsync(System.ArraySegment{System.Byte},System.Threading.CancellationToken)
    /**
    Receives data from the  connection asynchronously.

    - Parameter buffer: References the application buffer that is the storage location for the received data.
    - Parameter cancellationToken: Propagates the notification that operations should be canceled.
    - Returns: The task object representing the asynchronous operation. The  property on the task object returns a  object that represents the received data.

    */
    open func ReceiveAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken) async throws -> dotnet.System.Net.WebSockets.WebSocketReceiveResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_System_Threading_Tasks_Task_System_Net_WebSockets_WebSocketReceiveResult___ReceiveAsync_0__2__System_ArraySegment_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.WebSockets.ValueWebSocketReceiveResult> ReceiveAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.WebSocket.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Receives data from the  connection asynchronously.

    - Parameter buffer: The application buffer that is the storage location for the received data.
    - Parameter cancellationToken: The cancellation token to use to cancel the receive operation.
    - Returns: The task object representing the asynchronous operation. The  property on the task object returns a  object that represents the received data.

    */
    open func ReceiveAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.WebSockets.ValueWebSocketReceiveResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_System_Threading_Tasks_ValueTask_System_Net_WebSockets_ValueWebSocketReceiveResult___ReceiveAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // void RegisterPrefixes()
// docid: M:System.Net.WebSockets.WebSocket.RegisterPrefixes
    /**
    Allows callers to register prefixes for WebSocket requests (ws and wss).

    */
    open class func RegisterPrefixes() throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocket_void__RegisterPrefixes_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task SendAsync(System.ArraySegment<System.Byte>, System.Net.WebSockets.WebSocketMessageType, bool, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.WebSocket.SendAsync(System.ArraySegment{System.Byte},System.Net.WebSockets.WebSocketMessageType,System.Boolean,System.Threading.CancellationToken)
    /**
    Sends data over the  connection asynchronously.

    - Parameter buffer: The buffer to be sent over the connection.
    - Parameter messageType: Indicates whether the application is sending a binary or text message.
    - Parameter endOfMessage: Indicates whether the data in "buffer" is the last part of a message.
    - Parameter cancellationToken: The token that propagates the notification that operations should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SendAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, endOfMessage : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_Task__SendAsync_0__4__System_ArraySegment_u8__WebSocketMessageType_bool_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), messageType.get_value(), Swift.Int32(endOfMessage ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask SendAsync(System.ReadOnlyMemory<System.Byte>, System.Net.WebSockets.WebSocketMessageType, bool, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.WebSocket.SendAsync(System.ReadOnlyMemory{System.Byte},System.Net.WebSockets.WebSocketMessageType,System.Boolean,System.Threading.CancellationToken)
    /**
    Sends data over the  connection asynchronously.

    - Parameter buffer: The buffer to be sent over the connection.
    - Parameter messageType: One of the enumeration values that indicates whether the application is sending a binary or text message.
    - Parameter endOfMessage: 
         to indicate the data in "buffer" is the last part of a message; otherwise, .
    - Parameter cancellationToken: The cancellation token to use to cancel the send operation.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SendAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, endOfMessage : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_ValueTask__SendAsync_0__4__System_ReadOnlyMemory_u8__WebSocketMessageType_bool_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), messageType.get_value(), Swift.Int32(endOfMessage ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask SendAsync(System.ReadOnlyMemory<System.Byte>, System.Net.WebSockets.WebSocketMessageType, System.Net.WebSockets.WebSocketMessageFlags, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.WebSocket.SendAsync(System.ReadOnlyMemory{System.Byte},System.Net.WebSockets.WebSocketMessageType,System.Net.WebSockets.WebSocketMessageFlags,System.Threading.CancellationToken)
    /**
    Sends data over the  connection asynchronously.

    - Parameter buffer: The buffer to be sent over the connection.
    - Parameter messageType: One of the enumeration values that indicates whether the application is sending a binary or text message.
    - Parameter messageFlags: Flags for controlling how the  should send a message.
    - Parameter cancellationToken: The cancellation token to use to cancel the send operation.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SendAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, messageFlags : dotnet.System.Net.WebSockets.WebSocketMessageFlags, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_ValueTask__SendAsync_0__4__System_ReadOnlyMemory_u8__WebSocketMessageType_WebSocketMessageFlags_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), messageType.get_value(), messageFlags.get_value(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.Nullable<System.Net.WebSockets.WebSocketCloseStatus> get_CloseStatus()
// docid: M:System.Net.WebSockets.WebSocket.get_CloseStatus
    open func get_CloseStatus() throws -> Optional<dotnet.System.Net.WebSockets.WebSocketCloseStatus> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_System_Nullable_System_Net_WebSockets_WebSocketCloseStatus___get_CloseStatus_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Int32_unbox(__return!)) : nil;
        }
    }
    // [IsSpecialName] System.String get_CloseStatusDescription()
// docid: M:System.Net.WebSockets.WebSocket.get_CloseStatusDescription
    open func get_CloseStatusDescription() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_String__get_CloseStatusDescription_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.TimeSpan get_DefaultKeepAliveInterval()
// docid: M:System.Net.WebSockets.WebSocket.get_DefaultKeepAliveInterval
    open class func get_DefaultKeepAliveInterval() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_TimeSpan__get_DefaultKeepAliveInterval_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.WebSockets.WebSocketState get_State()
// docid: M:System.Net.WebSockets.WebSocket.get_State
    open func get_State() throws -> dotnet.System.Net.WebSockets.WebSocketState {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_WebSocketState__get_State_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocketState(val: __return);
        }
    }
    // [IsSpecialName] System.String get_SubProtocol()
// docid: M:System.Net.WebSockets.WebSocket.get_SubProtocol
    open func get_SubProtocol() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocket_String__get_SubProtocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Indicates the reason why the remote endpoint initiated the close handshake.

    */
    open var CloseStatus : Optional<dotnet.System.Net.WebSockets.WebSocketCloseStatus> {
        get {
            return try! get_CloseStatus();
        }
    }
    /**
    Allows the remote endpoint to describe the reason why the connection was closed.

    */
    open var CloseStatusDescription : Optional<dotnet.System.String> {
        get {
            return try! get_CloseStatusDescription();
        }
    }
    /**
    Gets the default WebSocket protocol keep-alive interval.

    */
    public static var DefaultKeepAliveInterval : dotnet.System.TimeSpan {
        get {
            return try! get_DefaultKeepAliveInterval();
        }
    }
    /**
    Returns the current state of the WebSocket connection.

    */
    open var State : dotnet.System.Net.WebSockets.WebSocketState {
        get {
            return try! get_State();
        }
    }
    /**
    Gets the subprotocol that was negotiated during the opening handshake.

    */
    open var SubProtocol : Optional<dotnet.System.String> {
        get {
            return try! get_SubProtocol();
        }
    }
} // WebSocket


// type: System.Net.WebSockets.WebSocketCloseStatus
    /**
    Represents well known WebSocket close codes as defined in section 11.7 of the WebSocket protocol spec.

    */
public struct WebSocketCloseStatus : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketCloseStatus_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.WebSockets.WebSocketCloseStatus NormalClosure
    /**
    (1000) The connection has closed after the request was fulfilled.

    */
    public static var NormalClosure : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_NormalClosure());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus EndpointUnavailable
    /**
    (1001) Indicates an endpoint is being removed. Either the server or client will become unavailable.

    */
    public static var EndpointUnavailable : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_EndpointUnavailable());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus ProtocolError
    /**
    (1002) The client or server is terminating the connection because of a protocol error.

    */
    public static var ProtocolError : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_ProtocolError());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus InvalidMessageType
    /**
    (1003) The client or server is terminating the connection because it cannot accept the data type it received.

    */
    public static var InvalidMessageType : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_InvalidMessageType());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus Empty
    /**
    No error specified.

    */
    public static var Empty : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_Empty());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus InvalidPayloadData
    /**
    (1007) The client or server is terminating the connection because it has received data inconsistent with the message type.

    */
    public static var InvalidPayloadData : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_InvalidPayloadData());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus PolicyViolation
    /**
    (1008) The connection will be closed because an endpoint has received a message that violates its policy.

    */
    public static var PolicyViolation : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_PolicyViolation());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus MessageTooBig
    /**
    (1009) The client or server is terminating the connection because it has received a message that is too big for it to process.

    */
    public static var MessageTooBig : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_MessageTooBig());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus MandatoryExtension
    /**
    (1010) The client is terminating the connection because it expected the server to negotiate an extension.

    */
    public static var MandatoryExtension : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_MandatoryExtension());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketCloseStatus InternalServerError
    /**
    (1011) The connection will be closed by the server because of an error on the server.

    */
    public static var InternalServerError : dotnet.System.Net.WebSockets.WebSocketCloseStatus {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Net_WebSockets_WebSocketCloseStatus_get_InternalServerError());
            return __return;
        }
    }
} // WebSocketCloseStatus


// type: System.Net.WebSockets.WebSocketContext
    /**
    Used for accessing the information in the WebSocket handshake.

    */
open class WebSocketContext
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketContext_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.Net.CookieCollection get_CookieCollection()
// docid: M:System.Net.WebSockets.WebSocketContext.get_CookieCollection
    open func get_CookieCollection() throws -> dotnet.System.Net.CookieCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_CookieCollection__get_CookieCollection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.CookieCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.Collections.Specialized.NameValueCollection get_Headers()
// docid: M:System.Net.WebSockets.WebSocketContext.get_Headers
    open func get_Headers() throws -> dotnet.System.Collections.Specialized.NameValueCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_NameValueCollection__get_Headers_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Specialized.NameValueCollection(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsAuthenticated()
// docid: M:System.Net.WebSockets.WebSocketContext.get_IsAuthenticated
    open func get_IsAuthenticated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_bool__get_IsAuthenticated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsLocal()
// docid: M:System.Net.WebSockets.WebSocketContext.get_IsLocal
    open func get_IsLocal() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_bool__get_IsLocal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSecureConnection()
// docid: M:System.Net.WebSockets.WebSocketContext.get_IsSecureConnection
    open func get_IsSecureConnection() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_bool__get_IsSecureConnection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Origin()
// docid: M:System.Net.WebSockets.WebSocketContext.get_Origin
    open func get_Origin() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_String__get_Origin_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Uri get_RequestUri()
// docid: M:System.Net.WebSockets.WebSocketContext.get_RequestUri
    open func get_RequestUri() throws -> dotnet.System.Uri {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_Uri__get_RequestUri_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Uri(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_SecWebSocketKey()
// docid: M:System.Net.WebSockets.WebSocketContext.get_SecWebSocketKey
    open func get_SecWebSocketKey() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_String__get_SecWebSocketKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<System.String> get_SecWebSocketProtocols()
// docid: M:System.Net.WebSockets.WebSocketContext.get_SecWebSocketProtocols
    open func get_SecWebSocketProtocols() throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_System_Collections_Generic_IEnumerable_string___get_SecWebSocketProtocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_SecWebSocketVersion()
// docid: M:System.Net.WebSockets.WebSocketContext.get_SecWebSocketVersion
    open func get_SecWebSocketVersion() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_String__get_SecWebSocketVersion_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Principal.IPrincipal get_User()
// docid: M:System.Net.WebSockets.WebSocketContext.get_User
    open func get_User() throws -> Optional<dotnet.System.Security.Principal.IPrincipal> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_IPrincipal__get_User_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Principal.IPrincipal(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Net.WebSockets.WebSocket get_WebSocket()
// docid: M:System.Net.WebSockets.WebSocketContext.get_WebSocket
    open func get_WebSocket() throws -> dotnet.System.Net.WebSockets.WebSocket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketContext_WebSocket__get_WebSocket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocket(hndl : __return);
        }
    }
    /**
    The cookies that were passed to the server during the opening handshake.

    */
    open var CookieCollection : dotnet.System.Net.CookieCollection {
        get {
            return try! get_CookieCollection();
        }
    }
    /**
    The HTTP headers that were sent to the server during the opening handshake.

    */
    open var Headers : dotnet.System.Collections.Specialized.NameValueCollection {
        get {
            return try! get_Headers();
        }
    }
    /**
    Whether the WebSocket client is authenticated.

    */
    open var IsAuthenticated : Bool {
        get {
            return try! get_IsAuthenticated();
        }
    }
    /**
    Whether the WebSocket client connected from the local machine.

    */
    open var IsLocal : Bool {
        get {
            return try! get_IsLocal();
        }
    }
    /**
    Whether the WebSocket connection is secured using Secure Sockets Layer (SSL).

    */
    open var IsSecureConnection : Bool {
        get {
            return try! get_IsSecureConnection();
        }
    }
    /**
    The value of the Origin HTTP header included in the opening handshake.

    */
    open var Origin : dotnet.System.String {
        get {
            return try! get_Origin();
        }
    }
    /**
    The URI requested by the WebSocket client.

    */
    open var RequestUri : dotnet.System.Uri {
        get {
            return try! get_RequestUri();
        }
    }
    /**
    The value of the SecWebSocketKey HTTP header included in the opening handshake.

    */
    open var SecWebSocketKey : dotnet.System.String {
        get {
            return try! get_SecWebSocketKey();
        }
    }
    /**
    The value of the SecWebSocketKey HTTP header included in the opening handshake.

    */
    open var SecWebSocketProtocols : dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String> {
        get {
            return try! get_SecWebSocketProtocols();
        }
    }
    /**
    The list of subprotocols requested by the WebSocket client.

    */
    open var SecWebSocketVersion : dotnet.System.String {
        get {
            return try! get_SecWebSocketVersion();
        }
    }
    /**
    An object used to obtain identity, authentication information, and security roles for the WebSocket client.

    */
    open var User : Optional<dotnet.System.Security.Principal.IPrincipal> {
        get {
            return try! get_User();
        }
    }
    /**
    The WebSocket instance used to interact (send/receive/close/etc) with the WebSocket connection.

    */
    open var WebSocket : dotnet.System.Net.WebSockets.WebSocket {
        get {
            return try! get_WebSocket();
        }
    }
} // WebSocketContext


// type: System.Net.WebSockets.WebSocketCreationOptions
    /**
    Options that control how a  is created.

    */
public final class WebSocketCreationOptions
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketCreationOptions_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.#ctor
    /**
    Creates an instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketCreationOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_IsServer()
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.get_IsServer
    public func get_IsServer() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketCreationOptions_bool__get_IsServer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_IsServer(bool)
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.set_IsServer(System.Boolean)
    public func set_IsServer(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketCreationOptions_void__set_IsServer_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_SubProtocol()
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.get_SubProtocol
    public func get_SubProtocol() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketCreationOptions_String__get_SubProtocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SubProtocol(System.String)
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.set_SubProtocol(System.String)
    public func set_SubProtocol(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketCreationOptions_void__set_SubProtocol_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_KeepAliveInterval()
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.get_KeepAliveInterval
    public func get_KeepAliveInterval() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketCreationOptions_TimeSpan__get_KeepAliveInterval_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_KeepAliveInterval(System.TimeSpan)
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.set_KeepAliveInterval(System.TimeSpan)
    public func set_KeepAliveInterval(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketCreationOptions_void__set_KeepAliveInterval_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.WebSockets.WebSocketDeflateOptions get_DangerousDeflateOptions()
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.get_DangerousDeflateOptions
    public func get_DangerousDeflateOptions() throws -> Optional<dotnet.System.Net.WebSockets.WebSocketDeflateOptions> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketCreationOptions_WebSocketDeflateOptions__get_DangerousDeflateOptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.WebSockets.WebSocketDeflateOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_DangerousDeflateOptions(System.Net.WebSockets.WebSocketDeflateOptions)
// docid: M:System.Net.WebSockets.WebSocketCreationOptions.set_DangerousDeflateOptions(System.Net.WebSockets.WebSocketDeflateOptions)
    public func set_DangerousDeflateOptions(value : Optional<dotnet.System.Net.WebSockets.WebSocketDeflateOptions>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketCreationOptions_void__set_DangerousDeflateOptions_0__1__WebSocketDeflateOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    The agreed upon options for per message deflate. Be aware that enabling compression makes the application subject to CRIME/BREACH type of attacks.
            It is strongly advised to turn off compression when sending data containing secrets by specifying  flag for such messages.

    */
    public var DangerousDeflateOptions : Optional<dotnet.System.Net.WebSockets.WebSocketDeflateOptions> {
        get {
            return try! get_DangerousDeflateOptions();
        }
        set(v) {
            return try! set_DangerousDeflateOptions(value: v!);
        }
    }
    /**
    Defines if this websocket is the server-side of the connection. The default value is .

    */
    public var IsServer : Bool {
        get {
            return try! get_IsServer();
        }
        set(v) {
            return try! set_IsServer(value: v);
        }
    }
    /**
    The keep-alive interval to use, or  or  to disable keep-alives.
            The default is .

    */
    public var KeepAliveInterval : dotnet.System.TimeSpan {
        get {
            return try! get_KeepAliveInterval();
        }
        set(v) {
            return try! set_KeepAliveInterval(value: v);
        }
    }
    /**
    The agreed upon sub-protocol that was used when creating the connection.

    */
    public var SubProtocol : Optional<dotnet.System.String> {
        get {
            return try! get_SubProtocol();
        }
        set(v) {
            return try! set_SubProtocol(value: v!);
        }
    }
} // WebSocketCreationOptions


// type: System.Net.WebSockets.WebSocketDeflateOptions
    /**
    Options to enable per-message deflate compression for .

    */
public final class WebSocketDeflateOptions
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketDeflateOptions_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.#ctor
    /**
    Creates an instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketDeflateOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_ClientMaxWindowBits()
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.get_ClientMaxWindowBits
    public func get_ClientMaxWindowBits() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketDeflateOptions_i32__get_ClientMaxWindowBits_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ClientMaxWindowBits(System.Int32)
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.set_ClientMaxWindowBits(System.Int32)
    public func set_ClientMaxWindowBits(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketDeflateOptions_void__set_ClientMaxWindowBits_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ClientContextTakeover()
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.get_ClientContextTakeover
    public func get_ClientContextTakeover() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketDeflateOptions_bool__get_ClientContextTakeover_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ClientContextTakeover(bool)
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.set_ClientContextTakeover(System.Boolean)
    public func set_ClientContextTakeover(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketDeflateOptions_void__set_ClientContextTakeover_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ServerMaxWindowBits()
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.get_ServerMaxWindowBits
    public func get_ServerMaxWindowBits() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketDeflateOptions_i32__get_ServerMaxWindowBits_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ServerMaxWindowBits(System.Int32)
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.set_ServerMaxWindowBits(System.Int32)
    public func set_ServerMaxWindowBits(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketDeflateOptions_void__set_ServerMaxWindowBits_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ServerContextTakeover()
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.get_ServerContextTakeover
    public func get_ServerContextTakeover() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketDeflateOptions_bool__get_ServerContextTakeover_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ServerContextTakeover(bool)
// docid: M:System.Net.WebSockets.WebSocketDeflateOptions.set_ServerContextTakeover(System.Boolean)
    public func set_ServerContextTakeover(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketDeflateOptions_void__set_ServerContextTakeover_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    When  the client-side of the connection indicates that it will persist the deflate context accross messages.
            The default is .

    */
    public var ClientContextTakeover : Bool {
        get {
            return try! get_ClientContextTakeover();
        }
        set(v) {
            return try! set_ClientContextTakeover(value: v);
        }
    }
    /**
    This parameter indicates the base-2 logarithm for the LZ77 sliding window size used by the client to compress messages and by the server to decompress them.
            Must be a value between 9 and 15. The default is 15.

    */
    public var ClientMaxWindowBits : Swift.Int32 {
        get {
            return try! get_ClientMaxWindowBits();
        }
        set(v) {
            return try! set_ClientMaxWindowBits(value: v);
        }
    }
    /**
    When  the server-side of the connection indicates that it will persist the deflate context accross messages.
            The default is .

    */
    public var ServerContextTakeover : Bool {
        get {
            return try! get_ServerContextTakeover();
        }
        set(v) {
            return try! set_ServerContextTakeover(value: v);
        }
    }
    /**
    This parameter indicates the base-2 logarithm for the LZ77 sliding window size used by the server to compress messages and by the client to decompress them.
            Must be a value between 9 and 15. The default is 15.

    */
    public var ServerMaxWindowBits : Swift.Int32 {
        get {
            return try! get_ServerMaxWindowBits();
        }
        set(v) {
            return try! set_ServerMaxWindowBits(value: v);
        }
    }
} // WebSocketDeflateOptions


// type: System.Net.WebSockets.WebSocketError
    /**
    Contains the list of possible WebSocket errors.

    */
public struct WebSocketError : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketError_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.WebSockets.WebSocketError Success
    /**
    Indicates that there was no native error information for the exception.

    */
    public static var Success : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_Success());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError InvalidMessageType
    /**
    Indicates that a WebSocket frame with an unknown opcode was received.

    */
    public static var InvalidMessageType : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_InvalidMessageType());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError Faulted
    /**
    Indicates a general error.

    */
    public static var Faulted : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_Faulted());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError NativeError
    /**
    Indicates that an unknown native error occurred.

    */
    public static var NativeError : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_NativeError());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError NotAWebSocket
    /**
    Indicates that the incoming request was not a valid websocket request.

    */
    public static var NotAWebSocket : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_NotAWebSocket());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError UnsupportedVersion
    /**
    Indicates that the client requested an unsupported version of the WebSocket protocol.

    */
    public static var UnsupportedVersion : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_UnsupportedVersion());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError UnsupportedProtocol
    /**
    Indicates that the client requested an unsupported WebSocket subprotocol.

    */
    public static var UnsupportedProtocol : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_UnsupportedProtocol());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError HeaderError
    /**
    Indicates an error occurred when parsing the HTTP headers during the opening handshake.

    */
    public static var HeaderError : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_HeaderError());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError ConnectionClosedPrematurely
    /**
    Indicates that the connection was terminated unexpectedly.

    */
    public static var ConnectionClosedPrematurely : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_ConnectionClosedPrematurely());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketError InvalidState
    /**
    Indicates the WebSocket is an invalid state for the given operation (such as being closed or aborted).

    */
    public static var InvalidState : dotnet.System.Net.WebSockets.WebSocketError {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketError(val: System_Net_WebSockets_WebSocketError_get_InvalidState());
            return __return;
        }
    }
} // WebSocketError


// type: System.Net.WebSockets.WebSocketException
    /**
    Represents an exception that occurred when performing an operation on a WebSocket connection.

    */
public final class WebSocketException
    :
    dotnet.System.ComponentModel.Win32Exception
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketException_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.WebSockets.WebSocketException.#ctor
    /**
    Creates an instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Int32)
    /**
    Creates an instance of the  class.

    - Parameter nativeError: The native error code for the exception.
    */
    public init(nativeError : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__1__i32(&__thrown, nativeError);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Exception)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Int32,System.Exception)
    /**
    Creates an instance of the  class.

    - Parameter nativeError: The native error code for the exception.
    - Parameter innerException: Indicates the previous exception that led to the current exception.
    */
    public init(nativeError : Swift.Int32, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__2__i32_Exception(&__thrown, nativeError, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.String)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Int32,System.String)
    /**
    Creates an instance of the  class.

    - Parameter nativeError: The native error code for the exception.
    - Parameter message: The description of the error.
    */
    public init(nativeError : Swift.Int32, message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__2__i32_String(&__thrown, nativeError, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__1__WebSocketError(&__thrown, error.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError, System.Exception)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError,System.Exception)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    - Parameter innerException: Indicates the previous exception that led to the current exception.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__2__WebSocketError_Exception(&__thrown, error.get_value(), innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError, System.Int32)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError,System.Int32)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    - Parameter nativeError: The native error code for the exception.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError, nativeError : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__2__WebSocketError_i32(&__thrown, error.get_value(), nativeError);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError, System.Int32, System.Exception)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError,System.Int32,System.Exception)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    - Parameter nativeError: The native error code for the exception.
    - Parameter innerException: Indicates the previous exception that led to the current exception.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError, nativeError : Swift.Int32, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__3__WebSocketError_i32_Exception(&__thrown, error.get_value(), nativeError, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError, System.Int32, System.String)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError,System.Int32,System.String)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    - Parameter nativeError: The native error code for the exception.
    - Parameter message: The description of the error.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError, nativeError : Swift.Int32, message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__3__WebSocketError_i32_String(&__thrown, error.get_value(), nativeError, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError, System.Int32, System.String, System.Exception)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError,System.Int32,System.String,System.Exception)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    - Parameter nativeError: The native error code for the exception.
    - Parameter message: The description of the error.
    - Parameter innerException: Indicates the previous exception that led to the current exception.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError, nativeError : Swift.Int32, message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__4__WebSocketError_i32_String_Exception(&__thrown, error.get_value(), nativeError, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError, System.String)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError,System.String)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    - Parameter message: The description of the error.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError, message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__2__WebSocketError_String(&__thrown, error.get_value(), message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.WebSockets.WebSocketError, System.String, System.Exception)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.Net.WebSockets.WebSocketError,System.String,System.Exception)
    /**
    Creates an instance of the  class.

    - Parameter error: The error from the WebSocketError enumeration.
    - Parameter message: The description of the error.
    - Parameter innerException: Indicates the previous exception that led to the current exception.
    */
    public init(error : dotnet.System.Net.WebSockets.WebSocketError, message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__3__WebSocketError_String_Exception(&__thrown, error.get_value(), message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.String)
    /**
    Creates an instance of the  class.

    - Parameter message: The description of the error.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Net.WebSockets.WebSocketException.#ctor(System.String,System.Exception)
    /**
    Creates an instance of the  class.

    - Parameter message: The description of the error.
    - Parameter innerException: Indicates the previous exception that led to the current exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
// docid: M:System.Net.WebSockets.WebSocketException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    /**
    Sets the SerializationInfo object with the file name and line number where the exception occurred.

    - Parameter info: A SerializationInfo object.
    - Parameter context: The contextual information about the source or destination.
    */
    public override func GetObjectData(info : dotnet.System.Runtime.Serialization.SerializationInfo, context : dotnet.System.Runtime.Serialization.StreamingContext) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_WebSocketException_void__GetObjectData_0__2__SerializationInfo_StreamingContext(&__thrown, self.get_handle(), info.get_handle(), context.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ErrorCode()
// docid: M:System.Net.WebSockets.WebSocketException.get_ErrorCode
    public override func get_ErrorCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketException_i32__get_ErrorCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Net.WebSockets.WebSocketError get_WebSocketErrorCode()
// docid: M:System.Net.WebSockets.WebSocketException.get_WebSocketErrorCode
    public func get_WebSocketErrorCode() throws -> dotnet.System.Net.WebSockets.WebSocketError {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketException_WebSocketError__get_WebSocketErrorCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocketError(val: __return);
        }
    }
    /**
    The native error code for the exception that occurred.

    */
    public override var ErrorCode : Swift.Int32 {
        get {
            return try! get_ErrorCode();
        }
    }
    /**
    Returns a WebSocketError indicating the type of error that occurred.

    */
    public var WebSocketErrorCode : dotnet.System.Net.WebSockets.WebSocketError {
        get {
            return try! get_WebSocketErrorCode();
        }
    }
} // WebSocketException


// type: System.Net.WebSockets.WebSocketMessageFlags
    /**
    Flags for controlling how the  should send a message.

    */
public struct WebSocketMessageFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketMessageFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.WebSockets.WebSocketMessageFlags None
    /**
    None

    */
    public static var None : dotnet.System.Net.WebSockets.WebSocketMessageFlags {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketMessageFlags(val: System_Net_WebSockets_WebSocketMessageFlags_get_None());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketMessageFlags EndOfMessage
    /**
    Indicates that the data in "buffer" is the last part of a message.

    */
    public static var EndOfMessage : dotnet.System.Net.WebSockets.WebSocketMessageFlags {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketMessageFlags(val: System_Net_WebSockets_WebSocketMessageFlags_get_EndOfMessage());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketMessageFlags DisableCompression
    /**
    Disables compression for the message if compression has been enabled for the  instance.

    */
    public static var DisableCompression : dotnet.System.Net.WebSockets.WebSocketMessageFlags {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketMessageFlags(val: System_Net_WebSockets_WebSocketMessageFlags_get_DisableCompression());
            return __return;
        }
    }
} // WebSocketMessageFlags


// type: System.Net.WebSockets.WebSocketMessageType
    /**
    Indicates the message type.

    */
public struct WebSocketMessageType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketMessageType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.WebSockets.WebSocketMessageType Text
    /**
    The message is clear text.

    */
    public static var Text : dotnet.System.Net.WebSockets.WebSocketMessageType {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketMessageType(val: System_Net_WebSockets_WebSocketMessageType_get_Text());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketMessageType Binary
    /**
    The message is in binary format.

    */
    public static var Binary : dotnet.System.Net.WebSockets.WebSocketMessageType {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketMessageType(val: System_Net_WebSockets_WebSocketMessageType_get_Binary());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketMessageType Close
    /**
    A receive has completed because a close message was received.

    */
    public static var Close : dotnet.System.Net.WebSockets.WebSocketMessageType {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketMessageType(val: System_Net_WebSockets_WebSocketMessageType_get_Close());
            return __return;
        }
    }
} // WebSocketMessageType


// type: System.Net.WebSockets.WebSocketReceiveResult
    /**
    An instance of this class represents the result of performing a single ReceiveAsync operation on a WebSocket.

    */
open class WebSocketReceiveResult
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketReceiveResult_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32, System.Net.WebSockets.WebSocketMessageType, bool)
// docid: M:System.Net.WebSockets.WebSocketReceiveResult.#ctor(System.Int32,System.Net.WebSockets.WebSocketMessageType,System.Boolean)
    /**
    Creates an instance of the  class.

    - Parameter count: The number of bytes received.
    - Parameter messageType: The type of message that was received.
    - Parameter endOfMessage: Indicates whether this is the final message.
    */
    public init(count : Swift.Int32, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, endOfMessage : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketReceiveResult_ctor_0__3__i32_WebSocketMessageType_bool(&__thrown, count, messageType.get_value(), Swift.Int32(endOfMessage ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Net.WebSockets.WebSocketMessageType, bool, System.Nullable<System.Net.WebSockets.WebSocketCloseStatus>, System.String)
// docid: M:System.Net.WebSockets.WebSocketReceiveResult.#ctor(System.Int32,System.Net.WebSockets.WebSocketMessageType,System.Boolean,System.Nullable{System.Net.WebSockets.WebSocketCloseStatus},System.String)
    /**
    Creates an instance of the  class.

    - Parameter count: The number of bytes received.
    - Parameter messageType: The type of message that was received.
    - Parameter endOfMessage: Indicates whether this is the final message.
    - Parameter closeStatus: Indicates the  of the connection.
    - Parameter closeStatusDescription: The description of .
    */
    public init(count : Swift.Int32, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, endOfMessage : Bool, closeStatus : Optional<dotnet.System.Net.WebSockets.WebSocketCloseStatus>, closeStatusDescription : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_WebSocketReceiveResult_ctor_0__5__i32_WebSocketMessageType_bool_System_Nullable_System_Net_WebSockets_WebSocketCloseStatus__String(&__thrown, count, messageType.get_value(), Swift.Int32(endOfMessage ? 1 : 0), (closeStatus != nil) ? System_Int32_box(closeStatus!.get_value()) : nil, closeStatusDescription?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Nullable<System.Net.WebSockets.WebSocketCloseStatus> get_CloseStatus()
// docid: M:System.Net.WebSockets.WebSocketReceiveResult.get_CloseStatus
    open func get_CloseStatus() throws -> Optional<dotnet.System.Net.WebSockets.WebSocketCloseStatus> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketReceiveResult_System_Nullable_System_Net_WebSockets_WebSocketCloseStatus___get_CloseStatus_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Int32_unbox(__return!)) : nil;
        }
    }
    // [IsSpecialName] System.String get_CloseStatusDescription()
// docid: M:System.Net.WebSockets.WebSocketReceiveResult.get_CloseStatusDescription
    open func get_CloseStatusDescription() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketReceiveResult_String__get_CloseStatusDescription_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Net.WebSockets.WebSocketReceiveResult.get_Count
    open func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketReceiveResult_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_EndOfMessage()
// docid: M:System.Net.WebSockets.WebSocketReceiveResult.get_EndOfMessage
    open func get_EndOfMessage() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketReceiveResult_bool__get_EndOfMessage_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.WebSockets.WebSocketMessageType get_MessageType()
// docid: M:System.Net.WebSockets.WebSocketReceiveResult.get_MessageType
    open func get_MessageType() throws -> dotnet.System.Net.WebSockets.WebSocketMessageType {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_WebSocketReceiveResult_WebSocketMessageType__get_MessageType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocketMessageType(val: __return);
        }
    }
    /**
    Indicates the reason why the remote endpoint initiated the close handshake.

    */
    open var CloseStatus : Optional<dotnet.System.Net.WebSockets.WebSocketCloseStatus> {
        get {
            return try! get_CloseStatus();
        }
    }
    /**
    Returns the optional description that describes why the close handshake has been initiated by the remote endpoint.

    */
    open var CloseStatusDescription : Optional<dotnet.System.String> {
        get {
            return try! get_CloseStatusDescription();
        }
    }
    /**
    Indicates the number of bytes that the WebSocket received.

    */
    open var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Indicates whether the message has been received completely.

    */
    open var EndOfMessage : Bool {
        get {
            return try! get_EndOfMessage();
        }
    }
    /**
    Indicates whether the current message is a UTF-8 message or a binary message.

    */
    open var MessageType : dotnet.System.Net.WebSockets.WebSocketMessageType {
        get {
            return try! get_MessageType();
        }
    }
} // WebSocketReceiveResult


// type: System.Net.WebSockets.WebSocketState
    /**
    Defines the different states a WebSockets instance can be in.

    */
public struct WebSocketState : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_WebSocketState_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.WebSockets.WebSocketState None
    /**
    Reserved for future use.

    */
    public static var None : dotnet.System.Net.WebSockets.WebSocketState {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketState(val: System_Net_WebSockets_WebSocketState_get_None());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketState Connecting
    /**
    The connection is negotiating the handshake with the remote endpoint.

    */
    public static var Connecting : dotnet.System.Net.WebSockets.WebSocketState {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketState(val: System_Net_WebSockets_WebSocketState_get_Connecting());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketState Open
    /**
    The initial state after the HTTP handshake has been completed.

    */
    public static var Open : dotnet.System.Net.WebSockets.WebSocketState {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketState(val: System_Net_WebSockets_WebSocketState_get_Open());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketState CloseSent
    /**
    A close message was sent to the remote endpoint.

    */
    public static var CloseSent : dotnet.System.Net.WebSockets.WebSocketState {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketState(val: System_Net_WebSockets_WebSocketState_get_CloseSent());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketState CloseReceived
    /**
    A close message was received from the remote endpoint.

    */
    public static var CloseReceived : dotnet.System.Net.WebSockets.WebSocketState {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketState(val: System_Net_WebSockets_WebSocketState_get_CloseReceived());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketState Closed
    /**
    Indicates the WebSocket close handshake completed gracefully.

    */
    public static var Closed : dotnet.System.Net.WebSockets.WebSocketState {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketState(val: System_Net_WebSockets_WebSocketState_get_Closed());
            return __return;
        }
    }
    // static field: System.Net.WebSockets.WebSocketState Aborted
    /**
    Indicates that the WebSocket has been aborted.

    */
    public static var Aborted : dotnet.System.Net.WebSockets.WebSocketState {
        get {
        let __return = dotnet.System.Net.WebSockets.WebSocketState(val: System_Net_WebSockets_WebSocketState_get_Aborted());
            return __return;
        }
    }
} // WebSocketState


}



