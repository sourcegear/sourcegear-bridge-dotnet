// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// Microsoft
// Microsoft.Win32
// Microsoft.Win32.SafeHandles
extension Microsoft.Win32.SafeHandles {
// type: Microsoft.Win32.SafeHandles.SafeNCryptHandle
    /**
    Provides a safe handle that can be used by Cryptography Next Generation (CNG) objects.

    */
open class SafeNCryptHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafeNCryptHandle_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Win32_SafeHandles_SafeNCryptHandle_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] bool get_IsInvalid()
// docid: M:Microsoft.Win32.SafeHandles.SafeNCryptHandle.get_IsInvalid
    open override func get_IsInvalid() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Win32_SafeHandles_SafeNCryptHandle_bool__get_IsInvalid_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets a value that indicates whether the handle is invalid.

    */
    open override var IsInvalid : Bool {
        get {
            return try! get_IsInvalid();
        }
    }
} // SafeNCryptHandle


// type: Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle
    /**
    Provides a safe handle that represents a key (NCRYPT_KEY_HANDLE).

    */
public final class SafeNCryptKeyHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeNCryptHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr, System.Runtime.InteropServices.SafeHandle)
// docid: M:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle.#ctor(System.IntPtr,System.Runtime.InteropServices.SafeHandle)
    /**
    Instantiates a new instance of the  class.

    - Parameter handle: The pre-existing handle to use. Using  returns an invalid handle.
    - Parameter parentHandle: The parent handle of this .
    */
    public init(handle : dotnet.System.IntPtr, parentHandle : dotnet.System.Runtime.InteropServices.SafeHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle_ctor_0__2__IntPtr_SafeHandle(&__thrown, handle.get_value(), parentHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SafeNCryptKeyHandle


// type: Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle
    /**
    Provides a safe handle that represents a key storage provider (NCRYPT_PROV_HANDLE).

    */
public final class SafeNCryptProviderHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeNCryptHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SafeNCryptProviderHandle


// type: Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle
    /**
    Provides a safe handle that represents a secret agreement value (NCRYPT_SECRET_HANDLE).

    */
public final class SafeNCryptSecretHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeNCryptHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafeNCryptSecretHandle_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Win32_SafeHandles_SafeNCryptSecretHandle_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafeNCryptSecretHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SafeNCryptSecretHandle


}



// System
// System.Security
// System.Security.Cryptography
extension System.Security.Cryptography {
// type: System.Security.Cryptography.AesCng
    /**
    Provides a Cryptography Next Generation (CNG) implementation of the Advanced Encryption Standard (AES) algorithm.

    */
public final class AesCng
    :
    dotnet.System.Security.Cryptography.Aes
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AesCng_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_AesCng_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.AesCng.#ctor
    /**
    Initializes a new instance of the  class with an ephemeral key.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesCng_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.AesCng.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified key name, which represents an existing persisted AES key.

    - Parameter keyName: The name of the key.
    */
    public init(keyName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesCng_ctor_0__1__String(&__thrown, keyName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.AesCng.#ctor(System.String,System.Security.Cryptography.CngProvider)
    /**
    Initializes a new instance of the  class with the specified key name, which represents an existing persisted AES key, and the specified key storage provider (KSP).

    - Parameter keyName: The name of the key.
    - Parameter provider: The KSP that contains the key.
    */
    public init(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesCng_ctor_0__2__String_CngProvider(&__thrown, keyName.get_handle(), provider.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.CngProvider, System.Security.Cryptography.CngKeyOpenOptions)
// docid: M:System.Security.Cryptography.AesCng.#ctor(System.String,System.Security.Cryptography.CngProvider,System.Security.Cryptography.CngKeyOpenOptions)
    /**
    Initializes a new instance of the  class with the specified key name, which represents an existing persisted AES key,  the specified key storage provider (KSP) and key open options.

    - Parameter keyName: The name of the key.
    - Parameter provider: The KSP that contains the key.
    - Parameter openOptions: A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.
    */
    public init(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider, openOptions : dotnet.System.Security.Cryptography.CngKeyOpenOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesCng_ctor_0__3__String_CngProvider_CngKeyOpenOptions(&__thrown, keyName.get_handle(), provider.get_handle(), openOptions.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.AesCng.CreateDecryptor
    /**
    Creates a symmetric AES decryptor object with the current key and initialization vector ().

    - Returns: A symmetric AES decryptor object.

    */
    public override func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCng_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesCng.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric AES decryptor object with the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the AES algorithm. The key size must be 128, 192, or 256 bits.
    - Parameter rgbIV: The initialization vector to use for the AES algorithm.
    - Returns: A symmetric AES decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCng_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.AesCng.CreateEncryptor
    /**
    Creates a symmetric AES encryptor object using the current key and initialization vector ().

    - Returns: A symmetric AES encryptor object.

    */
    public override func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCng_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesCng.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric AES encryptor object with the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the AES algorithm. The key size must be 128, 192, or 256 bits.
    - Parameter rgbIV: The initialization vector to use for the AES algorithm.
    - Returns: A symmetric AES encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCng_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.AesCng.GenerateIV
    /**
    Generates a random initialization vector (IV) to use for the AES algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCng_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.AesCng.GenerateKey
    /**
    Generates a random key to use for the AES algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCng_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.AesCng.get_Key
    public override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCng_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.AesCng.set_Key(System.Byte[])
    public override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCng_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.AesCng.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCng_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.AesCng.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCng_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key for the  algorithm.

    */
    public override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the secret key used by the  algorithm.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
} // AesCng


// type: System.Security.Cryptography.CngAlgorithm
    /**
    Encapsulates the name of an encryption algorithm.

    */
public final class CngAlgorithm
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngAlgorithm_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngAlgorithm_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.CngAlgorithm.#ctor(System.String)
    /**
    Initializes a new instance of the  class.

    - Parameter algorithm: The name of the algorithm to initialize.
    */
    public init(algorithm : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngAlgorithm_ctor_0__1__String(&__thrown, algorithm.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.CngAlgorithm.Equals(System.Object)
    /**
    Compares the specified object to the current  object.

    - Parameter obj: An object to be compared to the current  object.
    - Returns: 
         if the  parameter is a  that specifies the same algorithm as the current object; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.CngAlgorithm)
// docid: M:System.Security.Cryptography.CngAlgorithm.Equals(System.Security.Cryptography.CngAlgorithm)
    /**
    Compares the specified  object to the current  object.

    - Parameter other: An object to be compared to the current  object.
    - Returns: 
         if the  parameter specifies the same algorithm as the current object; otherwise, .

    */
    public func Equals(other : Optional<dotnet.System.Security.Cryptography.CngAlgorithm>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_bool__Equals_0__1__CngAlgorithm(&__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.CngAlgorithm.GetHashCode
    /**
    Generates a hash value for the algorithm name that is embedded in the current  object.

    - Returns: The hash value of the embedded algorithm name.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.CngAlgorithm, System.Security.Cryptography.CngAlgorithm)
// docid: M:System.Security.Cryptography.CngAlgorithm.op_Equality(System.Security.Cryptography.CngAlgorithm,System.Security.Cryptography.CngAlgorithm)
    /**
    Determines whether two  objects specify the same algorithm name.

    - Parameter left: An object that specifies an algorithm name.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects specify the same algorithm name; otherwise, .

    */
    public class func op_Equality(left : Optional<dotnet.System.Security.Cryptography.CngAlgorithm>, right : Optional<dotnet.System.Security.Cryptography.CngAlgorithm>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_bool__op_Equality_0__2__CngAlgorithm_CngAlgorithm(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func == (left : dotnet.System.Security.Cryptography.CngAlgorithm, right : dotnet.System.Security.Cryptography.CngAlgorithm) -> Bool
    {
        return try! op_Equality(left: left, right: right);
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.CngAlgorithm, System.Security.Cryptography.CngAlgorithm)
// docid: M:System.Security.Cryptography.CngAlgorithm.op_Inequality(System.Security.Cryptography.CngAlgorithm,System.Security.Cryptography.CngAlgorithm)
    /**
    Determines whether two  objects do not specify the same algorithm.

    - Parameter left: An object that specifies an algorithm name.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects do not specify the same algorithm name; otherwise, .

    */
    public class func op_Inequality(left : Optional<dotnet.System.Security.Cryptography.CngAlgorithm>, right : Optional<dotnet.System.Security.Cryptography.CngAlgorithm>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_bool__op_Inequality_0__2__CngAlgorithm_CngAlgorithm(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func != (left : dotnet.System.Security.Cryptography.CngAlgorithm, right : dotnet.System.Security.Cryptography.CngAlgorithm) -> Bool
    {
        return try! op_Inequality(left: left, right: right);
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.CngAlgorithm.ToString
    /**
    Gets the name of the algorithm that the current  object specifies.

    - Returns: The embedded algorithm name.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Algorithm()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_Algorithm
    public func get_Algorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_String__get_Algorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDiffieHellman()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDiffieHellman
    public class func get_ECDiffieHellman() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDiffieHellman_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDiffieHellmanP256()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDiffieHellmanP256
    public class func get_ECDiffieHellmanP256() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDiffieHellmanP256_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDiffieHellmanP384()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDiffieHellmanP384
    public class func get_ECDiffieHellmanP384() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDiffieHellmanP384_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDiffieHellmanP521()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDiffieHellmanP521
    public class func get_ECDiffieHellmanP521() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDiffieHellmanP521_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDsa()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDsa
    public class func get_ECDsa() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDsa_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDsaP256()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDsaP256
    public class func get_ECDsaP256() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDsaP256_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDsaP384()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDsaP384
    public class func get_ECDsaP384() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDsaP384_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_ECDsaP521()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_ECDsaP521
    public class func get_ECDsaP521() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_ECDsaP521_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_MD5()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_MD5
    public class func get_MD5() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_MD5_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_Rsa()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_Rsa
    public class func get_Rsa() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_Rsa_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_Sha1()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_Sha1
    public class func get_Sha1() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_Sha1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_Sha256()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_Sha256
    public class func get_Sha256() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_Sha256_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_Sha384()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_Sha384
    public class func get_Sha384() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_Sha384_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_Sha512()
// docid: M:System.Security.Cryptography.CngAlgorithm.get_Sha512
    public class func get_Sha512() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithm_CngAlgorithm__get_Sha512_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    /**
    Gets the algorithm name that the current  object specifies.

    */
    public var Algorithm : dotnet.System.String {
        get {
            return try! get_Algorithm();
        }
    }
    /**
    Gets a  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm whose curve is described via a key property.

    */
    public static var ECDiffieHellman : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDiffieHellman();
        }
    }
    /**
    Gets a  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-256 curve.

    */
    public static var ECDiffieHellmanP256 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDiffieHellmanP256();
        }
    }
    /**
    Gets a  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-384 curve.

    */
    public static var ECDiffieHellmanP384 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDiffieHellmanP384();
        }
    }
    /**
    Gets a  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-521 curve.

    */
    public static var ECDiffieHellmanP521 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDiffieHellmanP521();
        }
    }
    /**
    Gets a  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) whose curve is described via a key property.

    */
    public static var ECDsa : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDsa();
        }
    }
    /**
    Gets a  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-256 curve.

    */
    public static var ECDsaP256 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDsaP256();
        }
    }
    /**
    Gets a  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-384 curve.

    */
    public static var ECDsaP384 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDsaP384();
        }
    }
    /**
    Gets a new  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-521 curve.

    */
    public static var ECDsaP521 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_ECDsaP521();
        }
    }
    /**
    Gets a new  object that specifies the Message Digest 5 (MD5) hash algorithm.

    */
    public static var MD5 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_MD5();
        }
    }
    /**
    Gets a new  object that specifies the RSA hash algorithm.

    */
    public static var Rsa : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_Rsa();
        }
    }
    /**
    Gets a new  object that specifies the Secure Hash Algorithm 1 (SHA-1) algorithm.

    */
    public static var Sha1 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_Sha1();
        }
    }
    /**
    Gets a new  object that specifies the Secure Hash Algorithm 256 (SHA-256) algorithm.

    */
    public static var Sha256 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_Sha256();
        }
    }
    /**
    Gets a new  object that specifies the Secure Hash Algorithm 384 (SHA-384) algorithm.

    */
    public static var Sha384 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_Sha384();
        }
    }
    /**
    Gets a new  object that specifies the Secure Hash Algorithm 512 (SHA-512) algorithm.

    */
    public static var Sha512 : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_Sha512();
        }
    }
} // CngAlgorithm


// type: System.Security.Cryptography.CngAlgorithmGroup
    /**
    Encapsulates the name of an encryption algorithm group.

    */
public final class CngAlgorithmGroup
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngAlgorithmGroup_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngAlgorithmGroup_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.#ctor(System.String)
    /**
    Initializes a new instance of the  class.

    - Parameter algorithmGroup: The name of the algorithm group to initialize.
    */
    public init(algorithmGroup : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngAlgorithmGroup_ctor_0__1__String(&__thrown, algorithmGroup.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.Equals(System.Object)
    /**
    Compares the specified object to the current  object.

    - Parameter obj: An object to be compared to the current  object.
    - Returns: 
         if the  parameter is a  that specifies the same algorithm group as the current object; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.CngAlgorithmGroup)
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.Equals(System.Security.Cryptography.CngAlgorithmGroup)
    /**
    Compares the specified  object to the current  object.

    - Parameter other: An object to be compared to the current  object.
    - Returns: 
         if the  parameter specifies the same algorithm group as the current object; otherwise, .

    */
    public func Equals(other : Optional<dotnet.System.Security.Cryptography.CngAlgorithmGroup>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_bool__Equals_0__1__CngAlgorithmGroup(&__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.GetHashCode
    /**
    Generates a hash value for the algorithm group name that is embedded in the current  object.

    - Returns: The hash value of the embedded algorithm group name.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.CngAlgorithmGroup, System.Security.Cryptography.CngAlgorithmGroup)
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.op_Equality(System.Security.Cryptography.CngAlgorithmGroup,System.Security.Cryptography.CngAlgorithmGroup)
    /**
    Determines whether two  objects specify the same algorithm group.

    - Parameter left: An object that specifies an algorithm group.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects specify the same algorithm group; otherwise, .

    */
    public class func op_Equality(left : Optional<dotnet.System.Security.Cryptography.CngAlgorithmGroup>, right : Optional<dotnet.System.Security.Cryptography.CngAlgorithmGroup>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_bool__op_Equality_0__2__CngAlgorithmGroup_CngAlgorithmGroup(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func == (left : dotnet.System.Security.Cryptography.CngAlgorithmGroup, right : dotnet.System.Security.Cryptography.CngAlgorithmGroup) -> Bool
    {
        return try! op_Equality(left: left, right: right);
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.CngAlgorithmGroup, System.Security.Cryptography.CngAlgorithmGroup)
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.op_Inequality(System.Security.Cryptography.CngAlgorithmGroup,System.Security.Cryptography.CngAlgorithmGroup)
    /**
    Determines whether two  objects do not specify the same algorithm group.

    - Parameter left: An object that specifies an algorithm group.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects do not specify the same algorithm group; otherwise, .

    */
    public class func op_Inequality(left : Optional<dotnet.System.Security.Cryptography.CngAlgorithmGroup>, right : Optional<dotnet.System.Security.Cryptography.CngAlgorithmGroup>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_bool__op_Inequality_0__2__CngAlgorithmGroup_CngAlgorithmGroup(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func != (left : dotnet.System.Security.Cryptography.CngAlgorithmGroup, right : dotnet.System.Security.Cryptography.CngAlgorithmGroup) -> Bool
    {
        return try! op_Inequality(left: left, right: right);
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.ToString
    /**
    Gets the name of the algorithm group that the current  object specifies.

    - Returns: The embedded algorithm group name.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_AlgorithmGroup()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.get_AlgorithmGroup
    public func get_AlgorithmGroup() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_String__get_AlgorithmGroup_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithmGroup get_DiffieHellman()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.get_DiffieHellman
    public class func get_DiffieHellman() throws -> dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_CngAlgorithmGroup__get_DiffieHellman_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithmGroup(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithmGroup get_Dsa()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.get_Dsa
    public class func get_Dsa() throws -> dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_CngAlgorithmGroup__get_Dsa_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithmGroup(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithmGroup get_ECDiffieHellman()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.get_ECDiffieHellman
    public class func get_ECDiffieHellman() throws -> dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_CngAlgorithmGroup__get_ECDiffieHellman_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithmGroup(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithmGroup get_ECDsa()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.get_ECDsa
    public class func get_ECDsa() throws -> dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_CngAlgorithmGroup__get_ECDsa_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithmGroup(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithmGroup get_Rsa()
// docid: M:System.Security.Cryptography.CngAlgorithmGroup.get_Rsa
    public class func get_Rsa() throws -> dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngAlgorithmGroup_CngAlgorithmGroup__get_Rsa_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithmGroup(hndl : __return);
        }
    }
    /**
    Gets the name of the algorithm group that the current  object specifies.

    */
    public var AlgorithmGroup : dotnet.System.String {
        get {
            return try! get_AlgorithmGroup();
        }
    }
    /**
    Gets a  object that specifies the Diffie-Hellman family of algorithms.

    */
    public static var DiffieHellman : dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        get {
            return try! get_DiffieHellman();
        }
    }
    /**
    Gets a  object that specifies the Digital Signature Algorithm (DSA) family of algorithms.

    */
    public static var Dsa : dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        get {
            return try! get_Dsa();
        }
    }
    /**
    Gets a  object that specifies the Elliptic Curve Diffie-Hellman (ECDH) family of algorithms.

    */
    public static var ECDiffieHellman : dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        get {
            return try! get_ECDiffieHellman();
        }
    }
    /**
    Gets a  object that specifies the Elliptic Curve Digital Signature Algorithm (ECDSA) family of algorithms.

    */
    public static var ECDsa : dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        get {
            return try! get_ECDsa();
        }
    }
    /**
    Gets a  object that specifies the Rivest-Shamir-Adleman (RSA) family of algorithms.

    */
    public static var Rsa : dotnet.System.Security.Cryptography.CngAlgorithmGroup {
        get {
            return try! get_Rsa();
        }
    }
} // CngAlgorithmGroup


// type: System.Security.Cryptography.CngExportPolicies
    /**
    Specifies the key export policies for a key.

    */
public struct CngExportPolicies : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngExportPolicies_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CngExportPolicies None
    /**
    No export policies are established. Key export is allowed without restriction.

    */
    public static var None : dotnet.System.Security.Cryptography.CngExportPolicies {
        get {
        let __return = dotnet.System.Security.Cryptography.CngExportPolicies(val: System_Security_Cryptography_CngExportPolicies_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngExportPolicies AllowExport
    /**
    The private key can be exported multiple times.

    */
    public static var AllowExport : dotnet.System.Security.Cryptography.CngExportPolicies {
        get {
        let __return = dotnet.System.Security.Cryptography.CngExportPolicies(val: System_Security_Cryptography_CngExportPolicies_get_AllowExport());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngExportPolicies AllowPlaintextExport
    /**
    The private key can be exported multiple times as plaintext.

    */
    public static var AllowPlaintextExport : dotnet.System.Security.Cryptography.CngExportPolicies {
        get {
        let __return = dotnet.System.Security.Cryptography.CngExportPolicies(val: System_Security_Cryptography_CngExportPolicies_get_AllowPlaintextExport());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngExportPolicies AllowArchiving
    /**
    The private key can be exported one time for archiving purposes.

    */
    public static var AllowArchiving : dotnet.System.Security.Cryptography.CngExportPolicies {
        get {
        let __return = dotnet.System.Security.Cryptography.CngExportPolicies(val: System_Security_Cryptography_CngExportPolicies_get_AllowArchiving());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngExportPolicies AllowPlaintextArchiving
    /**
    The private key can be exported one time as plaintext.

    */
    public static var AllowPlaintextArchiving : dotnet.System.Security.Cryptography.CngExportPolicies {
        get {
        let __return = dotnet.System.Security.Cryptography.CngExportPolicies(val: System_Security_Cryptography_CngExportPolicies_get_AllowPlaintextArchiving());
            return __return;
        }
    }
} // CngExportPolicies


// type: System.Security.Cryptography.CngKey
    /**
    Defines the core functionality for keys that are used with Cryptography Next Generation (CNG) objects.

    */
public final class CngKey
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngKey_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngKey_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // System.Security.Cryptography.CngKey Create(System.Security.Cryptography.CngAlgorithm)
// docid: M:System.Security.Cryptography.CngKey.Create(System.Security.Cryptography.CngAlgorithm)
    /**
    Creates a  object that can be used with the specified algorithm.

    - Parameter algorithm: The algorithm that the key will be used with.
    - Returns: An ephemeral key.

    */
    public class func Create(algorithm : dotnet.System.Security.Cryptography.CngAlgorithm) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Create_0__1__CngAlgorithm(&__thrown, algorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Create(System.Security.Cryptography.CngAlgorithm, System.String)
// docid: M:System.Security.Cryptography.CngKey.Create(System.Security.Cryptography.CngAlgorithm,System.String)
    /**
    Creates a named  object that provides the specified algorithm.

    - Parameter algorithm: The algorithm that the key will be used with.
    - Parameter keyName: The key name. If a name is not provided, the key will not be persisted.
    - Returns: A persisted or ephemeral key that provides the specified algorithm.

    */
    public class func Create(algorithm : dotnet.System.Security.Cryptography.CngAlgorithm, keyName : Optional<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Create_0__2__CngAlgorithm_String(&__thrown, algorithm.get_handle(), keyName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Create(System.Security.Cryptography.CngAlgorithm, System.String, System.Security.Cryptography.CngKeyCreationParameters)
// docid: M:System.Security.Cryptography.CngKey.Create(System.Security.Cryptography.CngAlgorithm,System.String,System.Security.Cryptography.CngKeyCreationParameters)
    /**
    Creates a named  object that provides the specified algorithm, using the supplied key creation parameters.

    - Parameter algorithm: The algorithm that the key will be used with.
    - Parameter keyName: The key name. If a name is not provided, the key will not be persisted.
    - Parameter creationParameters: An object that specifies advanced parameters for the method, including the .
    - Returns: A persisted or ephemeral key that provides the specified algorithm.

    */
    public class func Create(algorithm : dotnet.System.Security.Cryptography.CngAlgorithm, keyName : Optional<dotnet.System.String>, creationParameters : Optional<dotnet.System.Security.Cryptography.CngKeyCreationParameters>) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Create_0__3__CngAlgorithm_String_CngKeyCreationParameters(&__thrown, algorithm.get_handle(), keyName?.get_handle() ?? nil, creationParameters?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // void Delete()
// docid: M:System.Security.Cryptography.CngKey.Delete
    /**
    Removes the key that is associated with the object.

    */
    public func Delete() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKey_void__Delete_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Dispose()
// docid: M:System.Security.Cryptography.CngKey.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKey_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Exists(System.String)
// docid: M:System.Security.Cryptography.CngKey.Exists(System.String)
    /**
    Checks to see whether a named key exists in the default key storage provider (KSP).

    - Parameter keyName: The key name.
    - Returns: 
         if the named key exists in the default KSP; otherwise, .

    */
    public class func Exists(keyName : dotnet.System.String) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_bool__Exists_0__1__String(&__thrown, keyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Exists(System.String, System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.CngKey.Exists(System.String,System.Security.Cryptography.CngProvider)
    /**
    Checks to see whether a named key exists in the specified key storage provider (KSP).

    - Parameter keyName: The key name.
    - Parameter provider: The KSP to check for the key.
    - Returns: 
         if the named key exists in the specified provider; otherwise, .

    */
    public class func Exists(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_bool__Exists_0__2__String_CngProvider(&__thrown, keyName.get_handle(), provider.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Exists(System.String, System.Security.Cryptography.CngProvider, System.Security.Cryptography.CngKeyOpenOptions)
// docid: M:System.Security.Cryptography.CngKey.Exists(System.String,System.Security.Cryptography.CngProvider,System.Security.Cryptography.CngKeyOpenOptions)
    /**
    Checks to see whether a named key exists in the specified key storage provider (KSP), according to the specified options.

    - Parameter keyName: The key name.
    - Parameter provider: The KSP to search for the key.
    - Parameter options: A bitwise combination of the enumeration values that specify options for opening a key.
    - Returns: 
         if the named key exists in the specified provider; otherwise, .

    */
    public class func Exists(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider, options : dotnet.System.Security.Cryptography.CngKeyOpenOptions) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_bool__Exists_0__3__String_CngProvider_CngKeyOpenOptions(&__thrown, keyName.get_handle(), provider.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Byte[] Export(System.Security.Cryptography.CngKeyBlobFormat)
// docid: M:System.Security.Cryptography.CngKey.Export(System.Security.Cryptography.CngKeyBlobFormat)
    /**
    Exports the key material into a BLOB, in the specified format.

    - Parameter format: An object that specifies the format of the key BLOB.
    - Returns: A BLOB that contains the key material in the specified format.

    */
    public func Export(format : dotnet.System.Security.Cryptography.CngKeyBlobFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_u8Array__Export_0__1__CngKeyBlobFormat(&__thrown, self.get_handle(), format.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngProperty GetProperty(System.String, System.Security.Cryptography.CngPropertyOptions)
// docid: M:System.Security.Cryptography.CngKey.GetProperty(System.String,System.Security.Cryptography.CngPropertyOptions)
    /**
    Gets a property, given a name and a set of property options.

    - Parameter name: The name of the desired property.
    - Parameter options: A bitwise combination of the enumeration values that specify options for the named property.
    - Returns: An object that contains the raw value of the specified property.

    */
    public func GetProperty(name : dotnet.System.String, options : dotnet.System.Security.Cryptography.CngPropertyOptions) throws -> dotnet.System.Security.Cryptography.CngProperty {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngProperty__GetProperty_0__2__String_CngPropertyOptions(&__thrown, self.get_handle(), name.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngProperty(hndl : __return);
        }
    }
    // bool HasProperty(System.String, System.Security.Cryptography.CngPropertyOptions)
// docid: M:System.Security.Cryptography.CngKey.HasProperty(System.String,System.Security.Cryptography.CngPropertyOptions)
    /**
    Checks to see whether the specified property exists on the key.

    - Parameter name: The property name to check.
    - Parameter options: A bitwise combination of the enumeration values that specify options for the named property.
    - Returns: 
         if the specified property is found; otherwise, .

    */
    public func HasProperty(name : dotnet.System.String, options : dotnet.System.Security.Cryptography.CngPropertyOptions) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_bool__HasProperty_0__2__String_CngPropertyOptions(&__thrown, self.get_handle(), name.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Security.Cryptography.CngKey Import(System.Byte[], System.Security.Cryptography.CngKeyBlobFormat)
// docid: M:System.Security.Cryptography.CngKey.Import(System.Byte[],System.Security.Cryptography.CngKeyBlobFormat)
    /**
    Creates a new key by importing the specified key material into the default key storage provider (KSP) and using the specified format.

    - Parameter keyBlob: An array that contains the key information.
    - Parameter format: An object that specifies the format of the  array.
    - Returns: A new key.

    */
    public class func Import(keyBlob : dotnet.System_Arr<Swift.UInt8>, format : dotnet.System.Security.Cryptography.CngKeyBlobFormat) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Import_0__2__u8Array_CngKeyBlobFormat(&__thrown, keyBlob.get_handle(), format.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Import(System.Byte[], System.Security.Cryptography.CngKeyBlobFormat, System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.CngKey.Import(System.Byte[],System.Security.Cryptography.CngKeyBlobFormat,System.Security.Cryptography.CngProvider)
    /**
    Creates a new key by importing the specified key material into the specified key storage provider (KSP), using the specified format.

    - Parameter keyBlob: An array that contains the key information.
    - Parameter format: An object that specifies the format of the  array.
    - Parameter provider: The KSP.
    - Returns: A new key.

    */
    public class func Import(keyBlob : dotnet.System_Arr<Swift.UInt8>, format : dotnet.System.Security.Cryptography.CngKeyBlobFormat, provider : dotnet.System.Security.Cryptography.CngProvider) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Import_0__3__u8Array_CngKeyBlobFormat_CngProvider(&__thrown, keyBlob.get_handle(), format.get_handle(), provider.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Open(Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle, System.Security.Cryptography.CngKeyHandleOpenOptions)
// docid: M:System.Security.Cryptography.CngKey.Open(Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle,System.Security.Cryptography.CngKeyHandleOpenOptions)
    /**
    Creates an instance of an  object by using a handle to an existing key.

    - Parameter keyHandle: A handle to an existing key.
    - Parameter keyHandleOpenOptions: One of the enumeration values that indicates whether  represents an ephemeral key or a named key.
    - Returns: An existing key.

    */
    public class func Open(keyHandle : dotnet.Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle, keyHandleOpenOptions : dotnet.System.Security.Cryptography.CngKeyHandleOpenOptions) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Open_0__2__SafeNCryptKeyHandle_CngKeyHandleOpenOptions(&__thrown, keyHandle.get_handle(), keyHandleOpenOptions.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Open(System.String)
// docid: M:System.Security.Cryptography.CngKey.Open(System.String)
    /**
    Creates an instance of an  object that represents an existing named key.

    - Parameter keyName: The name of the key.
    - Returns: An existing key.

    */
    public class func Open(keyName : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Open_0__1__String(&__thrown, keyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Open(System.String, System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.CngKey.Open(System.String,System.Security.Cryptography.CngProvider)
    /**
    Creates an instance of an  object that represents an existing named key, using the specified key storage provider (KSP).

    - Parameter keyName: The name of the key.
    - Parameter provider: The KSP that contains the key.
    - Returns: An existing key.

    */
    public class func Open(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Open_0__2__String_CngProvider(&__thrown, keyName.get_handle(), provider.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Open(System.String, System.Security.Cryptography.CngProvider, System.Security.Cryptography.CngKeyOpenOptions)
// docid: M:System.Security.Cryptography.CngKey.Open(System.String,System.Security.Cryptography.CngProvider,System.Security.Cryptography.CngKeyOpenOptions)
    /**
    Creates an instance of an  object that represents an existing named key, using the specified key storage provider (KSP) and key open options.

    - Parameter keyName: The name of the key.
    - Parameter provider: The KSP that contains the key.
    - Parameter openOptions: A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.
    - Returns: An existing key.

    */
    public class func Open(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider, openOptions : dotnet.System.Security.Cryptography.CngKeyOpenOptions) throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKey__Open_0__3__String_CngProvider_CngKeyOpenOptions(&__thrown, keyName.get_handle(), provider.get_handle(), openOptions.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // void SetProperty(System.Security.Cryptography.CngProperty)
// docid: M:System.Security.Cryptography.CngKey.SetProperty(System.Security.Cryptography.CngProperty)
    /**
    Sets a named property on the key.

    - Parameter property: The key property to set.
    */
    public func SetProperty(property : dotnet.System.Security.Cryptography.CngProperty) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKey_void__SetProperty_0__1__CngProperty(&__thrown, self.get_handle(), property.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_Algorithm()
// docid: M:System.Security.Cryptography.CngKey.get_Algorithm
    public func get_Algorithm() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngAlgorithm__get_Algorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithmGroup get_AlgorithmGroup()
// docid: M:System.Security.Cryptography.CngKey.get_AlgorithmGroup
    public func get_AlgorithmGroup() throws -> Optional<dotnet.System.Security.Cryptography.CngAlgorithmGroup> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngAlgorithmGroup__get_AlgorithmGroup_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.CngAlgorithmGroup(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngExportPolicies get_ExportPolicy()
// docid: M:System.Security.Cryptography.CngKey.get_ExportPolicy
    public func get_ExportPolicy() throws -> dotnet.System.Security.Cryptography.CngExportPolicies {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngExportPolicies__get_ExportPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngExportPolicies(val: __return);
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle get_Handle()
// docid: M:System.Security.Cryptography.CngKey.get_Handle
    public func get_Handle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_SafeNCryptKeyHandle__get_Handle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsEphemeral()
// docid: M:System.Security.Cryptography.CngKey.get_IsEphemeral
    public func get_IsEphemeral() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_bool__get_IsEphemeral_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsMachineKey()
// docid: M:System.Security.Cryptography.CngKey.get_IsMachineKey
    public func get_IsMachineKey() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_bool__get_IsMachineKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_KeyName()
// docid: M:System.Security.Cryptography.CngKey.get_KeyName
    public func get_KeyName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_String__get_KeyName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.CngKey.get_KeySize
    public func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyUsages get_KeyUsage()
// docid: M:System.Security.Cryptography.CngKey.get_KeyUsage
    public func get_KeyUsage() throws -> dotnet.System.Security.Cryptography.CngKeyUsages {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngKeyUsages__get_KeyUsage_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyUsages(val: __return);
        }
    }
    // [IsSpecialName] System.IntPtr get_ParentWindowHandle()
// docid: M:System.Security.Cryptography.CngKey.get_ParentWindowHandle
    public func get_ParentWindowHandle() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_IntPtr__get_ParentWindowHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] void set_ParentWindowHandle(System.IntPtr)
// docid: M:System.Security.Cryptography.CngKey.set_ParentWindowHandle(System.IntPtr)
    public func set_ParentWindowHandle(value : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKey_void__set_ParentWindowHandle_0__1__IntPtr(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngProvider get_Provider()
// docid: M:System.Security.Cryptography.CngKey.get_Provider
    public func get_Provider() throws -> Optional<dotnet.System.Security.Cryptography.CngProvider> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngProvider__get_Provider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.CngProvider(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle get_ProviderHandle()
// docid: M:System.Security.Cryptography.CngKey.get_ProviderHandle
    public func get_ProviderHandle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_SafeNCryptProviderHandle__get_ProviderHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngUIPolicy get_UIPolicy()
// docid: M:System.Security.Cryptography.CngKey.get_UIPolicy
    public func get_UIPolicy() throws -> dotnet.System.Security.Cryptography.CngUIPolicy {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_CngUIPolicy__get_UIPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngUIPolicy(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_UniqueName()
// docid: M:System.Security.Cryptography.CngKey.get_UniqueName
    public func get_UniqueName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKey_String__get_UniqueName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the algorithm that is used by the key.

    */
    public var Algorithm : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_Algorithm();
        }
    }
    /**
    Gets the algorithm group that is used by the key.

    */
    public var AlgorithmGroup : Optional<dotnet.System.Security.Cryptography.CngAlgorithmGroup> {
        get {
            return try! get_AlgorithmGroup();
        }
    }
    /**
    Gets the export policy that is used by the key.

    */
    public var ExportPolicy : dotnet.System.Security.Cryptography.CngExportPolicies {
        get {
            return try! get_ExportPolicy();
        }
    }
    /**
    Gets a safe handle that represents a native key (NCRYPT_KEY_HANDLE).

    */
    public var Handle : dotnet.Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle {
        get {
            return try! get_Handle();
        }
    }
    /**
    Gets the persistence state of the key.

    */
    public var IsEphemeral : Bool {
        get {
            return try! get_IsEphemeral();
        }
    }
    /**
    Gets the scope (machine or user) of the key.

    */
    public var IsMachineKey : Bool {
        get {
            return try! get_IsMachineKey();
        }
    }
    /**
    Gets the name of the key.

    */
    public var KeyName : Optional<dotnet.System.String> {
        get {
            return try! get_KeyName();
        }
    }
    /**
    Gets the key size in bits.

    */
    public var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
    }
    /**
    Gets the cryptographic operations specified by the key.

    */
    public var KeyUsage : dotnet.System.Security.Cryptography.CngKeyUsages {
        get {
            return try! get_KeyUsage();
        }
    }
    /**
    Gets or sets the window handle (HWND) that should be used for user interface (UI) prompts caused by accessing the key.

    */
    public var ParentWindowHandle : dotnet.System.IntPtr {
        get {
            return try! get_ParentWindowHandle();
        }
        set(v) {
            return try! set_ParentWindowHandle(value: v);
        }
    }
    /**
    Gets the key storage provider (KSP) that manages the key.

    */
    public var Provider : Optional<dotnet.System.Security.Cryptography.CngProvider> {
        get {
            return try! get_Provider();
        }
    }
    /**
    Gets a native handle (an NCRYPT_PROV_HANDLE) to the key storage provider (KSP).

    */
    public var ProviderHandle : dotnet.Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle {
        get {
            return try! get_ProviderHandle();
        }
    }
    /**
    Gets parameters that control the user interface (UI) for accessing the key.

    */
    public var UIPolicy : dotnet.System.Security.Cryptography.CngUIPolicy {
        get {
            return try! get_UIPolicy();
        }
    }
    /**
    Gets the unique name for the key.

    */
    public var UniqueName : Optional<dotnet.System.String> {
        get {
            return try! get_UniqueName();
        }
    }
} // CngKey


// type: System.Security.Cryptography.CngKeyBlobFormat
    /**
    Specifies a key BLOB format for use with Microsoft Cryptography Next Generation (CNG) objects.

    */
public final class CngKeyBlobFormat
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngKeyBlobFormat_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngKeyBlobFormat_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.#ctor(System.String)
    /**
    Initializes a new instance of the  class by using the specified format.

    - Parameter format: The key BLOB format to initialize.
    */
    public init(format : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngKeyBlobFormat_ctor_0__1__String(&__thrown, format.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.Equals(System.Object)
    /**
    Compares the specified object to the current  object.

    - Parameter obj: An object to be compared to the current  object.
    - Returns: 
         if the  parameter is a  object that specifies the same key BLOB format as the current object; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.CngKeyBlobFormat)
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.Equals(System.Security.Cryptography.CngKeyBlobFormat)
    /**
    Compares the specified  object to the current  object.

    - Parameter other: An object to be compared to the current  object.
    - Returns: 
         if the  parameter specifies the same key BLOB format as the current object; otherwise, .

    */
    public func Equals(other : Optional<dotnet.System.Security.Cryptography.CngKeyBlobFormat>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_bool__Equals_0__1__CngKeyBlobFormat(&__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.GetHashCode
    /**
    Generates a hash value for the embedded key BLOB format in the current  object.

    - Returns: The hash value of the embedded key BLOB format.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.CngKeyBlobFormat, System.Security.Cryptography.CngKeyBlobFormat)
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.op_Equality(System.Security.Cryptography.CngKeyBlobFormat,System.Security.Cryptography.CngKeyBlobFormat)
    /**
    Determines whether two  objects specify the same key BLOB format.

    - Parameter left: An object that specifies a key BLOB format.
    - Parameter right: A second object, to be compared to the object identified by the  parameter.
    - Returns: 
         if the two objects specify the same key BLOB format; otherwise, .

    */
    public class func op_Equality(left : Optional<dotnet.System.Security.Cryptography.CngKeyBlobFormat>, right : Optional<dotnet.System.Security.Cryptography.CngKeyBlobFormat>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_bool__op_Equality_0__2__CngKeyBlobFormat_CngKeyBlobFormat(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func == (left : dotnet.System.Security.Cryptography.CngKeyBlobFormat, right : dotnet.System.Security.Cryptography.CngKeyBlobFormat) -> Bool
    {
        return try! op_Equality(left: left, right: right);
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.CngKeyBlobFormat, System.Security.Cryptography.CngKeyBlobFormat)
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.op_Inequality(System.Security.Cryptography.CngKeyBlobFormat,System.Security.Cryptography.CngKeyBlobFormat)
    /**
    Determines whether two  objects do not specify the same key BLOB format.

    - Parameter left: An object that specifies a key BLOB format.
    - Parameter right: A second object, to be compared to the object identified by the  parameter.
    - Returns: 
         if the two objects do not specify the same key BLOB format; otherwise, .

    */
    public class func op_Inequality(left : Optional<dotnet.System.Security.Cryptography.CngKeyBlobFormat>, right : Optional<dotnet.System.Security.Cryptography.CngKeyBlobFormat>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_bool__op_Inequality_0__2__CngKeyBlobFormat_CngKeyBlobFormat(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func != (left : dotnet.System.Security.Cryptography.CngKeyBlobFormat, right : dotnet.System.Security.Cryptography.CngKeyBlobFormat) -> Bool
    {
        return try! op_Inequality(left: left, right: right);
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.ToString
    /**
    Gets the name of the key BLOB format that the current  object specifies.

    - Returns: The embedded key BLOB format name.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_EccFullPrivateBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_EccFullPrivateBlob
    public class func get_EccFullPrivateBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_EccFullPrivateBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_EccFullPublicBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_EccFullPublicBlob
    public class func get_EccFullPublicBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_EccFullPublicBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_EccPrivateBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_EccPrivateBlob
    public class func get_EccPrivateBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_EccPrivateBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_EccPublicBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_EccPublicBlob
    public class func get_EccPublicBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_EccPublicBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Format()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_Format
    public func get_Format() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_String__get_Format_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_GenericPrivateBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_GenericPrivateBlob
    public class func get_GenericPrivateBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_GenericPrivateBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_GenericPublicBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_GenericPublicBlob
    public class func get_GenericPublicBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_GenericPublicBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_OpaqueTransportBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_OpaqueTransportBlob
    public class func get_OpaqueTransportBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_OpaqueTransportBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_Pkcs8PrivateBlob()
// docid: M:System.Security.Cryptography.CngKeyBlobFormat.get_Pkcs8PrivateBlob
    public class func get_Pkcs8PrivateBlob() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyBlobFormat_CngKeyBlobFormat__get_Pkcs8PrivateBlob_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    /**
    Gets a  object that specifies a private key BLOB for an elliptic curve cryptography (ECC) key which contains explicit curve parameters.

    */
    public static var EccFullPrivateBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_EccFullPrivateBlob();
        }
    }
    /**
    Gets a  object that specifies a public key BLOB for an elliptic curve cryptography (ECC) key which contains explicit curve parameters.

    */
    public static var EccFullPublicBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_EccFullPublicBlob();
        }
    }
    /**
    Gets a  object that specifies a private key BLOB for an elliptic curve cryptography (ECC) key.

    */
    public static var EccPrivateBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_EccPrivateBlob();
        }
    }
    /**
    Gets a  object that specifies a public key BLOB for an elliptic curve cryptography (ECC) key.

    */
    public static var EccPublicBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_EccPublicBlob();
        }
    }
    /**
    Gets the name of the key BLOB format that the current  object specifies.

    */
    public var Format : dotnet.System.String {
        get {
            return try! get_Format();
        }
    }
    /**
    Gets a  object that specifies a generic private key BLOB.

    */
    public static var GenericPrivateBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_GenericPrivateBlob();
        }
    }
    /**
    Gets a  object that specifies a generic public key BLOB.

    */
    public static var GenericPublicBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_GenericPublicBlob();
        }
    }
    /**
    Gets a  object that specifies an opaque transport key BLOB.

    */
    public static var OpaqueTransportBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_OpaqueTransportBlob();
        }
    }
    /**
    Gets a  object that specifies a Private Key Information Syntax Standard (PKCS #8) key BLOB.

    */
    public static var Pkcs8PrivateBlob : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_Pkcs8PrivateBlob();
        }
    }
} // CngKeyBlobFormat


// type: System.Security.Cryptography.CngKeyCreationOptions
    /**
    Specifies options used for key creation.

    */
public struct CngKeyCreationOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngKeyCreationOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CngKeyCreationOptions None
    /**
    No key creation options are used.

    */
    public static var None : dotnet.System.Security.Cryptography.CngKeyCreationOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyCreationOptions(val: System_Security_Cryptography_CngKeyCreationOptions_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyCreationOptions MachineKey
    /**
    A machine-wide key is created.

    */
    public static var MachineKey : dotnet.System.Security.Cryptography.CngKeyCreationOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyCreationOptions(val: System_Security_Cryptography_CngKeyCreationOptions_get_MachineKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyCreationOptions OverwriteExistingKey
    /**
    The existing key is overwritten during key creation.

    */
    public static var OverwriteExistingKey : dotnet.System.Security.Cryptography.CngKeyCreationOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyCreationOptions(val: System_Security_Cryptography_CngKeyCreationOptions_get_OverwriteExistingKey());
            return __return;
        }
    }
} // CngKeyCreationOptions


// type: System.Security.Cryptography.CngKeyCreationParameters
    /**
    Contains advanced properties for key creation.

    */
public final class CngKeyCreationParameters
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngKeyCreationParameters_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngKeyCreationParameters_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngKeyCreationParameters_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Nullable<System.Security.Cryptography.CngExportPolicies> get_ExportPolicy()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.get_ExportPolicy
    public func get_ExportPolicy() throws -> Optional<dotnet.System.Security.Cryptography.CngExportPolicies> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyCreationParameters_System_Nullable_System_Security_Cryptography_CngExportPolicies___get_ExportPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? dotnet.System.Security.Cryptography.CngExportPolicies(val: System_Int32_unbox(__return!)) : nil;
        }
    }
    // [IsSpecialName] void set_ExportPolicy(System.Nullable<System.Security.Cryptography.CngExportPolicies>)
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.set_ExportPolicy(System.Nullable{System.Security.Cryptography.CngExportPolicies})
    public func set_ExportPolicy(value : Optional<dotnet.System.Security.Cryptography.CngExportPolicies>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKeyCreationParameters_void__set_ExportPolicy_0__1__System_Nullable_System_Security_Cryptography_CngExportPolicies_(&__thrown, self.get_handle(), (value != nil) ? System_Int32_box(value!.get_value()) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyCreationOptions get_KeyCreationOptions()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.get_KeyCreationOptions
    public func get_KeyCreationOptions() throws -> dotnet.System.Security.Cryptography.CngKeyCreationOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyCreationParameters_CngKeyCreationOptions__get_KeyCreationOptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyCreationOptions(val: __return);
        }
    }
    // [IsSpecialName] void set_KeyCreationOptions(System.Security.Cryptography.CngKeyCreationOptions)
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.set_KeyCreationOptions(System.Security.Cryptography.CngKeyCreationOptions)
    public func set_KeyCreationOptions(value : dotnet.System.Security.Cryptography.CngKeyCreationOptions) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKeyCreationParameters_void__set_KeyCreationOptions_0__1__CngKeyCreationOptions(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Security.Cryptography.CngKeyUsages> get_KeyUsage()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.get_KeyUsage
    public func get_KeyUsage() throws -> Optional<dotnet.System.Security.Cryptography.CngKeyUsages> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyCreationParameters_System_Nullable_System_Security_Cryptography_CngKeyUsages___get_KeyUsage_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? dotnet.System.Security.Cryptography.CngKeyUsages(val: System_Int32_unbox(__return!)) : nil;
        }
    }
    // [IsSpecialName] void set_KeyUsage(System.Nullable<System.Security.Cryptography.CngKeyUsages>)
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.set_KeyUsage(System.Nullable{System.Security.Cryptography.CngKeyUsages})
    public func set_KeyUsage(value : Optional<dotnet.System.Security.Cryptography.CngKeyUsages>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKeyCreationParameters_void__set_KeyUsage_0__1__System_Nullable_System_Security_Cryptography_CngKeyUsages_(&__thrown, self.get_handle(), (value != nil) ? System_Int32_box(value!.get_value()) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngPropertyCollection get_Parameters()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.get_Parameters
    public func get_Parameters() throws -> dotnet.System.Security.Cryptography.CngPropertyCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyCreationParameters_CngPropertyCollection__get_Parameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngPropertyCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.IntPtr get_ParentWindowHandle()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.get_ParentWindowHandle
    public func get_ParentWindowHandle() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyCreationParameters_IntPtr__get_ParentWindowHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] void set_ParentWindowHandle(System.IntPtr)
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.set_ParentWindowHandle(System.IntPtr)
    public func set_ParentWindowHandle(value : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKeyCreationParameters_void__set_ParentWindowHandle_0__1__IntPtr(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngProvider get_Provider()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.get_Provider
    public func get_Provider() throws -> dotnet.System.Security.Cryptography.CngProvider {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyCreationParameters_CngProvider__get_Provider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngProvider(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Provider(System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.set_Provider(System.Security.Cryptography.CngProvider)
    public func set_Provider(value : dotnet.System.Security.Cryptography.CngProvider) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKeyCreationParameters_void__set_Provider_0__1__CngProvider(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngUIPolicy get_UIPolicy()
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.get_UIPolicy
    public func get_UIPolicy() throws -> Optional<dotnet.System.Security.Cryptography.CngUIPolicy> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngKeyCreationParameters_CngUIPolicy__get_UIPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.CngUIPolicy(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_UIPolicy(System.Security.Cryptography.CngUIPolicy)
// docid: M:System.Security.Cryptography.CngKeyCreationParameters.set_UIPolicy(System.Security.Cryptography.CngUIPolicy)
    public func set_UIPolicy(value : Optional<dotnet.System.Security.Cryptography.CngUIPolicy>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CngKeyCreationParameters_void__set_UIPolicy_0__1__CngUIPolicy(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key export policy.

    */
    public var ExportPolicy : Optional<dotnet.System.Security.Cryptography.CngExportPolicies> {
        get {
            return try! get_ExportPolicy();
        }
        set(v) {
            return try! set_ExportPolicy(value: v!);
        }
    }
    /**
    Gets or sets the key creation options.

    */
    public var KeyCreationOptions : dotnet.System.Security.Cryptography.CngKeyCreationOptions {
        get {
            return try! get_KeyCreationOptions();
        }
        set(v) {
            return try! set_KeyCreationOptions(value: v);
        }
    }
    /**
    Gets or sets the cryptographic operations that apply to the current key.

    */
    public var KeyUsage : Optional<dotnet.System.Security.Cryptography.CngKeyUsages> {
        get {
            return try! get_KeyUsage();
        }
        set(v) {
            return try! set_KeyUsage(value: v!);
        }
    }
    /**
    Enables a  object to be created with additional properties that are set before the key is finalized.

    */
    public var Parameters : dotnet.System.Security.Cryptography.CngPropertyCollection {
        get {
            return try! get_Parameters();
        }
    }
    /**
    Gets or sets the window handle that should be used as the parent window for dialog boxes that are created by Cryptography Next Generation (CNG) classes.

    */
    public var ParentWindowHandle : dotnet.System.IntPtr {
        get {
            return try! get_ParentWindowHandle();
        }
        set(v) {
            return try! set_ParentWindowHandle(value: v);
        }
    }
    /**
    Gets or sets the key storage provider (KSP) to create a key in.

    */
    public var Provider : dotnet.System.Security.Cryptography.CngProvider {
        get {
            return try! get_Provider();
        }
        set(v) {
            return try! set_Provider(value: v);
        }
    }
    /**
    Gets or sets information about the user interface to display when a key is created or accessed.

    */
    public var UIPolicy : Optional<dotnet.System.Security.Cryptography.CngUIPolicy> {
        get {
            return try! get_UIPolicy();
        }
        set(v) {
            return try! set_UIPolicy(value: v!);
        }
    }
} // CngKeyCreationParameters


// type: System.Security.Cryptography.CngKeyHandleOpenOptions
    /**
    Specifies options for opening key handles.

    */
public struct CngKeyHandleOpenOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngKeyHandleOpenOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CngKeyHandleOpenOptions None
    /**
    The key handle being opened does not specify an ephemeral key.

    */
    public static var None : dotnet.System.Security.Cryptography.CngKeyHandleOpenOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyHandleOpenOptions(val: System_Security_Cryptography_CngKeyHandleOpenOptions_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyHandleOpenOptions EphemeralKey
    /**
    The key handle being opened specifies an ephemeral key.

    */
    public static var EphemeralKey : dotnet.System.Security.Cryptography.CngKeyHandleOpenOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyHandleOpenOptions(val: System_Security_Cryptography_CngKeyHandleOpenOptions_get_EphemeralKey());
            return __return;
        }
    }
} // CngKeyHandleOpenOptions


// type: System.Security.Cryptography.CngKeyOpenOptions
    /**
    Specifies options for opening a key.

    */
public struct CngKeyOpenOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngKeyOpenOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CngKeyOpenOptions None
    /**
    No key open options are specified.

    */
    public static var None : dotnet.System.Security.Cryptography.CngKeyOpenOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyOpenOptions(val: System_Security_Cryptography_CngKeyOpenOptions_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyOpenOptions UserKey
    /**
    If the  value is not specified, a user key is opened instead.

    */
    public static var UserKey : dotnet.System.Security.Cryptography.CngKeyOpenOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyOpenOptions(val: System_Security_Cryptography_CngKeyOpenOptions_get_UserKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyOpenOptions MachineKey
    /**
    A machine-wide key is opened.

    */
    public static var MachineKey : dotnet.System.Security.Cryptography.CngKeyOpenOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyOpenOptions(val: System_Security_Cryptography_CngKeyOpenOptions_get_MachineKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyOpenOptions Silent
    /**
    UI prompting is suppressed.

    */
    public static var Silent : dotnet.System.Security.Cryptography.CngKeyOpenOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyOpenOptions(val: System_Security_Cryptography_CngKeyOpenOptions_get_Silent());
            return __return;
        }
    }
} // CngKeyOpenOptions


// type: System.Security.Cryptography.CngKeyUsages
    /**
    Specifies the cryptographic operations that a Cryptography Next Generation (CNG) key may be used with.

    */
public struct CngKeyUsages : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngKeyUsages_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CngKeyUsages None
    /**
    No usage values are assigned to the key.

    */
    public static var None : dotnet.System.Security.Cryptography.CngKeyUsages {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyUsages(val: System_Security_Cryptography_CngKeyUsages_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyUsages Decryption
    /**
    The key can be used for encryption and decryption.

    */
    public static var Decryption : dotnet.System.Security.Cryptography.CngKeyUsages {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyUsages(val: System_Security_Cryptography_CngKeyUsages_get_Decryption());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyUsages Signing
    /**
    The key can be used for signing and verification.

    */
    public static var Signing : dotnet.System.Security.Cryptography.CngKeyUsages {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyUsages(val: System_Security_Cryptography_CngKeyUsages_get_Signing());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyUsages KeyAgreement
    /**
    The key can be used for secret agreement generation and key exchange.

    */
    public static var KeyAgreement : dotnet.System.Security.Cryptography.CngKeyUsages {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyUsages(val: System_Security_Cryptography_CngKeyUsages_get_KeyAgreement());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngKeyUsages AllUsages
    /**
    The key can be used for all purposes.

    */
    public static var AllUsages : dotnet.System.Security.Cryptography.CngKeyUsages {
        get {
        let __return = dotnet.System.Security.Cryptography.CngKeyUsages(val: System_Security_Cryptography_CngKeyUsages_get_AllUsages());
            return __return;
        }
    }
} // CngKeyUsages


// type: System.Security.Cryptography.CngProperty
// boxed value type
    /**
    Encapsulates a property of a Cryptography Next Generation (CNG) key or provider.

    */
public final class CngProperty
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngProperty_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the property name that the current  object specifies.

    */
    public var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
    }
    /**
    Gets the property options that the current  object specifies.

    */
    public var Options : dotnet.System.Security.Cryptography.CngPropertyOptions {
        get {
            return try! get_Options();
        }
    }
    // .ctor(System.String, System.Byte[], System.Security.Cryptography.CngPropertyOptions)
// docid: M:System.Security.Cryptography.CngProperty.#ctor(System.String,System.Byte[],System.Security.Cryptography.CngPropertyOptions)
    /**
    Initializes a new instance of the  class.

    - Parameter name: The property name to initialize.
    - Parameter value: The property value to initialize.
    - Parameter options: A bitwise combination of the enumeration values that specify how the property is stored.
    */
    public init(name : dotnet.System.String, value : Optional<dotnet.System_Arr<Swift.UInt8>>, options : dotnet.System.Security.Cryptography.CngPropertyOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngProperty_ctor_0__3__String_u8Array_CngPropertyOptions(&__thrown, name.get_handle(), (value?.get_handle()), options.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Security_Cryptography_CngProperty_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.CngProperty.Equals(System.Object)
    /**
    Compares the specified object to the current  object.

    - Parameter obj: An object to be compared to the current  object.
    - Returns: 
         if the  parameter is a  object that specifies the same property as the current object; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.CngProperty)
// docid: M:System.Security.Cryptography.CngProperty.Equals(System.Security.Cryptography.CngProperty)
    /**
    Compares the specified  object to the current  object.

    - Parameter other: An object to be compared to the current  object.
    - Returns: 
         if the  parameter represents the same property as the current object; otherwise, .

    */
    public func Equals(other : dotnet.System.Security.Cryptography.CngProperty) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_bool__Equals_0__1__CngProperty(&__thrown, self.get_handle(), other.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.CngProperty.GetHashCode
    /**
    Generates a hash value for the current  object.

    - Returns: The hash value of the current  object.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Byte[] GetValue()
// docid: M:System.Security.Cryptography.CngProperty.GetValue
    /**
    Gets the property value that the current  object specifies.

    - Returns: An array that represents the value stored in the property.

    */
    public func GetValue() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_u8Array__GetValue_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.CngProperty, System.Security.Cryptography.CngProperty)
// docid: M:System.Security.Cryptography.CngProperty.op_Equality(System.Security.Cryptography.CngProperty,System.Security.Cryptography.CngProperty)
    /**
    Determines whether two  objects specify the same property name, value, and options.

    - Parameter left: An object that specifies a property of a Cryptography Next Generation (CNG) key or provider.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects specify the same property; otherwise, .

    */
    public class func op_Equality(left : dotnet.System.Security.Cryptography.CngProperty, right : dotnet.System.Security.Cryptography.CngProperty) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_bool__op_Equality_0__2__CngProperty_CngProperty(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func == (left : dotnet.System.Security.Cryptography.CngProperty, right : dotnet.System.Security.Cryptography.CngProperty) -> Bool
    {
        return try! op_Equality(left: left, right: right);
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.CngProperty, System.Security.Cryptography.CngProperty)
// docid: M:System.Security.Cryptography.CngProperty.op_Inequality(System.Security.Cryptography.CngProperty,System.Security.Cryptography.CngProperty)
    /**
    Determines whether two  objects do not specify the same property name, value, and options.

    - Parameter left: An object that specifies a property of a Cryptography Next Generation (CNG) key or provider.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects do not specify the same property; otherwise, .

    */
    public class func op_Inequality(left : dotnet.System.Security.Cryptography.CngProperty, right : dotnet.System.Security.Cryptography.CngProperty) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_bool__op_Inequality_0__2__CngProperty_CngProperty(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func != (left : dotnet.System.Security.Cryptography.CngProperty, right : dotnet.System.Security.Cryptography.CngProperty) -> Bool
    {
        return try! op_Inequality(left: left, right: right);
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Security.Cryptography.CngProperty.get_Name
    public func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngPropertyOptions get_Options()
// docid: M:System.Security.Cryptography.CngProperty.get_Options
    public func get_Options() throws -> dotnet.System.Security.Cryptography.CngPropertyOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProperty_CngPropertyOptions__get_Options_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngPropertyOptions(val: __return);
        }
    }
} // CngProperty


// type: System.Security.Cryptography.CngPropertyCollection
    /**
    Provides a strongly typed collection of Cryptography Next Generation (CNG) properties.

    */
public final class CngPropertyCollection
    :
    dotnet.System.Collections.ObjectModel.Collection_1<dotnet.System.Security.Cryptography.CngProperty>
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngPropertyCollection_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngPropertyCollection_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.CngPropertyCollection.#ctor
    /**
    Initializes a new  object.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngPropertyCollection_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // CngPropertyCollection


// type: System.Security.Cryptography.CngPropertyOptions
    /**
    Specifies Cryptography Next Generation (CNG) key property options.

    */
public struct CngPropertyOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngPropertyOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CngPropertyOptions Persist
    /**
    The property should be persisted.

    */
    public static var Persist : dotnet.System.Security.Cryptography.CngPropertyOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngPropertyOptions(val: System_Security_Cryptography_CngPropertyOptions_get_Persist());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngPropertyOptions None
    /**
    The referenced property has no options.

    */
    public static var None : dotnet.System.Security.Cryptography.CngPropertyOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngPropertyOptions(val: System_Security_Cryptography_CngPropertyOptions_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngPropertyOptions CustomProperty
    /**
    The property is not specified by CNG. Use this option to avoid future name conflicts with CNG properties.

    */
    public static var CustomProperty : dotnet.System.Security.Cryptography.CngPropertyOptions {
        get {
        let __return = dotnet.System.Security.Cryptography.CngPropertyOptions(val: System_Security_Cryptography_CngPropertyOptions_get_CustomProperty());
            return __return;
        }
    }
} // CngPropertyOptions


// type: System.Security.Cryptography.CngProvider
    /**
    Encapsulates the name of a key storage provider (KSP) for use with Cryptography Next Generation (CNG) objects.

    */
public final class CngProvider
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngProvider_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngProvider_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.CngProvider.#ctor(System.String)
    /**
    Initializes a new instance of the  class.

    - Parameter provider: The name of the key storage provider (KSP) to initialize.
    */
    public init(provider : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngProvider_ctor_0__1__String(&__thrown, provider.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.CngProvider.Equals(System.Object)
    /**
    Compares the specified object to the current  object.

    - Parameter obj: An object to be compared to the current  object.
    - Returns: 
         if the  parameter is a  that specifies the same key storage provider(KSP) as the current object; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.CngProvider.Equals(System.Security.Cryptography.CngProvider)
    /**
    Compares the specified  object to the current  object.

    - Parameter other: An object to be compared to the current  object.
    - Returns: 
         if the  parameter specifies the same key storage provider (KSP) as the current object; otherwise, .

    */
    public func Equals(other : Optional<dotnet.System.Security.Cryptography.CngProvider>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_bool__Equals_0__1__CngProvider(&__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.CngProvider.GetHashCode
    /**
    Generates a hash value for the name of the key storage provider (KSP) that is embedded in the current  object.

    - Returns: The hash value of the embedded KSP name.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.CngProvider, System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.CngProvider.op_Equality(System.Security.Cryptography.CngProvider,System.Security.Cryptography.CngProvider)
    /**
    Determines whether two  objects specify the same key storage provider (KSP).

    - Parameter left: An object that specifies a KSP.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects represent the same KSP; otherwise, .

    */
    public class func op_Equality(left : Optional<dotnet.System.Security.Cryptography.CngProvider>, right : Optional<dotnet.System.Security.Cryptography.CngProvider>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_bool__op_Equality_0__2__CngProvider_CngProvider(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func == (left : dotnet.System.Security.Cryptography.CngProvider, right : dotnet.System.Security.Cryptography.CngProvider) -> Bool
    {
        return try! op_Equality(left: left, right: right);
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.CngProvider, System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.CngProvider.op_Inequality(System.Security.Cryptography.CngProvider,System.Security.Cryptography.CngProvider)
    /**
    Determines whether two  objects do not represent the same key storage provider (KSP).

    - Parameter left: An object that specifies a KSP.
    - Parameter right: A second object, to be compared to the object that is identified by the  parameter.
    - Returns: 
         if the two objects do not represent the same KSP; otherwise, .

    */
    public class func op_Inequality(left : Optional<dotnet.System.Security.Cryptography.CngProvider>, right : Optional<dotnet.System.Security.Cryptography.CngProvider>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_bool__op_Inequality_0__2__CngProvider_CngProvider(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func != (left : dotnet.System.Security.Cryptography.CngProvider, right : dotnet.System.Security.Cryptography.CngProvider) -> Bool
    {
        return try! op_Inequality(left: left, right: right);
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.CngProvider.ToString
    /**
    Gets the name of the key storage provider (KSP) that the current  object specifies.

    - Returns: The embedded KSP name.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngProvider get_MicrosoftPlatformCryptoProvider()
// docid: M:System.Security.Cryptography.CngProvider.get_MicrosoftPlatformCryptoProvider
    public class func get_MicrosoftPlatformCryptoProvider() throws -> dotnet.System.Security.Cryptography.CngProvider {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_CngProvider__get_MicrosoftPlatformCryptoProvider_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngProvider(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngProvider get_MicrosoftSmartCardKeyStorageProvider()
// docid: M:System.Security.Cryptography.CngProvider.get_MicrosoftSmartCardKeyStorageProvider
    public class func get_MicrosoftSmartCardKeyStorageProvider() throws -> dotnet.System.Security.Cryptography.CngProvider {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_CngProvider__get_MicrosoftSmartCardKeyStorageProvider_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngProvider(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngProvider get_MicrosoftSoftwareKeyStorageProvider()
// docid: M:System.Security.Cryptography.CngProvider.get_MicrosoftSoftwareKeyStorageProvider
    public class func get_MicrosoftSoftwareKeyStorageProvider() throws -> dotnet.System.Security.Cryptography.CngProvider {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_CngProvider__get_MicrosoftSoftwareKeyStorageProvider_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngProvider(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Provider()
// docid: M:System.Security.Cryptography.CngProvider.get_Provider
    public func get_Provider() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngProvider_String__get_Provider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets a  object that specifies the Microsoft Platform Crypto Storage Provider.

    */
    public static var MicrosoftPlatformCryptoProvider : dotnet.System.Security.Cryptography.CngProvider {
        get {
            return try! get_MicrosoftPlatformCryptoProvider();
        }
    }
    /**
    Gets a  object that specifies the Microsoft Smart Card Key Storage Provider.

    */
    public static var MicrosoftSmartCardKeyStorageProvider : dotnet.System.Security.Cryptography.CngProvider {
        get {
            return try! get_MicrosoftSmartCardKeyStorageProvider();
        }
    }
    /**
    Gets a  object that specifies the Microsoft Software Key Storage Provider.

    */
    public static var MicrosoftSoftwareKeyStorageProvider : dotnet.System.Security.Cryptography.CngProvider {
        get {
            return try! get_MicrosoftSoftwareKeyStorageProvider();
        }
    }
    /**
    Gets the name of the key storage provider (KSP) that the current  object specifies.

    */
    public var Provider : dotnet.System.String {
        get {
            return try! get_Provider();
        }
    }
} // CngProvider


// type: System.Security.Cryptography.CngUIPolicy
    /**
    Encapsulates optional configuration parameters for the user interface (UI) that Cryptography Next Generation (CNG) displays when you access a protected key.

    */
public final class CngUIPolicy
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngUIPolicy_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_CngUIPolicy_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Security.Cryptography.CngUIProtectionLevels)
// docid: M:System.Security.Cryptography.CngUIPolicy.#ctor(System.Security.Cryptography.CngUIProtectionLevels)
    /**
    Initializes a new instance of the  class by using the specified protection level.

    - Parameter protectionLevel: A bitwise combination of the enumeration values that specify the protection level.
    */
    public init(protectionLevel : dotnet.System.Security.Cryptography.CngUIProtectionLevels) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngUIPolicy_ctor_0__1__CngUIProtectionLevels(&__thrown, protectionLevel.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngUIProtectionLevels, System.String)
// docid: M:System.Security.Cryptography.CngUIPolicy.#ctor(System.Security.Cryptography.CngUIProtectionLevels,System.String)
    /**
    Initializes a new instance of the  class by using the specified protection level and friendly name.

    - Parameter protectionLevel: A bitwise combination of the enumeration values that specify the protection level.
    - Parameter friendlyName: A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.
    */
    public init(protectionLevel : dotnet.System.Security.Cryptography.CngUIProtectionLevels, friendlyName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngUIPolicy_ctor_0__2__CngUIProtectionLevels_String(&__thrown, protectionLevel.get_value(), friendlyName?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngUIProtectionLevels, System.String, System.String)
// docid: M:System.Security.Cryptography.CngUIPolicy.#ctor(System.Security.Cryptography.CngUIProtectionLevels,System.String,System.String)
    /**
    Initializes a new instance of the  class by using the specified protection level, friendly name, and description.

    - Parameter protectionLevel: A bitwise combination of the enumeration values that specify the protection level.
    - Parameter friendlyName: A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.
    - Parameter description: The full-text description of the key. Specify a null string to use the default description.
    */
    public init(protectionLevel : dotnet.System.Security.Cryptography.CngUIProtectionLevels, friendlyName : Optional<dotnet.System.String>, description : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngUIPolicy_ctor_0__3__CngUIProtectionLevels_String_String(&__thrown, protectionLevel.get_value(), friendlyName?.get_handle() ?? nil, description?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngUIProtectionLevels, System.String, System.String, System.String)
// docid: M:System.Security.Cryptography.CngUIPolicy.#ctor(System.Security.Cryptography.CngUIProtectionLevels,System.String,System.String,System.String)
    /**
    Initializes a new instance of the  class by using the specified protection level, friendly name, description string, and use context.

    - Parameter protectionLevel: A bitwise combination of the enumeration values that specify the protection level.
    - Parameter friendlyName: A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.
    - Parameter description: The full-text description of the key. Specify a null string to use the default description.
    - Parameter useContext: A description of how the key will be used. Specify a null string to use the default description.
    */
    public init(protectionLevel : dotnet.System.Security.Cryptography.CngUIProtectionLevels, friendlyName : Optional<dotnet.System.String>, description : Optional<dotnet.System.String>, useContext : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngUIPolicy_ctor_0__4__CngUIProtectionLevels_String_String_String(&__thrown, protectionLevel.get_value(), friendlyName?.get_handle() ?? nil, description?.get_handle() ?? nil, useContext?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngUIProtectionLevels, System.String, System.String, System.String, System.String)
// docid: M:System.Security.Cryptography.CngUIPolicy.#ctor(System.Security.Cryptography.CngUIProtectionLevels,System.String,System.String,System.String,System.String)
    /**
    Initializes a new instance of the  class by using the specified protection level, friendly name, description string, use context, and title.

    - Parameter protectionLevel: A bitwise combination of the enumeration values that specify the protection level.
    - Parameter friendlyName: A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.
    - Parameter description: The full-text description of the key. Specify a null string to use the default description.
    - Parameter useContext: A description of how the key will be used. Specify a null string to use the default description.
    - Parameter creationTitle: The title for the dialog box that provides the UI prompt. Specify a null string to use the default title.
    */
    public init(protectionLevel : dotnet.System.Security.Cryptography.CngUIProtectionLevels, friendlyName : Optional<dotnet.System.String>, description : Optional<dotnet.System.String>, useContext : Optional<dotnet.System.String>, creationTitle : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CngUIPolicy_ctor_0__5__CngUIProtectionLevels_String_String_String_String(&__thrown, protectionLevel.get_value(), friendlyName?.get_handle() ?? nil, description?.get_handle() ?? nil, useContext?.get_handle() ?? nil, creationTitle?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_CreationTitle()
// docid: M:System.Security.Cryptography.CngUIPolicy.get_CreationTitle
    public func get_CreationTitle() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngUIPolicy_String__get_CreationTitle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Description()
// docid: M:System.Security.Cryptography.CngUIPolicy.get_Description
    public func get_Description() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngUIPolicy_String__get_Description_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_FriendlyName()
// docid: M:System.Security.Cryptography.CngUIPolicy.get_FriendlyName
    public func get_FriendlyName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngUIPolicy_String__get_FriendlyName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngUIProtectionLevels get_ProtectionLevel()
// docid: M:System.Security.Cryptography.CngUIPolicy.get_ProtectionLevel
    public func get_ProtectionLevel() throws -> dotnet.System.Security.Cryptography.CngUIProtectionLevels {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngUIPolicy_CngUIProtectionLevels__get_ProtectionLevel_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngUIProtectionLevels(val: __return);
        }
    }
    // [IsSpecialName] System.String get_UseContext()
// docid: M:System.Security.Cryptography.CngUIPolicy.get_UseContext
    public func get_UseContext() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CngUIPolicy_String__get_UseContext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the title that is displayed by the UI prompt.

    */
    public var CreationTitle : Optional<dotnet.System.String> {
        get {
            return try! get_CreationTitle();
        }
    }
    /**
    Gets the description string that is displayed by the UI prompt.

    */
    public var Description : Optional<dotnet.System.String> {
        get {
            return try! get_Description();
        }
    }
    /**
    Gets the friendly name that is displayed by the UI prompt.

    */
    public var FriendlyName : Optional<dotnet.System.String> {
        get {
            return try! get_FriendlyName();
        }
    }
    /**
    Gets the UI protection level for the key.

    */
    public var ProtectionLevel : dotnet.System.Security.Cryptography.CngUIProtectionLevels {
        get {
            return try! get_ProtectionLevel();
        }
    }
    /**
    Gets the description of how the key will be used.

    */
    public var UseContext : Optional<dotnet.System.String> {
        get {
            return try! get_UseContext();
        }
    }
} // CngUIPolicy


// type: System.Security.Cryptography.CngUIProtectionLevels
    /**
    Specifies the protection level for the key in user interface (UI) prompting scenarios.

    */
public struct CngUIProtectionLevels : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CngUIProtectionLevels_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CngUIProtectionLevels None
    /**
    No UI prompt is displayed when the key is accessed.

    */
    public static var None : dotnet.System.Security.Cryptography.CngUIProtectionLevels {
        get {
        let __return = dotnet.System.Security.Cryptography.CngUIProtectionLevels(val: System_Security_Cryptography_CngUIProtectionLevels_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngUIProtectionLevels ProtectKey
    /**
    A UI prompt is displayed the first time the key is accessed in a process.

    */
    public static var ProtectKey : dotnet.System.Security.Cryptography.CngUIProtectionLevels {
        get {
        let __return = dotnet.System.Security.Cryptography.CngUIProtectionLevels(val: System_Security_Cryptography_CngUIProtectionLevels_get_ProtectKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CngUIProtectionLevels ForceHighProtection
    /**
    A UI prompt is displayed every time the key is accessed.

    */
    public static var ForceHighProtection : dotnet.System.Security.Cryptography.CngUIProtectionLevels {
        get {
        let __return = dotnet.System.Security.Cryptography.CngUIProtectionLevels(val: System_Security_Cryptography_CngUIProtectionLevels_get_ForceHighProtection());
            return __return;
        }
    }
} // CngUIProtectionLevels


// type: System.Security.Cryptography.DSACng
    /**
    Provides a Cryptography Next Generation (CNG) implementation of the Digital Signature Algorithm (DSA).

    */
public final class DSACng
    :
    dotnet.System.Security.Cryptography.DSA
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSACng_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_DSACng_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.DSACng.#ctor
    /**
    Initializes a new instance of the  class with a random 2,048-bit key pair.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSACng_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.DSACng.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a randomly generated key of the specified size.

    - Parameter keySize: The size of the key to generate in bits.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSACng_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngKey)
// docid: M:System.Security.Cryptography.DSACng.#ctor(System.Security.Cryptography.CngKey)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The key to use for DSA operations.
    */
    public init(key : dotnet.System.Security.Cryptography.CngKey) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSACng_ctor_0__1__CngKey(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CreateSignature(System.Byte[])
// docid: M:System.Security.Cryptography.DSACng.CreateSignature(System.Byte[])
    /**
    Creates the  signature for the specified data.

    - Parameter rgbHash: The hash value to be signed.
    - Returns: The digital signature for the specified data.

    */
    public override func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACng_u8Array__CreateSignature_0__1__u8Array(&__thrown, self.get_handle(), rgbHash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.DSACng.ExportParameters(System.Boolean)
    /**
    Exports the DSA algorithm parameters.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The DSA algorithm parameters.

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.DSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACng_DSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DSAParameters(hndl : __return);
        }
    }
    // void ImportParameters(System.Security.Cryptography.DSAParameters)
// docid: M:System.Security.Cryptography.DSACng.ImportParameters(System.Security.Cryptography.DSAParameters)
    /**
    Replaces the existing key that the current instance is working with by creating a new  for the parameters structure.

    - Parameter parameters: The DSA parameters.
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.DSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSACng_void__ImportParameters_0__1__DSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool VerifySignature(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DSACng.VerifySignature(System.Byte[],System.Byte[])
    /**
    Verifies if the specified digital signature matches the specified hash.

    - Parameter rgbHash: The signed hash.
    - Parameter rgbSignature: The digital signature to be verified.
    - Returns: 
         if  matches the signature computed using the specified hash; otherwise, .

    */
    public override func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACng_bool__VerifySignature_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKey get_Key()
// docid: M:System.Security.Cryptography.DSACng.get_Key
    public func get_Key() throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACng_CngKey__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_KeyExchangeAlgorithm()
// docid: M:System.Security.Cryptography.DSACng.get_KeyExchangeAlgorithm
    public override func get_KeyExchangeAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACng_String__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.DSACng.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACng_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.DSACng.get_SignatureAlgorithm
    public override func get_SignatureAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACng_String__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the key that will be used by the  object for any cryptographic operation that it performs.

    */
    public var Key : dotnet.System.Security.Cryptography.CngKey {
        get {
            return try! get_Key();
        }
    }
    /**
    Gets the name of the key exchange algorithm.

    */
    public override var KeyExchangeAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the DSA algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets the name of the signature algorithm.

    */
    public override var SignatureAlgorithm : dotnet.System.String {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
} // DSACng


// type: System.Security.Cryptography.ECDiffieHellmanCng
    /**
    Provides a Cryptography Next Generation (CNG) implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm. This class is used to perform cryptographic operations.

    */
public final class ECDiffieHellmanCng
    :
    dotnet.System.Security.Cryptography.ECDiffieHellman
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDiffieHellmanCng_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_ECDiffieHellmanCng_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor
    /**
    Initializes a new instance of the  class with a random key pair.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanCng_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a random key pair, using the specified key size.

    - Parameter keySize: The size of the key. Valid key sizes are 256, 384, and 521 bits.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanCng_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngKey)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.CngKey)
    /**
    Initializes a new instance of the  class by using the specified  object.

    - Parameter key: The key that will be used as input to the cryptographic operations performed by the current object.
    */
    public init(key : dotnet.System.Security.Cryptography.CngKey) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanCng_ctor_0__1__CngKey(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.ECCurve)
    /**
    Creates a new instance of the  class whose public/private key pair is generated over the specified curve.

    - Parameter curve: The curve used to generate the public/private key pair.
    */
    public init(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanCng_ctor_0__1__ECCurve(&__thrown, curve.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])
    /**
    Performs key derivation using a specified hash algorithm with optional prepended or appended data.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Parameter secretPrepend: A value to prepend to the derived secret before hashing.
    - Parameter secretAppend: A value to append to the derived secret before hashing.
    - Returns: The hash of the shared secret after prepending or appending data as requested.

    */
    public override func DeriveKeyFromHash(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, secretPrepend : Optional<dotnet.System_Arr<Swift.UInt8>>, secretAppend : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__DeriveKeyFromHash_0__4__ECDiffieHellmanPublicKey_HashAlgorithmName_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle(), (secretPrepend?.get_handle()), (secretAppend?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])
    /**
    Performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm with optional prepended or appended data.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Parameter hmacKey: The key for the HMAC.
    - Parameter secretPrepend: A value to prepend to the derived secret before hashing.
    - Parameter secretAppend: A value to append to the derived secret before hashing.
    - Returns: The HMAC of the shared secret after prepending or appending data as requested.

    */
    public override func DeriveKeyFromHmac(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, hmacKey : Optional<dotnet.System_Arr<Swift.UInt8>>, secretPrepend : Optional<dotnet.System_Arr<Swift.UInt8>>, secretAppend : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__DeriveKeyFromHmac_0__5__ECDiffieHellmanPublicKey_HashAlgorithmName_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle(), (hmacKey?.get_handle()), (secretPrepend?.get_handle()), (secretAppend?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyMaterial(System.Security.Cryptography.CngKey)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.CngKey)
    /**
    Derives the key material that is generated from the secret agreement between two parties, given a  object that contains the second party's public key.

    - Parameter otherPartyPublicKey: An object that contains the public part of the Elliptic Curve Diffie-Hellman (ECDH) key from the other party in the key exchange.
    - Returns: A byte array that contains the key material. This information is generated from the secret agreement that is calculated from the current object's private key and the specified public key.

    */
    public func DeriveKeyMaterial(otherPartyPublicKey : dotnet.System.Security.Cryptography.CngKey) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__DeriveKeyMaterial_0__1__CngKey(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)
    /**
    Derives the key material that is generated from the secret agreement between two parties, given an  object that contains the second party's public key.

    - Parameter otherPartyPublicKey: The public key from the other party in the key exchange.
    - Returns: A byte array that contains the key material. This information is generated from the secret agreement that is calculated from the current object's private key and the specified public key.

    */
    public override func DeriveKeyMaterial(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__DeriveKeyMaterial_0__1__ECDiffieHellmanPublicKey(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])
    /**
    Performs key derivation using the TLS (Transport Layer Security) 1.1 PRF (Pseudo-Random Function).

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter prfLabel: The ASCII-encoded PRF label.
    - Parameter prfSeed: The 64-byte PRF seed.
    - Returns: The first 48 bytes from the TLS 1.1 PRF, using the shared secret as the key.

    */
    public override func DeriveKeyTls(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, prfLabel : dotnet.System_Arr<Swift.UInt8>, prfSeed : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__DeriveKeyTls_0__3__ECDiffieHellmanPublicKey_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), prfLabel.get_handle(), prfSeed.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(System.Security.Cryptography.CngKey)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.CngKey)
    /**
    Gets a handle to the secret agreement generated between two parties, given a  object that contains the second party's public key.

    - Parameter otherPartyPublicKey: An object that contains the public part of the Elliptic Curve Diffie-Hellman (ECDH) key from the other party in the key exchange.
    - Returns: A handle to the secret agreement. This information is calculated from the current object's private key and the specified public key.

    */
    public func DeriveSecretAgreementHandle(otherPartyPublicKey : dotnet.System.Security.Cryptography.CngKey) throws -> dotnet.Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_SafeNCryptSecretHandle__DeriveSecretAgreementHandle_0__1__CngKey(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle(hndl : __return);
        }
    }
    // Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(System.Security.Cryptography.ECDiffieHellmanPublicKey)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.ECDiffieHellmanPublicKey)
    /**
    Gets a handle to the secret agreement generated between two parties, given an  object that contains the second party's public key.

    - Parameter otherPartyPublicKey: The public key from the other party in the key exchange.
    - Returns: A handle to the secret agreement. This information is calculated from the current object's private key and the specified public key.

    */
    public func DeriveSecretAgreementHandle(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey) throws -> dotnet.Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_SafeNCryptSecretHandle__DeriveSecretAgreementHandle_0__1__ECDiffieHellmanPublicKey(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters(bool)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.ExportExplicitParameters(System.Boolean)
    /**
    Exports the key and explicit curve parameters used by the  object into an  object.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key and explicit curve parameters used by the  object.

    */
    public override func ExportExplicitParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_ECParameters__ExportExplicitParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.ExportParameters(System.Boolean)
    /**
    Exports the key used by the  object into an  object.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key and named curve parameters used by the  object.

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_ECParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // void FromXmlString(System.String, System.Security.Cryptography.ECKeyXmlFormat)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString(System.String,System.Security.Cryptography.ECKeyXmlFormat)
    /**
    Deserializes the key information from an XML string by using the specified format.

    - Parameter xml: The XML-based key information to be deserialized.
    - Parameter format: One of the enumeration values that specifies the format of the XML string. The only currently accepted format is .
    */
    public func FromXmlString(xml : dotnet.System.String, format : dotnet.System.Security.Cryptography.ECKeyXmlFormat) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__FromXmlString_0__2__String_ECKeyXmlFormat(&__thrown, self.get_handle(), xml.get_handle(), format.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.GenerateKey(System.Security.Cryptography.ECCurve)
    /**
    Generates a new ephemeral public/private key pair for the specified curve.

    - Parameter curve: The curve used to generate an ephemeral public/private key pair.
    */
    public override func GenerateKey(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__GenerateKey_0__1__ECCurve(&__thrown, self.get_handle(), curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ImportParameters(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.ImportParameters(System.Security.Cryptography.ECParameters)
    /**
    Imports the specified parameters for an  object as a key into the current instance.

    - Parameter parameters: The curve's parameters to import.
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.ECParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__ImportParameters_0__1__ECParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String ToXmlString(System.Security.Cryptography.ECKeyXmlFormat)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString(System.Security.Cryptography.ECKeyXmlFormat)
    /**
    Serializes the key information to an XML string by using the specified format.

    - Parameter format: One of the enumeration values that specifies the format of the XML string. The only currently accepted format is .
    - Returns: A string object that contains the key information, serialized to an XML string, according to the requested format.

    */
    public func ToXmlString(format : dotnet.System.Security.Cryptography.ECKeyXmlFormat) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_String__ToXmlString_0__1__ECKeyXmlFormat(&__thrown, self.get_handle(), format.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_HashAlgorithm()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_HashAlgorithm
    public func get_HashAlgorithm() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_CngAlgorithm__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] void set_HashAlgorithm(System.Security.Cryptography.CngAlgorithm)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_HashAlgorithm(System.Security.Cryptography.CngAlgorithm)
    public func set_HashAlgorithm(value : dotnet.System.Security.Cryptography.CngAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_HashAlgorithm_0__1__CngAlgorithm(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_HmacKey()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_HmacKey
    public func get_HmacKey() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__get_HmacKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_HmacKey(System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_HmacKey(System.Byte[])
    public func set_HmacKey(value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_HmacKey_0__1__u8Array(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKey get_Key()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_Key
    public func get_Key() throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_CngKey__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_KeyDerivationFunction
    public func get_KeyDerivationFunction() throws -> dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_ECDiffieHellmanKeyDerivationFunction__get_KeyDerivationFunction_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction(val: __return);
        }
    }
    // [IsSpecialName] void set_KeyDerivationFunction(System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_KeyDerivationFunction(System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction)
    public func set_KeyDerivationFunction(value : dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_KeyDerivationFunction_0__1__ECDiffieHellmanKeyDerivationFunction(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Label()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_Label
    public func get_Label() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__get_Label_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Label(System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_Label(System.Byte[])
    public func set_Label(value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_Label_0__1__u8Array(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECDiffieHellmanPublicKey get_PublicKey()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_PublicKey
    public override func get_PublicKey() throws -> dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_ECDiffieHellmanPublicKey__get_PublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.Byte[] get_SecretAppend()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_SecretAppend
    public func get_SecretAppend() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__get_SecretAppend_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SecretAppend(System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_SecretAppend(System.Byte[])
    public func set_SecretAppend(value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_SecretAppend_0__1__u8Array(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_SecretPrepend()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_SecretPrepend
    public func get_SecretPrepend() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__get_SecretPrepend_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SecretPrepend(System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_SecretPrepend(System.Byte[])
    public func set_SecretPrepend(value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_SecretPrepend_0__1__u8Array(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Seed()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_Seed
    public func get_Seed() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_u8Array__get_Seed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Seed(System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.set_Seed(System.Byte[])
    public func set_Seed(value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanCng_void__set_Seed_0__1__u8Array(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UseSecretAgreementAsHmacKey()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCng.get_UseSecretAgreementAsHmacKey
    public func get_UseSecretAgreementAsHmacKey() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCng_bool__get_UseSecretAgreementAsHmacKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets or sets the hash algorithm to use when generating key material.

    */
    public var HashAlgorithm : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_HashAlgorithm();
        }
        set(v) {
            return try! set_HashAlgorithm(value: v);
        }
    }
    /**
    Gets or sets the Hash-based Message Authentication Code (HMAC) key to use when deriving key material.

    */
    public var HmacKey : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_HmacKey();
        }
        set(v) {
            return try! set_HmacKey(value: v!);
        }
    }
    /**
    Specifies the  that is used by the current object for cryptographic operations.

    */
    public var Key : dotnet.System.Security.Cryptography.CngKey {
        get {
            return try! get_Key();
        }
    }
    /**
    Gets or sets the key derivation function for the  class.

    */
    public var KeyDerivationFunction : dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction {
        get {
            return try! get_KeyDerivationFunction();
        }
        set(v) {
            return try! set_KeyDerivationFunction(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the key modulus used by the asymmetric algorithm.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets or sets the label value that is used for key derivation.

    */
    public var Label : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_Label();
        }
        set(v) {
            return try! set_Label(value: v!);
        }
    }
    /**
    Gets the public key that can be used by another  object to generate a shared secret agreement.

    */
    public override var PublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey {
        get {
            return try! get_PublicKey();
        }
    }
    /**
    Gets or sets a value that will be appended to the secret agreement when generating key material.

    */
    public var SecretAppend : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_SecretAppend();
        }
        set(v) {
            return try! set_SecretAppend(value: v!);
        }
    }
    /**
    Gets or sets a value that will be added to the beginning of the secret agreement when deriving key material.

    */
    public var SecretPrepend : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_SecretPrepend();
        }
        set(v) {
            return try! set_SecretPrepend(value: v!);
        }
    }
    /**
    Gets or sets the seed value that will be used when deriving key material.

    */
    public var Seed : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_Seed();
        }
        set(v) {
            return try! set_Seed(value: v!);
        }
    }
    /**
    Gets a value that indicates whether the secret agreement is used as a Hash-based Message Authentication Code (HMAC) key to derive key material.

    */
    public var UseSecretAgreementAsHmacKey : Bool {
        get {
            return try! get_UseSecretAgreementAsHmacKey();
        }
    }
} // ECDiffieHellmanCng


// type: System.Security.Cryptography.ECDiffieHellmanCngPublicKey
    /**
    Specifies an Elliptic Curve Diffie-Hellman (ECDH) public key for use with the  class.

    */
public final class ECDiffieHellmanCngPublicKey
    :
    dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDiffieHellmanCngPublicKey_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCngPublicKey.ExportExplicitParameters
    /**
    Exports the key and explicit curve parameters used by the  object into an  object.

    - Returns: The key and explicit curve parameters used by the  object.

    */
    public override func ExportExplicitParameters() throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_ECParameters__ExportExplicitParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCngPublicKey.ExportParameters
    /**
    Exports the key used by the  object into an  object.

    - Returns: The key and named curve parameters used by the  object.

    */
    public override func ExportParameters() throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_ECParameters__ExportParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDiffieHellmanPublicKey FromByteArray(System.Byte[], System.Security.Cryptography.CngKeyBlobFormat)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCngPublicKey.FromByteArray(System.Byte[],System.Security.Cryptography.CngKeyBlobFormat)
    /**
    Converts a byte array that contains a public key to a  object according to the specified format.

    - Parameter publicKeyBlob: A byte array that contains an Elliptic Curve Diffie-Hellman (ECDH) public key.
    - Parameter format: An object that specifies the format of the key BLOB.
    - Returns: An object that contains the ECDH public key that is serialized in the byte array.

    */
    public class func FromByteArray(publicKeyBlob : dotnet.System_Arr<Swift.UInt8>, format : dotnet.System.Security.Cryptography.CngKeyBlobFormat) throws -> dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_ECDiffieHellmanPublicKey__FromByteArray_0__2__u8Array_CngKeyBlobFormat(&__thrown, publicKeyBlob.get_handle(), format.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDiffieHellmanCngPublicKey FromXmlString(System.String)
// docid: M:System.Security.Cryptography.ECDiffieHellmanCngPublicKey.FromXmlString(System.String)
    /**
    Converts an XML string to an  object.

    - Parameter xml: An XML string that contains an Elliptic Curve Diffie-Hellman (ECDH) key.
    - Returns: An object that contains the ECDH public key that is specified by the given XML.

    */
    public class func FromXmlString(xml : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.ECDiffieHellmanCngPublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_ECDiffieHellmanCngPublicKey__FromXmlString_0__1__String(&__thrown, xml.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellmanCngPublicKey(hndl : __return);
        }
    }
    // System.Security.Cryptography.CngKey Import()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCngPublicKey.Import
    /**
    Converts the  object to a  object.

    - Returns: An object that contains the key represented by the  object.

    */
    public func Import() throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_CngKey__Import_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // System.String ToXmlString()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCngPublicKey.ToXmlString
    /**
    Serializes the  public key to an XML string in RFC 4050 format.

    - Returns: An XML string that contains the serialized  public key.

    */
    public override func ToXmlString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_String__ToXmlString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKeyBlobFormat get_BlobFormat()
// docid: M:System.Security.Cryptography.ECDiffieHellmanCngPublicKey.get_BlobFormat
    public func get_BlobFormat() throws -> dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanCngPublicKey_CngKeyBlobFormat__get_BlobFormat_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKeyBlobFormat(hndl : __return);
        }
    }
    /**
    Gets the key BLOB format for a  object.

    */
    public var BlobFormat : dotnet.System.Security.Cryptography.CngKeyBlobFormat {
        get {
            return try! get_BlobFormat();
        }
    }
} // ECDiffieHellmanCngPublicKey


// type: System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction
    /**
    Specifies the key derivation function that the  class will use to convert secret agreements into key material.

    */
public struct ECDiffieHellmanKeyDerivationFunction : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDiffieHellmanKeyDerivationFunction_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Hash
    /**
    A hash algorithm is used to generate key material. The  property specifies the name of the algorithm to use. If the algorithm name is not specified,  is used as the default algorithm. You can also specify the  and  properties, but they are not required. The amount of key material that is generated is equivalent to the size of the hash value for the specified algorithm.

    */
    public static var Hash : dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction {
        get {
        let __return = dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction(val: System_Security_Cryptography_ECDiffieHellmanKeyDerivationFunction_get_Hash());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Hmac
    /**
    A Hash-based Message Authentication Code (HMAC) algorithm is used to generate key material. The  property specifies the key to use. Either this property must be set or the  property must be set to ; otherwise, a  is thrown when you use . If both properties are set, the secret agreement is used as the HMAC key. You can also specify the  and  properties, but they are not required. The amount of key material that is generated is equivalent to the size of the HMAC value.

    */
    public static var Hmac : dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction {
        get {
        let __return = dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction(val: System_Security_Cryptography_ECDiffieHellmanKeyDerivationFunction_get_Hmac());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Tls
    /**
    The Transport Layer Security (TLS) protocol is used to generate key material. The  and  properties must be set; otherwise, a  is thrown when you use . This value generates 160 bits of key material.

    */
    public static var Tls : dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction {
        get {
        let __return = dotnet.System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction(val: System_Security_Cryptography_ECDiffieHellmanKeyDerivationFunction_get_Tls());
            return __return;
        }
    }
} // ECDiffieHellmanKeyDerivationFunction


// type: System.Security.Cryptography.ECDsaCng
    /**
    Provides a Cryptography Next Generation (CNG) implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).

    */
public final class ECDsaCng
    :
    dotnet.System.Security.Cryptography.ECDsa
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDsaCng_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_ECDsaCng_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.ECDsaCng.#ctor
    /**
    Initializes a new instance of the  class with a random key pair.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaCng_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.ECDsaCng.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a specified target key size.

    - Parameter keySize: The size of the key. Valid key sizes are 256, 384, and 521 bits.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaCng_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngKey)
// docid: M:System.Security.Cryptography.ECDsaCng.#ctor(System.Security.Cryptography.CngKey)
    /**
    Initializes a new instance of the  class by using the specified  object.

    - Parameter key: The key that will be used as input to the cryptographic operations performed by the current object.
    */
    public init(key : dotnet.System.Security.Cryptography.CngKey) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaCng_ctor_0__1__CngKey(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDsaCng.#ctor(System.Security.Cryptography.ECCurve)
    /**
    Initializes a new instance of the  class whose public/private key pair is generated over the specified curve.

    - Parameter curve: The curve used to generate the public/private key pair.
    */
    public init(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaCng_ctor_0__1__ECCurve(&__thrown, curve.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters(bool)
// docid: M:System.Security.Cryptography.ECDsaCng.ExportExplicitParameters(System.Boolean)
    /**
    Exports the key and explicit curve parameters used by the Elliptic curve cryptography (ECC) object into an  object.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key and explicit curve parameters used by the ECC object.

    */
    public override func ExportExplicitParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_ECParameters__ExportExplicitParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.ECDsaCng.ExportParameters(System.Boolean)
    /**
    Exports the key used by the Elliptic curve cryptography (ECC) object into an  object. If the key was created as a named curve, the  field contains named curve parameters; otherwise, it contains explicit parameters.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key and named curve parameters used by the ECC object.

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_ECParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // void FromXmlString(System.String, System.Security.Cryptography.ECKeyXmlFormat)
// docid: M:System.Security.Cryptography.ECDsaCng.FromXmlString(System.String,System.Security.Cryptography.ECKeyXmlFormat)
    /**
    Deserializes the key information from an XML string by using the specified format.

    - Parameter xml: The XML-based key information to be deserialized.
    - Parameter format: One of the enumeration values that specifies the format of the XML string. The only currently accepted format is .
    */
    public func FromXmlString(xml : dotnet.System.String, format : dotnet.System.Security.Cryptography.ECKeyXmlFormat) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaCng_void__FromXmlString_0__2__String_ECKeyXmlFormat(&__thrown, self.get_handle(), xml.get_handle(), format.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDsaCng.GenerateKey(System.Security.Cryptography.ECCurve)
    /**
    Generates a new ephemeral public/private key pair for the specified curve, replacing the current key.

    - Parameter curve: The curve to use to generate the key.
    */
    public override func GenerateKey(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaCng_void__GenerateKey_0__1__ECCurve(&__thrown, self.get_handle(), curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ImportParameters(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDsaCng.ImportParameters(System.Security.Cryptography.ECParameters)
    /**
    Replaces the existing key that the current instance is working with by creating a new  for the parameters structure.

    - Parameter parameters: The curve parameters.
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.ECParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaCng_void__ImportParameters_0__1__ECParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] SignData(System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaCng.SignData(System.Byte[])
    /**
    Generates a signature for the specified data.

    - Parameter data: The message data to be signed.
    - Returns: A digital signature for the specified data.

    */
    public func SignData(data : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_u8Array__SignData_0__1__u8Array(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.ECDsaCng.SignData(System.Byte[],System.Int32,System.Int32)
    /**
    Generates a digital signature for the specified length of data, beginning at the specified offset.

    - Parameter data: The message data to be signed.
    - Parameter offset: The location in the string at which to start signing.
    - Parameter count: The length of the string, in characters, following  that will be signed.
    - Returns: A digital signature for the specified length of data.

    */
    public func SignData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_u8Array__SignData_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), data.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream)
// docid: M:System.Security.Cryptography.ECDsaCng.SignData(System.IO.Stream)
    /**
    Generates a signature for the specified data stream, reading to the end of the stream.

    - Parameter data: The data stream to be signed.
    - Returns: A digital signature for the specified data stream.

    */
    public func SignData(data : dotnet.System.IO.Stream) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_u8Array__SignData_0__1__Stream(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignHash(System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaCng.SignHash(System.Byte[])
    /**
    Generates a signature for the specified hash value.

    - Parameter hash: The hash value of the data to be signed.
    - Returns: A digital signature for the specified hash value.

    */
    public override func SignHash(hash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_u8Array__SignHash_0__1__u8Array(&__thrown, self.get_handle(), hash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String ToXmlString(System.Security.Cryptography.ECKeyXmlFormat)
// docid: M:System.Security.Cryptography.ECDsaCng.ToXmlString(System.Security.Cryptography.ECKeyXmlFormat)
    /**
    Serializes the key information to an XML string by using the specified format.

    - Parameter format: One of the enumeration values that specifies the format of the XML string. The only currently accepted format is .
    - Returns: A string object that contains the key information, serialized to an XML string according to the requested format.

    */
    public func ToXmlString(format : dotnet.System.Security.Cryptography.ECKeyXmlFormat) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_String__ToXmlString_0__1__ECKeyXmlFormat(&__thrown, self.get_handle(), format.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // bool VerifyData(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaCng.VerifyData(System.Byte[],System.Byte[])
    /**
    Verifies the digital signature of the specified data.

    - Parameter data: The data that was signed.
    - Parameter signature: The signature to be verified.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_bool__VerifyData_0__2__u8Array_u8Array(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Int32, System.Int32, System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaCng.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[])
    /**
    Verifies a signature for the specified length of data, beginning at the specified offset.

    - Parameter data: The data that was signed.
    - Parameter offset: The location in the data at which the signed data begins.
    - Parameter count: The length of the data, in characters, following  that will be signed.
    - Parameter signature: The signature to be verified.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, signature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_bool__VerifyData_0__4__u8Array_i32_i32_u8Array(&__thrown, self.get_handle(), data.get_handle(), offset, count, signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.IO.Stream, System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaCng.VerifyData(System.IO.Stream,System.Byte[])
    /**
    Verifies the digital signature of the specified data stream, reading to the end of the stream.

    - Parameter data: The data stream that was signed.
    - Parameter signature: The signature to be verified.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public func VerifyData(data : dotnet.System.IO.Stream, signature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_bool__VerifyData_0__2__Stream_u8Array(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyHash(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaCng.VerifyHash(System.Byte[],System.Byte[])
    /**
    Verifies that a digital signature is appropriate for the current key and provided data hash.

    - Parameter hash: The hash value of the data to be verified.
    - Parameter signature: The digital signature of the data to be verified against the hash value.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public override func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_bool__VerifyHash_0__2__u8Array_u8Array(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngAlgorithm get_HashAlgorithm()
// docid: M:System.Security.Cryptography.ECDsaCng.get_HashAlgorithm
    public func get_HashAlgorithm() throws -> dotnet.System.Security.Cryptography.CngAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_CngAlgorithm__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] void set_HashAlgorithm(System.Security.Cryptography.CngAlgorithm)
// docid: M:System.Security.Cryptography.ECDsaCng.set_HashAlgorithm(System.Security.Cryptography.CngAlgorithm)
    public func set_HashAlgorithm(value : dotnet.System.Security.Cryptography.CngAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaCng_void__set_HashAlgorithm_0__1__CngAlgorithm(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKey get_Key()
// docid: M:System.Security.Cryptography.ECDsaCng.get_Key
    public func get_Key() throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_CngKey__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.ECDsaCng.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.ECDsaCng.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaCng_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.ECDsaCng.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaCng_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    /**
    Gets or sets the hash algorithm to use when signing and verifying data.

    */
    public var HashAlgorithm : dotnet.System.Security.Cryptography.CngAlgorithm {
        get {
            return try! get_HashAlgorithm();
        }
        set(v) {
            return try! set_HashAlgorithm(value: v);
        }
    }
    /**
    Gets or sets the key to use when signing and verifying data.

    */
    public var Key : dotnet.System.Security.Cryptography.CngKey {
        get {
            return try! get_Key();
        }
    }
    /**
    Gets or sets the size, in bits, of the key modulus used by the asymmetric algorithm.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the  property setter.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
} // ECDsaCng


// type: System.Security.Cryptography.ECKeyXmlFormat
    /**
    Defines XML serialization formats for elliptic curve keys.

    */
public struct ECKeyXmlFormat : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECKeyXmlFormat_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.ECKeyXmlFormat Rfc4050
    /**
    An XML serialization format described in RFC 4050, "Using the Elliptic Curve Signature Algorithm (ECDSA) for XML Digital Signatures."

    */
    public static var Rfc4050 : dotnet.System.Security.Cryptography.ECKeyXmlFormat {
        get {
        let __return = dotnet.System.Security.Cryptography.ECKeyXmlFormat(val: System_Security_Cryptography_ECKeyXmlFormat_get_Rfc4050());
            return __return;
        }
    }
} // ECKeyXmlFormat


// type: System.Security.Cryptography.RSACng
    /**
    Provides a Cryptography Next Generation (CNG) implementation of the RSA algorithm.

    */
public final class RSACng
    :
    dotnet.System.Security.Cryptography.RSA
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSACng_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_RSACng_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.RSACng.#ctor
    /**
    Initializes a new instance of the  class with a random 2,048-bit key pair.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSACng_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.RSACng.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a randomly generated key of the specified size.

    - Parameter keySize: The size of the key to generate in bits.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSACng_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CngKey)
// docid: M:System.Security.Cryptography.RSACng.#ctor(System.Security.Cryptography.CngKey)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The key to use for RSA operations.
    */
    public init(key : dotnet.System.Security.Cryptography.CngKey) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSACng_ctor_0__1__CngKey(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] Decrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSACng.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Decrypts input data using the specified padding mode.

    - Parameter data: The data to decrypt.
    - Parameter padding: The padding mode.
    - Returns: The decrypted data.

    */
    public override func Decrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACng_u8Array__Decrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Encrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSACng.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Encrypts the input data using the specified padding.

    - Parameter data: The data to encrypt.
    - Parameter padding: The padding mode.
    - Returns: The encrypted data.

    */
    public override func Encrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACng_u8Array__Encrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.RSACng.ExportParameters(System.Boolean)
    /**
    Exports the key used by the RSA object into a  object.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key used by the RSA object.

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.RSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACng_RSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAParameters(hndl : __return);
        }
    }
    // void ImportParameters(System.Security.Cryptography.RSAParameters)
// docid: M:System.Security.Cryptography.RSACng.ImportParameters(System.Security.Cryptography.RSAParameters)
    /**
    Replaces the existing key that the current instance is working with by creating a new  for the parameters structure.

    - Parameter parameters: The RSA parameters.
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.RSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSACng_void__ImportParameters_0__1__RSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] SignHash(System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSACng.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Signs data that was hashed by using the specified hashing algorithm and padding mode.

    - Parameter hash: The hash to sign.
    - Parameter hashAlgorithm: The hash algorithm name.
    - Parameter padding: The padding mode.
    - Returns: The signed data.

    */
    public override func SignHash(hash : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACng_u8Array__SignHash_0__3__u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // bool VerifyHash(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSACng.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Verifies data that was signed and already hashed with the specified algorithm and padding mode.

    - Parameter hash: The hash to verify.
    - Parameter signature: The signature of the data.
    - Parameter hashAlgorithm: The hash algorithm name.
    - Parameter padding: The padding mode.
    - Returns: 
         if the signature verifies for the hash; otherwise, .

    */
    public override func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACng_bool__VerifyHash_0__4__u8Array_u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CngKey get_Key()
// docid: M:System.Security.Cryptography.RSACng.get_Key
    public func get_Key() throws -> dotnet.System.Security.Cryptography.CngKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACng_CngKey__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CngKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.RSACng.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACng_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    /**
    Gets the key that will be used by the  object for any cryptographic operation that it performs.

    */
    public var Key : dotnet.System.Security.Cryptography.CngKey {
        get {
            return try! get_Key();
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by this implementation of RSA.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
} // RSACng


// type: System.Security.Cryptography.TripleDESCng
    /**
    Provides a Cryptography Next Generation (CNG) implementation of the Triple Data Encryption Standard (3DES) algorithm.

    */
public final class TripleDESCng
    :
    dotnet.System.Security.Cryptography.TripleDES
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_TripleDESCng_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_TripleDESCng_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.TripleDESCng.#ctor
    /**
    Initializes a new instance of the  class with an ephemeral key.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_TripleDESCng_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.TripleDESCng.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified key name, which represents an existing persisted 3DES key.

    - Parameter keyName: The name of the key.
    */
    public init(keyName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_TripleDESCng_ctor_0__1__String(&__thrown, keyName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.CngProvider)
// docid: M:System.Security.Cryptography.TripleDESCng.#ctor(System.String,System.Security.Cryptography.CngProvider)
    /**
    Initializes a new instance of the  class with the specified key name, which represents an existing persisted 3DES key, and the specified key storage provider (KSP).

    - Parameter keyName: The name of the key.
    - Parameter provider: The KSP that contains the key.
    */
    public init(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_TripleDESCng_ctor_0__2__String_CngProvider(&__thrown, keyName.get_handle(), provider.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.CngProvider, System.Security.Cryptography.CngKeyOpenOptions)
// docid: M:System.Security.Cryptography.TripleDESCng.#ctor(System.String,System.Security.Cryptography.CngProvider,System.Security.Cryptography.CngKeyOpenOptions)
    /**
    Initializes a new instance of the  class with the specified key name, which represents an existing persisted 3DES key,  the specified key storage provider (KSP) and key open options.

    - Parameter keyName: The name of the key.
    - Parameter provider: The KSP that contains the key.
    - Parameter openOptions: A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.
    */
    public init(keyName : dotnet.System.String, provider : dotnet.System.Security.Cryptography.CngProvider, openOptions : dotnet.System.Security.Cryptography.CngKeyOpenOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_TripleDESCng_ctor_0__3__String_CngProvider_CngKeyOpenOptions(&__thrown, keyName.get_handle(), provider.get_handle(), openOptions.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.TripleDESCng.CreateDecryptor
    /**
    Creates a symmetric 3DES decryptor object with the current key and initialization vector ().

    - Returns: A symmetric 3DES decryptor object.

    */
    public override func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCng_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.TripleDESCng.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric 3DES decryptor object with the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the 3DES algorithm. The key size must be 192 bits.
    - Parameter rgbIV: The initialization vector to use for the 3DES algorithm.
    - Returns: A symmetric 3DES decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCng_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.TripleDESCng.CreateEncryptor
    /**
    Creates a symmetric 3DES encryptor object using the current key and initialization vector ().

    - Returns: A symmetric 3DES encryptor object.

    */
    public override func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCng_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.TripleDESCng.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric 3DES encryptor object with the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the 3DES algorithm. The key size must be 192 bits.
    - Parameter rgbIV: The initialization vector to use for the 3DES algorithm.
    - Returns: A symmetric 3DES encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCng_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.TripleDESCng.GenerateIV
    /**
    Generates a random initialization vector (IV) to use for the 3DES algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCng_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.TripleDESCng.GenerateKey
    /**
    Generates a random key to use for the 3DES algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCng_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.TripleDESCng.get_Key
    public override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCng_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.TripleDESCng.set_Key(System.Byte[])
    public override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCng_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.TripleDESCng.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCng_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.TripleDESCng.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCng_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key for the  algorithm.

    */
    public override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the secret key used by the  algorithm.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
} // TripleDESCng


}



