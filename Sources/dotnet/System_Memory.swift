// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
extension System {
// type: System.MemoryExtensions
public struct MemoryExtensions {
    // System.ReadOnlyMemory<System.Char> AsMemory(System.String)
// docid: M:System.MemoryExtensions.AsMemory(System.String)
    /**
    Creates a new  over the portion of the target string.

    - Parameter text: The target string.
    - Returns: The read-only character memory representation of the string, or  if  is .

    */
    public static func AsMemory(text : Optional<dotnet.System.String>) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___AsMemory_0__1__String(&__thrown, text?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Index)
// docid: M:System.MemoryExtensions.AsMemory(System.String,System.Index)
    /**
    Creates a new  over a portion of the target string starting at a specified index.

    - Parameter text: The target string.
    - Parameter startIndex: The index at which to begin this slice.
    - Returns: The read-only character memory representation of the string.

    */
    public static func AsMemory(text : Optional<dotnet.System.String>, startIndex : dotnet.System.Index) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___AsMemory_0__2__String_Index(&__thrown, text?.get_handle() ?? nil, startIndex.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Int32)
// docid: M:System.MemoryExtensions.AsMemory(System.String,System.Int32)
    /**
    Creates a new  over a portion of the target string starting at a specified character position.

    - Parameter text: The target string.
    - Parameter start: The index at which to begin this slice.
    - Returns: The read-only character memory representation of the string, or  if  is .

    */
    public static func AsMemory(text : Optional<dotnet.System.String>, start : Swift.Int32) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___AsMemory_0__2__String_i32(&__thrown, text?.get_handle() ?? nil, start);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Int32, System.Int32)
// docid: M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)
    /**
    Creates a new  over a portion of the target string beginning at a specified position with a length.

    - Parameter text: The target string.
    - Parameter start: The index at which to begin this slice.
    - Parameter length: The desired length for the slice.
    - Returns: The read-only character memory representation of the string, or  if  is .

    */
    public static func AsMemory(text : Optional<dotnet.System.String>, start : Swift.Int32, length : Swift.Int32) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___AsMemory_0__3__String_i32_i32(&__thrown, text?.get_handle() ?? nil, start, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Range)
// docid: M:System.MemoryExtensions.AsMemory(System.String,System.Range)
    /**
    Creates a new  over a specified range of the target string.

    - Parameter text: The target string.
    - Parameter range: The range that indicates the start and length of the sliced string.
    - Returns: The read-only character memory representation of the string.

    */
    public static func AsMemory(text : Optional<dotnet.System.String>, range : dotnet.System.Range) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___AsMemory_0__2__String_Range(&__thrown, text?.get_handle() ?? nil, range.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // System.Memory<T> AsMemory<T>(System.ArraySegment<T>)
// docid: M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})
    /**
    Creates a new memory region over the portion of the target array segment.

    - Parameter segment: The segment to convert.
    - Returns: The memory representation of the segment.

    */
    public static func AsMemory<UT : SGBridgeGenericValue>(segment : dotnet.System.ArraySegment_1<UT>) throws -> dotnet.System.Memory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_UT___AsMemory_1__1__System_ArraySegment_UT_(UT.get_type_handle(), &__thrown, segment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
    // System.Memory<T> AsMemory<T>(System.ArraySegment<T>, System.Int32)
// docid: M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)
    /**
    Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.

    - Parameter segment: The target array segment.
    - Parameter start: The index at which to begin the memory.
    - Returns: The memory representation of the whole or part of the array.

    */
    public static func AsMemory<UT : SGBridgeGenericValue>(segment : dotnet.System.ArraySegment_1<UT>, start : Swift.Int32) throws -> dotnet.System.Memory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_UT___AsMemory_1__2__System_ArraySegment_UT__i32(UT.get_type_handle(), &__thrown, segment.get_handle(), start);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
    // System.Memory<T> AsMemory<T>(System.ArraySegment<T>, System.Int32, System.Int32)
// docid: M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)
    /**
    Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.

    - Parameter segment: The target array segment.
    - Parameter start: The index at which to begin the memory.
    - Parameter length: The number of items in the memory.
    - Returns: The memory representation of the whole or part of the array.

    */
    public static func AsMemory<UT : SGBridgeGenericValue>(segment : dotnet.System.ArraySegment_1<UT>, start : Swift.Int32, length : Swift.Int32) throws -> dotnet.System.Memory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_UT___AsMemory_1__3__System_ArraySegment_UT__i32_i32(UT.get_type_handle(), &__thrown, segment.get_handle(), start, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) System.Memory<T> AsMemory<T>(T[])
// TODO COPE (write_all_methods) (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Index)
// TODO COPE (write_all_methods) (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Int32)
// TODO COPE (write_all_methods) (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Int32, System.Int32)
// TODO COPE (write_all_methods) (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Range)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> AsSpan(System.String)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> AsSpan(System.String, System.Int32)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> AsSpan(System.String, System.Int32, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Index)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Int32, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Range)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[])
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Index)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Int32, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Range)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T>(System.ReadOnlySpan<T>, System.IComparable<T>)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T>(System.Span<T>, System.IComparable<T>)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparer>(System.ReadOnlySpan<T>, T, TComparer)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparable>(System.ReadOnlySpan<T>, TComparable)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparer>(System.Span<T>, T, TComparer)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparable>(System.Span<T>, TComparable)
// TODO COPE (write_all_methods) (span) System.Int32 CompareTo(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE (write_all_methods) (span) bool Contains(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE (parm span of t): bool Contains<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): bool Contains<T>(System.Span<T>, T)
    // void CopyTo<T>(T[], System.Memory<T>)
// docid: M:System.MemoryExtensions.CopyTo``1(System.T[],System.Memory{``0})
    public static func CopyTo<UT : SGBridgeGenericValue>(source : Optional<dotnet.System_Arr<UT>>, destination : dotnet.System.Memory_1<UT>) throws {
        var __thrown : NullableHandle = nil;
        System_MemoryExtensions_void__CopyTo_1__2__UTArray_System_Memory_UT_(UT.get_type_handle(), &__thrown, (source?.get_handle()), destination.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (parm span of t): void CopyTo<T>(T[], System.Span<T>)
// TODO COPE (write_all_methods) (span) bool EndsWith(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE (parm span of t): bool EndsWith<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool EndsWith<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (returns byreflike): System.Text.SpanLineEnumerator EnumerateLines(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Text.SpanLineEnumerator EnumerateLines(System.Span<System.Char>)
// TODO COPE (returns byreflike): System.Text.SpanRuneEnumerator EnumerateRunes(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Text.SpanRuneEnumerator EnumerateRunes(System.Span<System.Char>)
// TODO COPE (write_all_methods) (span) bool Equals(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE (write_all_methods) (span) System.Int32 IndexOf(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.ReadOnlySpan<T>, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.ReadOnlySpan<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.Span<T>, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.Span<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.Span<T>, T)
// TODO COPE (write_all_methods) (span) bool IsWhiteSpace(System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) System.Int32 LastIndexOf(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.ReadOnlySpan<T>, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.ReadOnlySpan<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.Span<T>, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.Span<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.Span<T>, T)
// TODO COPE (parm span of t): bool Overlaps<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool Overlaps<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>, ref System.Int32)
// TODO COPE (parm span of t): bool Overlaps<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool Overlaps<T>(System.Span<T>, System.ReadOnlySpan<T>, ref System.Int32)
// TODO COPE (parm span of t): void Reverse<T>(System.Span<T>)
// TODO COPE (parm span of t): System.Int32 SequenceCompareTo<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 SequenceCompareTo<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>, System.Collections.Generic.IEqualityComparer<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.Span<T>, System.ReadOnlySpan<T>, System.Collections.Generic.IEqualityComparer<T>)
// TODO COPE (parm span of t): void Sort<T>(System.Span<T>)
// TODO COPE (parm span of t): void Sort<T>(System.Span<T>, System.Comparison<T>)
// TODO COPE (parm span of t): void Sort<TKey, TValue>(System.Span<TKey>, System.Span<TValue>)
// TODO COPE (parm span of t): void Sort<TKey, TValue>(System.Span<TKey>, System.Span<TValue>, System.Comparison<TKey>)
// TODO COPE (parm span of t): void Sort<T, TComparer>(System.Span<T>, TComparer)
// TODO COPE (parm span of t): void Sort<TKey, TValue, TComparer>(System.Span<TKey>, System.Span<TValue>, TComparer)
// TODO COPE (write_all_methods) (span) bool StartsWith(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE (parm span of t): bool StartsWith<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool StartsWith<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (write_all_methods) (span) System.Int32 ToLower(System.ReadOnlySpan<System.Char>, System.Span<System.Char>, System.Globalization.CultureInfo)
// TODO COPE (write_all_methods) (span) System.Int32 ToLowerInvariant(System.ReadOnlySpan<System.Char>, System.Span<System.Char>)
// TODO COPE (write_all_methods) (span) System.Int32 ToUpper(System.ReadOnlySpan<System.Char>, System.Span<System.Char>, System.Globalization.CultureInfo)
// TODO COPE (write_all_methods) (span) System.Int32 ToUpperInvariant(System.ReadOnlySpan<System.Char>, System.Span<System.Char>)
    // System.Memory<System.Char> Trim(System.Memory<System.Char>)
// docid: M:System.MemoryExtensions.Trim(System.Memory{System.Char})
    /**
    Removes all leading and trailing whitespace characters from a character memory region.

    - Parameter memory: The source memory from which the characters are removed.
    - Returns: The trimmed character memory region.

    */
    public static func Trim(memory : dotnet.System.Memory_1<dotnet.System.Char>) throws -> dotnet.System.Memory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_System_Char___Trim_0__1__System_Memory_System_Char_(&__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
    // System.ReadOnlyMemory<System.Char> Trim(System.ReadOnlyMemory<System.Char>)
// docid: M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})
    /**
    Removes all leading and trailing whitespace characters from a read-only character memory region.

    - Parameter memory: The source memory from which the characters are removed.
    - Returns: The trimmed character memory region.

    */
    public static func Trim(memory : dotnet.System.ReadOnlyMemory_1<dotnet.System.Char>) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___Trim_0__1__System_ReadOnlyMemory_System_Char_(&__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> Trim(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> Trim(System.ReadOnlySpan<System.Char>, System.Char)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> Trim(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Span<System.Char> Trim(System.Span<System.Char>)
    // System.Memory<System.Char> TrimEnd(System.Memory<System.Char>)
// docid: M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})
    /**
    Removes all trailing whitespace characters from a character memory region.

    - Parameter memory: The source memory from which the characters are removed.
    - Returns: The trimmed character memory region.

    */
    public static func TrimEnd(memory : dotnet.System.Memory_1<dotnet.System.Char>) throws -> dotnet.System.Memory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_System_Char___TrimEnd_0__1__System_Memory_System_Char_(&__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
    // System.ReadOnlyMemory<System.Char> TrimEnd(System.ReadOnlyMemory<System.Char>)
// docid: M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})
    /**
    Removes all trailing whitespace characters from a read-only character memory region.

    - Parameter memory: The source memory from which the characters are removed.
    - Returns: The trimmed read-only character span.

    */
    public static func TrimEnd(memory : dotnet.System.ReadOnlyMemory_1<dotnet.System.Char>) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___TrimEnd_0__1__System_ReadOnlyMemory_System_Char_(&__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimEnd(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimEnd(System.ReadOnlySpan<System.Char>, System.Char)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimEnd(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Span<System.Char> TrimEnd(System.Span<System.Char>)
// TODO COPE (parm span of t): System.Memory<T> TrimEnd<T>(System.Memory<T>, System.ReadOnlySpan<T>)
    // System.Memory<T> TrimEnd<T>(System.Memory<T>, T)
// docid: M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)
    /**
    Removes all trailing occurrences of a specified element from a character memory region.

    - Parameter memory: The source memory from which the element is removed.
    - Parameter trimElement: The specified element to look for and remove.
    - Returns: The trimmed memory region.

    */
    public static func TrimEnd<UT : SGBridgeGenericValue>(memory : dotnet.System.Memory_1<UT>, trimElement : UT) throws -> dotnet.System.Memory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_UT___TrimEnd_1__2__System_Memory_UT__UT(UT.get_type_handle(), &__thrown, memory.get_handle(), trimElement.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (parm span of t): System.ReadOnlyMemory<T> TrimEnd<T>(System.ReadOnlyMemory<T>, System.ReadOnlySpan<T>)
    // System.ReadOnlyMemory<T> TrimEnd<T>(System.ReadOnlyMemory<T>, T)
// docid: M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)
    /**
    Removes all trailing occurrences of a specified element from a read-only memory region.

    - Parameter memory: The source memory from which the element is removed.
    - Parameter trimElement: The specified element to look for and remove.
    - Returns: The trimmed read-only memory region.

    */
    public static func TrimEnd<UT : SGBridgeGenericValue>(memory : dotnet.System.ReadOnlyMemory_1<UT>, trimElement : UT) throws -> dotnet.System.ReadOnlyMemory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_UT___TrimEnd_1__2__System_ReadOnlyMemory_UT__UT(UT.get_type_handle(), &__thrown, memory.get_handle(), trimElement.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimEnd<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimEnd<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Span<T> TrimEnd<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Span<T> TrimEnd<T>(System.Span<T>, T)
    // System.Memory<System.Char> TrimStart(System.Memory<System.Char>)
// docid: M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})
    /**
    Removes all leading whitespace characters from a memory region.

    - Parameter memory: The source memory from which the characters are removed.
    - Returns: The trimmed character memory region.

    */
    public static func TrimStart(memory : dotnet.System.Memory_1<dotnet.System.Char>) throws -> dotnet.System.Memory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_System_Char___TrimStart_0__1__System_Memory_System_Char_(&__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
    // System.ReadOnlyMemory<System.Char> TrimStart(System.ReadOnlyMemory<System.Char>)
// docid: M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})
    /**
    Removes all leading whitespace characters from a read-only memory region.

    - Parameter memory: The source memory from which the characters are removed.
    - Returns: The trimmed read-only character memory region.

    */
    public static func TrimStart(memory : dotnet.System.ReadOnlyMemory_1<dotnet.System.Char>) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_System_Char___TrimStart_0__1__System_ReadOnlyMemory_System_Char_(&__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimStart(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimStart(System.ReadOnlySpan<System.Char>, System.Char)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimStart(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Span<System.Char> TrimStart(System.Span<System.Char>)
// TODO COPE (parm span of t): System.Memory<T> TrimStart<T>(System.Memory<T>, System.ReadOnlySpan<T>)
    // System.Memory<T> TrimStart<T>(System.Memory<T>, T)
// docid: M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)
    /**
    Removes all leading occurrences of a specified element from a memory region.

    - Parameter memory: The source memory region from which the element is removed.
    - Parameter trimElement: The specified element to look for and remove.
    - Returns: The trimmed memory region.

    */
    public static func TrimStart<UT : SGBridgeGenericValue>(memory : dotnet.System.Memory_1<UT>, trimElement : UT) throws -> dotnet.System.Memory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_UT___TrimStart_1__2__System_Memory_UT__UT(UT.get_type_handle(), &__thrown, memory.get_handle(), trimElement.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (parm span of t): System.ReadOnlyMemory<T> TrimStart<T>(System.ReadOnlyMemory<T>, System.ReadOnlySpan<T>)
    // System.ReadOnlyMemory<T> TrimStart<T>(System.ReadOnlyMemory<T>, T)
// docid: M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)
    /**
    Removes all leading occurrences of a specified element from a memory region.

    - Parameter memory: The source memory from which the element is removed.
    - Parameter trimElement: The specified element to look for and remove.
    - Returns: The trimmed read-only memory region.

    */
    public static func TrimStart<UT : SGBridgeGenericValue>(memory : dotnet.System.ReadOnlyMemory_1<UT>, trimElement : UT) throws -> dotnet.System.ReadOnlyMemory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_UT___TrimStart_1__2__System_ReadOnlyMemory_UT__UT(UT.get_type_handle(), &__thrown, memory.get_handle(), trimElement.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimStart<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimStart<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Span<T> TrimStart<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Span<T> TrimStart<T>(System.Span<T>, T)
// TODO COPE (parm span of t): System.Memory<T> Trim<T>(System.Memory<T>, System.ReadOnlySpan<T>)
    // System.Memory<T> Trim<T>(System.Memory<T>, T)
// docid: M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)
    /**
    Removes all leading and trailing occurrences of a specified element from a memory region.

    - Parameter memory: The source memory from which the element is removed.
    - Parameter trimElement: The specified element to look for and remove.
    - Returns: The trimmed memory region.

    */
    public static func Trim<UT : SGBridgeGenericValue>(memory : dotnet.System.Memory_1<UT>, trimElement : UT) throws -> dotnet.System.Memory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_Memory_UT___Trim_1__2__System_Memory_UT__UT(UT.get_type_handle(), &__thrown, memory.get_handle(), trimElement.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (parm span of t): System.ReadOnlyMemory<T> Trim<T>(System.ReadOnlyMemory<T>, System.ReadOnlySpan<T>)
    // System.ReadOnlyMemory<T> Trim<T>(System.ReadOnlyMemory<T>, T)
// docid: M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)
    /**
    Removes all leading and trailing occurrences of a specified element from a read-only memory region.

    - Parameter memory: The source memory from which the element is removed.
    - Parameter trimElement: The specified element to look for and remove.
    - Returns: The trimmed read-only memory region.

    */
    public static func Trim<UT : SGBridgeGenericValue>(memory : dotnet.System.ReadOnlyMemory_1<UT>, trimElement : UT) throws -> dotnet.System.ReadOnlyMemory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_MemoryExtensions_System_ReadOnlyMemory_UT___Trim_1__2__System_ReadOnlyMemory_UT__UT(UT.get_type_handle(), &__thrown, memory.get_handle(), trimElement.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
// TODO COPE (parm span of t): System.ReadOnlySpan<T> Trim<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.ReadOnlySpan<T> Trim<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Span<T> Trim<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Span<T> Trim<T>(System.Span<T>, T)
// TODO COPE (parm byref span): bool TryWrite(System.Span<System.Char>, ref System.MemoryExtensions.TryWriteInterpolatedStringHandler, ref System.Int32)
// TODO COPE (parm byref span): bool TryWrite(System.Span<System.Char>, System.IFormatProvider, ref System.MemoryExtensions.TryWriteInterpolatedStringHandler, ref System.Int32)
} // MemoryExtensions


// type: System.SequencePosition
// boxed value type
    /**
    Represents a position in a non-contiguous set of memory. Properties of this type should not be interpreted by anything but the type that created it.

    */
public final class SequencePosition
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_SequencePosition_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Object, System.Int32)
// docid: M:System.SequencePosition.#ctor(System.Object,System.Int32)
    /**
    Initializes a new instance of the  struct.

    - Parameter object: A non-contiguous set of memory.
    - Parameter integer: The position in .
    */
    public init(object : Optional<dotnet.System.Object>, integer : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_SequencePosition_ctor_0__2__Object_i32(&__thrown, object?.get_handle() ?? nil, integer);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_SequencePosition_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Object)
// docid: M:System.SequencePosition.Equals(System.Object)
    /**
    Returns a value that indicates whether the current instance is equal to another object.

    - Parameter obj: The object to compare with the current instance.
    - Returns: 
         if  is of type  and is equal to the current instance; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_SequencePosition_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.SequencePosition)
// docid: M:System.SequencePosition.Equals(System.SequencePosition)
    /**
    Indicates whether the current instance is equal to another .

    - Parameter other: The sequence position to compare with the current instance.
    - Returns: 
         if the two instances are equal;  otherwise.

    */
    public func Equals(other : dotnet.System.SequencePosition) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_SequencePosition_bool__Equals_0__1__SequencePosition(&__thrown, self.get_handle(), other.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.SequencePosition.GetHashCode
    /**
    Returns the hash code for this instance.

    - Returns: The hash code for this instance.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_SequencePosition_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetInteger()
// docid: M:System.SequencePosition.GetInteger
    /**
    Returns the integer part of this .

    - Returns: The integer part of this sequence position.

    */
    public func GetInteger() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_SequencePosition_i32__GetInteger_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Object GetObject()
// docid: M:System.SequencePosition.GetObject
    /**
    Returns the object part of this .

    - Returns: The object part of this sequence position.

    */
    public func GetObject() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_SequencePosition_Object__GetObject_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // SequencePosition


}
// System.Buffers
extension System.Buffers {
// type: System.Buffers.ArrayBufferWriter`1
    /**
    Represents a heap-based, array-backed output sink into which  data can be written.

    */
public final class ArrayBufferWriter_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Buffers_ArrayBufferWriter_1_get_type_handle(T.get_type_handle());
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Buffers_ArrayBufferWriter_1_cast(T.get_type_handle(),&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Buffers.ArrayBufferWriter`1.#ctor
    /**
    Creates an instance of an  to which data can be written, with the default initial capacity.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Buffers_ArrayBufferWriter_1_ctor_0__0(T.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)
    /**
    Creates an instance of an  to which data can be written, with a specified initial capacity.

    - Parameter initialCapacity: The minimum capacity with which to initialize the underlying buffer.
    */
    public init(initialCapacity : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Buffers_ArrayBufferWriter_1_ctor_0__1__i32(T.get_type_handle(), &__thrown, initialCapacity);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE (returns byreflike): [IsSpecialName] System.ReadOnlySpan<T> get_WrittenSpan()
    // void Advance(System.Int32)
// docid: M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)
    /**
    Notifies the  that  items were written to the output /.

    - Parameter count: The number of items written.
    */
    public func Advance(count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Buffers_ArrayBufferWriter_1_void__Advance_0__1__i32(T.get_type_handle(), &__thrown, self.get_handle(), count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Clear()
// docid: M:System.Buffers.ArrayBufferWriter`1.Clear
    /**
    Clears the data written to the underlying buffer.

    */
    public func Clear() throws {
        var __thrown : NullableHandle = nil;
        System_Buffers_ArrayBufferWriter_1_void__Clear_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Memory<T> GetMemory(System.Int32)
// docid: M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)
    /**
    Returns a  to write to that is at least the length specified by .

    - Parameter sizeHint: The minimum requested length of the .
    - Returns: A  whose length is at least .  If  is not provided or is equal to 0, some non-empty buffer is returned.

    */
    public func GetMemory(sizeHint : Swift.Int32 = 0) throws -> dotnet.System.Memory_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ArrayBufferWriter_1_System_Memory_T___GetMemory_0__1__i32(T.get_type_handle(), &__thrown, self.get_handle(), sizeHint);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (returns byreflike): System.Span<T> GetSpan(System.Int32)
    // [IsSpecialName] System.Int32 get_Capacity()
// docid: M:System.Buffers.ArrayBufferWriter`1.get_Capacity
    public func get_Capacity() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ArrayBufferWriter_1_i32__get_Capacity_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_FreeCapacity()
// docid: M:System.Buffers.ArrayBufferWriter`1.get_FreeCapacity
    public func get_FreeCapacity() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ArrayBufferWriter_1_i32__get_FreeCapacity_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_WrittenCount()
// docid: M:System.Buffers.ArrayBufferWriter`1.get_WrittenCount
    public func get_WrittenCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ArrayBufferWriter_1_i32__get_WrittenCount_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.ReadOnlyMemory<T> get_WrittenMemory()
// docid: M:System.Buffers.ArrayBufferWriter`1.get_WrittenMemory
    public func get_WrittenMemory() throws -> dotnet.System.ReadOnlyMemory_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ArrayBufferWriter_1_System_ReadOnlyMemory_T___get_WrittenMemory_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    /**
    Gets the total amount of space within the underlying buffer.

    */
    public var Capacity : Swift.Int32 {
        get {
            return try! get_Capacity();
        }
    }
    /**
    Gets the amount of available space that can be written to without forcing the underlying buffer to grow.

    */
    public var FreeCapacity : Swift.Int32 {
        get {
            return try! get_FreeCapacity();
        }
    }
    /**
    Gets the amount of data written to the underlying buffer.

    */
    public var WrittenCount : Swift.Int32 {
        get {
            return try! get_WrittenCount();
        }
    }
    /**
    Gets a  that contains the data written to the underlying buffer so far.

    */
    public var WrittenMemory : dotnet.System.ReadOnlyMemory_1<T> {
        get {
            return try! get_WrittenMemory();
        }
    }
} // ArrayBufferWriter_1


// type: System.Buffers.BuffersExtensions
public struct BuffersExtensions {
// TODO COPE (parm span of t): void CopyTo<T>(ref System.Buffers.ReadOnlySequence<T>, System.Span<T>)
    // System.Nullable<System.SequencePosition> PositionOf<T>(ref System.Buffers.ReadOnlySequence<T>, T)
// docid: M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0}@,``0)
    public static func PositionOf<UT : SGBridgeGenericValue>(source : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<UT>>, value : UT) throws -> Optional<dotnet.System.SequencePosition> {
        var __thrown : NullableHandle = nil;
            var _tmp_in_source = (source != nil) ? (source!.get_handle()) : nil;
        let __return = System_Buffers_BuffersExtensions_System_Nullable_System_SequencePosition___PositionOf_1__2__inSystem_Buffers_ReadOnlySequence_UT__UT(UT.get_type_handle(), &__thrown, &_tmp_in_source, value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.SequencePosition(hndl: __return!)) : nil;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) T[] ToArray<T>(ref System.Buffers.ReadOnlySequence<T>)
// TODO COPE (parm span of t): void Write<T>(System.Buffers.IBufferWriter<T>, System.ReadOnlySpan<T>)
} // BuffersExtensions


// type: System.Buffers.IBufferWriter`1
    /**
    Represents an output sink into which  data can be written.

    */
open class IBufferWriter_1<T : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    System_Buffers_IBufferWriter_1
{
    public typealias T_IBufferWriter_1 = T;
    open class func get_type_handle() -> TypeHandle {
        return System_Buffers_IBufferWriter_1_get_type_handle(T.get_type_handle());
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Buffers_IBufferWriter_1_cast(T.get_type_handle(),&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // void Advance(System.Int32)
// docid: M:System.Buffers.IBufferWriter`1.Advance(System.Int32)
    /**
    Notifies the  that  data items were written to the output  or .

    - Parameter count: The number of data items written to the  or .
    */
    open func Advance(count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Buffers_IBufferWriter_1_void__Advance_0__1__i32(T.get_type_handle(), &__thrown, self.get_handle(), count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Memory<T> GetMemory(System.Int32)
// docid: M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)
    /**
    Returns a  to write to that is at least the requested size (specified by ).

    - Parameter sizeHint: The minimum length of the returned . If 0, a non-empty buffer is returned.
    - Returns: A  of at least the size . If  is 0, returns a non-empty buffer.

    */
    open func GetMemory(sizeHint : Swift.Int32 = 0) throws -> dotnet.System.Memory_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_IBufferWriter_1_System_Memory_T___GetMemory_0__1__i32(T.get_type_handle(), &__thrown, self.get_handle(), sizeHint);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (returns byreflike): System.Span<T> GetSpan(System.Int32)
} // IBufferWriter_1


// type: System.Buffers.MemoryPool`1
    /**
    Represents a pool of memory blocks.

    */
open class MemoryPool_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Buffers_MemoryPool_1_get_type_handle(T.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Buffers_MemoryPool_1_cast(T.get_type_handle(),&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // void Dispose()
// docid: M:System.Buffers.MemoryPool`1.Dispose
    /**
    Frees all resources used by the memory pool.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Buffers_MemoryPool_1_void__Dispose_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Buffers.IMemoryOwner<T> Rent(System.Int32)
// docid: M:System.Buffers.MemoryPool`1.Rent(System.Int32)
    /**
    Returns a memory block capable of holding at least  elements of T.

    - Parameter minBufferSize: The minimum number of elements of  that the memory pool can hold. A value of -1 returns a memory pool set to the default size for the pool.
    - Returns: A memory block capable of holding at least  elements of T.

    */
    open func Rent(minBufferSize : Swift.Int32 = -1) throws -> dotnet.System.Buffers.IMemoryOwner_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_MemoryPool_1_System_Buffers_IMemoryOwner_T___Rent_0__1__i32(T.get_type_handle(), &__thrown, self.get_handle(), minBufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.IMemoryOwner_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_MaxBufferSize()
// docid: M:System.Buffers.MemoryPool`1.get_MaxBufferSize
    open func get_MaxBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_MemoryPool_1_i32__get_MaxBufferSize_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Buffers.MemoryPool<T> get_Shared()
// docid: M:System.Buffers.MemoryPool`1.get_Shared
    open class func get_Shared() throws -> dotnet.System.Buffers.MemoryPool_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_MemoryPool_1_System_Buffers_MemoryPool_T___get_Shared_0__0(T.get_type_handle(), &__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.MemoryPool_1(hndl : __return);
        }
    }
    /**
    Gets the maximum buffer size supported by this pool.

    */
    open var MaxBufferSize : Swift.Int32 {
        get {
            return try! get_MaxBufferSize();
        }
    }
    /**
    Gets a singleton instance of a memory pool based on arrays.

    */
    public static var Shared : dotnet.System.Buffers.MemoryPool_1<T> {
        get {
            return try! get_Shared();
        }
    }
} // MemoryPool_1


// type: System.Buffers.ReadOnlySequenceSegment`1
    /**
    Represents a linked list of  nodes.

    */
open class ReadOnlySequenceSegment_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Buffers_ReadOnlySequenceSegment_1_get_type_handle(T.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Buffers_ReadOnlySequenceSegment_1_cast(T.get_type_handle(),&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] System.ReadOnlyMemory<T> get_Memory()
// docid: M:System.Buffers.ReadOnlySequenceSegment`1.get_Memory
    open func get_Memory() throws -> dotnet.System.ReadOnlyMemory_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequenceSegment_1_System_ReadOnlyMemory_T___get_Memory_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Memory(System.ReadOnlyMemory<T>)
// docid: M:System.Buffers.ReadOnlySequenceSegment`1.set_Memory(System.ReadOnlyMemory{`0})
    open func set_Memory(value : dotnet.System.ReadOnlyMemory_1<T>) throws {
        var __thrown : NullableHandle = nil;
        System_Buffers_ReadOnlySequenceSegment_1_void__set_Memory_0__1__System_ReadOnlyMemory_T_(T.get_type_handle(), &__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Buffers.ReadOnlySequenceSegment<T> get_Next()
// docid: M:System.Buffers.ReadOnlySequenceSegment`1.get_Next
    open func get_Next() throws -> Optional<dotnet.System.Buffers.ReadOnlySequenceSegment_1<T>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequenceSegment_1_System_Buffers_ReadOnlySequenceSegment_T___get_Next_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Buffers.ReadOnlySequenceSegment_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Next(System.Buffers.ReadOnlySequenceSegment<T>)
// docid: M:System.Buffers.ReadOnlySequenceSegment`1.set_Next(System.Buffers.ReadOnlySequenceSegment{`0})
    open func set_Next(value : Optional<dotnet.System.Buffers.ReadOnlySequenceSegment_1<T>>) throws {
        var __thrown : NullableHandle = nil;
        System_Buffers_ReadOnlySequenceSegment_1_void__set_Next_0__1__System_Buffers_ReadOnlySequenceSegment_T_(T.get_type_handle(), &__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_RunningIndex()
// docid: M:System.Buffers.ReadOnlySequenceSegment`1.get_RunningIndex
    open func get_RunningIndex() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequenceSegment_1_i64__get_RunningIndex_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_RunningIndex(System.Int64)
// docid: M:System.Buffers.ReadOnlySequenceSegment`1.set_RunningIndex(System.Int64)
    open func set_RunningIndex(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Buffers_ReadOnlySequenceSegment_1_void__set_RunningIndex_0__1__i64(T.get_type_handle(), &__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets a  value for the current node.

    */
    open var Memory : dotnet.System.ReadOnlyMemory_1<T> {
        get {
            return try! get_Memory();
        }
        set(v) {
            return try! set_Memory(value: v);
        }
    }
    /**
    Gets or sets the next node.

    */
    open var Next : Optional<dotnet.System.Buffers.ReadOnlySequenceSegment_1<T>> {
        get {
            return try! get_Next();
        }
        set(v) {
            return try! set_Next(value: v!);
        }
    }
    /**
    Gets or sets the sum of node lengths before the current node.

    */
    open var RunningIndex : Swift.Int64 {
        get {
            return try! get_RunningIndex();
        }
        set(v) {
            return try! set_RunningIndex(value: v);
        }
    }
} // ReadOnlySequenceSegment_1


// type: System.Buffers.ReadOnlySequence`1
// boxed value type
    /**
    Represents a sequence that can read a sequential series of .

    */
public final class ReadOnlySequence_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Buffers_ReadOnlySequence_1_get_type_handle(T.get_type_handle());
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field:  Empty
    /**
    Returns an empty .

    */
    public class var Empty : dotnet.System.Buffers.ReadOnlySequence_1<T> {
        get {
        let __return = dotnet.System.Buffers.ReadOnlySequence_1<T>(hndl: System_Buffers_ReadOnlySequence_1_get_Empty());
            return __return;
        }
    }
    /**
    Gets the position at the end of the .

    */
    public var End : dotnet.System.SequencePosition {
        get {
            return try! get_End();
        }
    }
    /**
    Gets the  from the first segment.

    */
    public var First : dotnet.System.ReadOnlyMemory_1<T> {
        get {
            return try! get_First();
        }
    }
    /**
    Gets a value that indicates whether the  is empty.

    */
    public var IsEmpty : Bool {
        get {
            return try! get_IsEmpty();
        }
    }
    /**
    Gets a value that indicates whether the  contains a single  segment.

    */
    public var IsSingleSegment : Bool {
        get {
            return try! get_IsSingleSegment();
        }
    }
    /**
    Gets the length of the .

    */
    public var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets the position to the start of the .

    */
    public var Start : dotnet.System.SequencePosition {
        get {
            return try! get_Start();
        }
    }
    // .ctor(System.Buffers.ReadOnlySequenceSegment<T>, System.Int32, System.Buffers.ReadOnlySequenceSegment<T>, System.Int32)
// docid: M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)
    /**
    Creates an instance of a  from a linked memory list represented by start and end segments and the corresponding indexes in them.

    - Parameter startSegment: The initial node of the linked memory list.
    - Parameter startIndex: The position to the start of the sequence inside .
    - Parameter endSegment: The final node of the linked memory list.
    - Parameter endIndex: The position to the end of the sequence inside .
    */
    public init(startSegment : dotnet.System.Buffers.ReadOnlySequenceSegment_1<T>, startIndex : Swift.Int32, endSegment : dotnet.System.Buffers.ReadOnlySequenceSegment_1<T>, endIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Buffers_ReadOnlySequence_1_ctor_0__4__System_Buffers_ReadOnlySequenceSegment_T__i32_System_Buffers_ReadOnlySequenceSegment_T__i32(T.get_type_handle(), &__thrown, startSegment.get_handle(), startIndex, endSegment.get_handle(), endIndex);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.ReadOnlyMemory<T>)
// docid: M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})
    /**
    Creates an instance of  from a .

    - Parameter memory: A read-only block of memory of elements of type .
    */
    public init(memory : dotnet.System.ReadOnlyMemory_1<T>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Buffers_ReadOnlySequence_1_ctor_0__1__System_ReadOnlyMemory_T_(T.get_type_handle(), &__thrown, memory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(T[])
// docid: M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.T[])
    public init(array : dotnet.System_Arr<T>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Buffers_ReadOnlySequence_1_ctor_0__1__TArray(T.get_type_handle(), &__thrown, array.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(T[], System.Int32, System.Int32)
// docid: M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.T[],System.Int32,System.Int32)
    public init(array : dotnet.System_Arr<T>, start : Swift.Int32, length : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Buffers_ReadOnlySequence_1_ctor_0__3__TArray_i32_i32(T.get_type_handle(), &__thrown, array.get_handle(), start, length);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Buffers_ReadOnlySequence_1_implicit_ctor(T.get_type_handle());
            super.init(hndl: h);
    }
// TODO COPE (returns byreflike): [IsSpecialName] System.ReadOnlySpan<T> get_FirstSpan()
    // System.Buffers.ReadOnlySequence<T>.Enumerator GetEnumerator()
// docid: M:System.Buffers.ReadOnlySequence`1.GetEnumerator
    /**
    Returns an enumerator over the .

    - Returns: Returns an enumerator over the .

    */
    public func GetEnumerator() throws -> dotnet.System.Buffers.ReadOnlySequence_Enumerator_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T__System_Buffers_Enumerator_T___GetEnumerator_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_Enumerator_1(hndl : __return);
        }
    }
    // System.Int64 GetOffset(System.SequencePosition)
// docid: M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)
    /**
    Returns the offset of a  within this sequence from the start.

    - Parameter position: The  of which to get the offset.
    - Returns: The offset from the start of the sequence.

    */
    public func GetOffset(position : dotnet.System.SequencePosition) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_i64__GetOffset_0__1__SequencePosition(T.get_type_handle(), &__thrown, self.get_handle(), position.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.SequencePosition GetPosition(System.Int64)
// docid: M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)
    /**
    Returns a new  at an  from the start of the sequence.

    - Parameter offset: The offset from the start of the sequence.
    - Returns: An object representing the sequence position that starts at the specified  from the start of the sequence.

    */
    public func GetPosition(offset : Swift.Int64) throws -> dotnet.System.SequencePosition {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_SequencePosition__GetPosition_0__1__i64(T.get_type_handle(), &__thrown, self.get_handle(), offset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.SequencePosition(hndl : __return);
        }
    }
    // System.SequencePosition GetPosition(System.Int64, System.SequencePosition)
// docid: M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)
    /**
    Returns a new  starting at the specified offset from the  position.

    - Parameter offset: The offset from the specified  sequence position.
    - Parameter origin: A sequence position representing the point from which to initiate the offset.
    - Returns: An object representing the sequence position that starts at the  position of the specified  position object.

    */
    public func GetPosition(offset : Swift.Int64, origin : dotnet.System.SequencePosition) throws -> dotnet.System.SequencePosition {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_SequencePosition__GetPosition_0__2__i64_SequencePosition(T.get_type_handle(), &__thrown, self.get_handle(), offset, origin.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.SequencePosition(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.Int32, System.Int32)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)
    /**
    Forms a slice out of the current , beginning at , with  items.

    - Parameter start: The index at which to begin this slice.
    - Parameter length: The length of the slice.
    - Returns: A slice that consists of  elements from the current instance starting at index .

    */
    public func Slice(start : Swift.Int32, length : Swift.Int32) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__2__i32_i32(T.get_type_handle(), &__thrown, self.get_handle(), start, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.Int32, System.SequencePosition)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)
    /**
    Forms a slice out of the current , beginning at  and ending at  (exclusive).

    - Parameter start: The index at which to begin this slice.
    - Parameter end: The end (exclusive)  of the slice.
    - Returns: A slice that consists of items from the  index to, but not including, the  sequence position in the current read-only sequence.

    */
    public func Slice(start : Swift.Int32, end : dotnet.System.SequencePosition) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__2__i32_SequencePosition(T.get_type_handle(), &__thrown, self.get_handle(), start, end.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.Int64)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)
    /**
    Forms a slice out of the current , beginning at a specified index and continuing to the end of the read-only sequence.

    - Parameter start: The start index at which to begin this slice.
    - Returns: A slice starting at index  and continuing to the end of the current read-only sequence.

    */
    public func Slice(start : Swift.Int64) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__1__i64(T.get_type_handle(), &__thrown, self.get_handle(), start);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.Int64, System.Int64)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)
    /**
    Forms a slice out of the given , beginning at , with  items.

    - Parameter start: The index at which to begin this slice.
    - Parameter length: The length of the slice.
    - Returns: A slice that consists of  elements from the current instance starting at index .

    */
    public func Slice(start : Swift.Int64, length : Swift.Int64) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__2__i64_i64(T.get_type_handle(), &__thrown, self.get_handle(), start, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.Int64, System.SequencePosition)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)
    /**
    Forms a slice out of the current , beginning at  and ending at  (exclusive).

    - Parameter start: The index at which to begin this slice.
    - Parameter end: The end (exclusive) of the slice.
    - Returns: A slice that consists of items from the  index to, but not including, the  sequence position in the current read-only sequence.

    */
    public func Slice(start : Swift.Int64, end : dotnet.System.SequencePosition) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__2__i64_SequencePosition(T.get_type_handle(), &__thrown, self.get_handle(), start, end.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)
    /**
    Forms a slice out of the current , beginning at a specified sequence position and continuing to the end of the read-only sequence.

    - Parameter start: The starting (inclusive)  at which to begin this slice.
    - Returns: A slice starting at sequence position  and continuing to the end of the current read-only sequence.

    */
    public func Slice(start : dotnet.System.SequencePosition) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__1__SequencePosition(T.get_type_handle(), &__thrown, self.get_handle(), start.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition, System.Int32)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)
    /**
    Forms a slice out of the current , beginning at , with  items.

    - Parameter start: The starting (inclusive)  at which to begin this slice.
    - Parameter length: The length of the slice.
    - Returns: A slice that consists of  elements from the current instance starting at sequence position .

    */
    public func Slice(start : dotnet.System.SequencePosition, length : Swift.Int32) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__2__SequencePosition_i32(T.get_type_handle(), &__thrown, self.get_handle(), start.get_handle(), length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition, System.Int64)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)
    /**
    Forms a slice out of the current , beginning at , with  items.

    - Parameter start: The starting (inclusive)  at which to begin this slice.
    - Parameter length: The length of the slice.
    - Returns: A slice that consists of  elements from the current instance starting at sequence position .

    */
    public func Slice(start : dotnet.System.SequencePosition, length : Swift.Int64) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__2__SequencePosition_i64(T.get_type_handle(), &__thrown, self.get_handle(), start.get_handle(), length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition, System.SequencePosition)
// docid: M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)
    /**
    Forms a slice out of the current , beginning at  and ending at  (exclusive).

    - Parameter start: The starting (inclusive)  at which to begin this slice.
    - Parameter end: The ending (exclusive)  of the slice.
    - Returns: A slice that consists of items from the  sequence position to, but not including, the  sequence position in the current read-only sequence.

    */
    public func Slice(start : dotnet.System.SequencePosition, end : dotnet.System.SequencePosition) throws -> dotnet.System.Buffers.ReadOnlySequence_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_Buffers_ReadOnlySequence_T___Slice_0__2__SequencePosition_SequencePosition(T.get_type_handle(), &__thrown, self.get_handle(), start.get_handle(), end.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // System.String ToString()
// docid: M:System.Buffers.ReadOnlySequence`1.ToString
    /**
    Returns a string that represents the current sequence.

    - Returns: A string that represents the current sequence.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_String__ToString_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // bool TryGet(ref System.SequencePosition, ref System.ReadOnlyMemory<T>, bool)
// docid: M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)
    /**
    Tries to retrieve the next segment after  and returns a value that indicates whether the operation succeeded.

    - Parameter position: The current sequence position.
    - Parameter memory: A read-only memory span that contains the next segment after .
    - Parameter advance: 
         if  should to the beginning of next segment; otherwise, .
    - Returns: Returns  if the method returned the next segment, or  if the end of the read-only sequence was reached.

    */
    public func TryGet(position : inout dotnet.System.SequencePosition, memory : inout Optional<dotnet.System.ReadOnlyMemory_1<T>>, advance : Bool = true) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_position = position.get_handle();
            var _tmp_out_memory = (memory != nil) ? (memory!.get_handle()) : nil;
        let __return = System_Buffers_ReadOnlySequence_1_bool__TryGet_0__3__refSequencePosition_outSystem_ReadOnlyMemory_T__bool(T.get_type_handle(), &__thrown, self.get_handle(), &_tmp_ref_position, &_tmp_out_memory, Swift.Int32(advance ? 1 : 0));
        let _tmp2_position = dotnet.System.SequencePosition(hndl: _tmp_ref_position);
            position = _tmp2_position;
        let __h__tmp2_memory = _tmp_out_memory;
        let _tmp2_memory = (__h__tmp2_memory != nil) ? dotnet.System.ReadOnlyMemory_1<T>(hndl: __h__tmp2_memory!) : nil;
            memory = _tmp2_memory;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.SequencePosition get_End()
// docid: M:System.Buffers.ReadOnlySequence`1.get_End
    public func get_End() throws -> dotnet.System.SequencePosition {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_SequencePosition__get_End_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.SequencePosition(hndl : __return);
        }
    }
    // [IsSpecialName] System.ReadOnlyMemory<T> get_First()
// docid: M:System.Buffers.ReadOnlySequence`1.get_First
    public func get_First() throws -> dotnet.System.ReadOnlyMemory_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_System_ReadOnlyMemory_T___get_First_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsEmpty()
// docid: M:System.Buffers.ReadOnlySequence`1.get_IsEmpty
    public func get_IsEmpty() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_bool__get_IsEmpty_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSingleSegment()
// docid: M:System.Buffers.ReadOnlySequence`1.get_IsSingleSegment
    public func get_IsSingleSegment() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_bool__get_IsSingleSegment_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.Buffers.ReadOnlySequence`1.get_Length
    public func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_i64__get_Length_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.SequencePosition get_Start()
// docid: M:System.Buffers.ReadOnlySequence`1.get_Start
    public func get_Start() throws -> dotnet.System.SequencePosition {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_SequencePosition__get_Start_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.SequencePosition(hndl : __return);
        }
    }
} // ReadOnlySequence_1


// type: System.Buffers.ReadOnlySequence`1+Enumerator
// boxed value type
    /**
    Represents an enumerator over a .

    */
public final class ReadOnlySequence_Enumerator_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Buffers_ReadOnlySequence_1_Enumerator_get_type_handle(T.get_type_handle());
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the current .

    */
    public var Current : dotnet.System.ReadOnlyMemory_1<T> {
        get {
            return try! get_Current();
        }
    }
    // .ctor(ref System.Buffers.ReadOnlySequence<T>)
// docid: M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)
    /**
    Initializes the enumerator.

    - Parameter sequence: The  to enumerate.
    */
    public init(sequence : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<T>>) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_in_sequence = (sequence != nil) ? (sequence!.get_handle()) : nil;
        let h = System_Buffers_ReadOnlySequence_1_Enumerator_ctor_0__1__inSystem_Buffers_ReadOnlySequence_T_(T.get_type_handle(), &__thrown, &_tmp_in_sequence);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Buffers_ReadOnlySequence_1_Enumerator_implicit_ctor(T.get_type_handle());
            super.init(hndl: h);
    }
    // bool MoveNext()
// docid: M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext
    /**
    Moves to the next  in the .

    - Returns: 
         if the enumerator successfully advanced to the next item;  if the end of the sequence has been reached.

    */
    public func MoveNext() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_Enumerator_bool__MoveNext_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.ReadOnlyMemory<T> get_Current()
// docid: M:System.Buffers.ReadOnlySequence`1.Enumerator.get_Current
    public func get_Current() throws -> dotnet.System.ReadOnlyMemory_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_ReadOnlySequence_1_Enumerator_System_ReadOnlyMemory_T___get_Current_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
} // ReadOnlySequence_Enumerator_1


// type: System.Buffers.SequenceReaderExtensions
public struct SequenceReaderExtensions {
// TODO COPE (parm byref span): bool TryReadBigEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int16)
// TODO COPE (parm byref span): bool TryReadBigEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int32)
// TODO COPE (parm byref span): bool TryReadBigEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int64)
// TODO COPE (parm byref span): bool TryReadLittleEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int16)
// TODO COPE (parm byref span): bool TryReadLittleEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int32)
// TODO COPE (parm byref span): bool TryReadLittleEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int64)
} // SequenceReaderExtensions


// type: System.Buffers.StandardFormat
// boxed value type
    /**
    Represents a standard format string without using an actual string.

    */
public final class StandardFormat
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Buffers_StandardFormat_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Byte MaxPrecision
    /**
    Defines the maximum valid precision value.

    */
    public class var MaxPrecision : Swift.UInt8 {
        get {
        let __return = System_Buffers_StandardFormat_get_MaxPrecision();
            return __return;
        }
    }
    // static field: System.Byte NoPrecision
    /**
    Indicates that a format doesn't use a precision or that the precision is unspecified.

    */
    public class var NoPrecision : Swift.UInt8 {
        get {
        let __return = System_Buffers_StandardFormat_get_NoPrecision();
            return __return;
        }
    }
    /**
    Gets a value that indicates whether a format has a defined precision.

    */
    public var HasPrecision : Bool {
        get {
            return try! get_HasPrecision();
        }
    }
    /**
    Gets a value that indicates whether the current instance is a default format.

    */
    public var IsDefault : Bool {
        get {
            return try! get_IsDefault();
        }
    }
    /**
    Gets the precision component of the format.

    */
    public var Precision : Swift.UInt8 {
        get {
            return try! get_Precision();
        }
    }
    /**
    Gets the character component of the format.

    */
    public var Symbol : dotnet.System.Char {
        get {
            return try! get_Symbol();
        }
    }
    // .ctor(System.Char, System.Byte)
// docid: M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)
    /**
    Initializes a new instance of the  structure.

    - Parameter symbol: A type-specific format specifier, such as 'G', 'D', or 'X'.
    - Parameter precision: An optional precision ranging from 0 to 99, or the special value  (the default).
    */
    public init(symbol : dotnet.System.Char, precision : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Buffers_StandardFormat_ctor_0__2__Char_u8(&__thrown, symbol.get_value(), precision);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Buffers_StandardFormat_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Buffers.StandardFormat)
// docid: M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)
    /**
    Returns a value that indicates whether the specified  is equal to the current instance.

    - Parameter other: The format to compare to the current instance.
    - Returns: 
         if the two instances are equal; otherwise, .

    */
    public func Equals(other : dotnet.System.Buffers.StandardFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_bool__Equals_0__1__StandardFormat(&__thrown, self.get_handle(), other.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Buffers.StandardFormat.Equals(System.Object)
    /**
    Returns a value that indicates whether the specified object is a  object that is equal to the current instance.

    - Parameter obj: An object to compare to the current instance.
    - Returns: 
         if the two instances are equal; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Buffers.StandardFormat.GetHashCode
    /**
    Returns the hash code for this instance.

    - Returns: The hash code for this instance.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Buffers.StandardFormat, System.Buffers.StandardFormat)
// docid: M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)
    /**
    Returns a value that indicates whether two  instances are equal.

    - Parameter left: The first format to compare.
    - Parameter right: The second format to compare.
    - Returns: 
         if the two instances are equal; otherwise, .

    */
    public class func op_Equality(left : dotnet.System.Buffers.StandardFormat, right : dotnet.System.Buffers.StandardFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_bool__op_Equality_0__2__StandardFormat_StandardFormat(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func == (left : dotnet.System.Buffers.StandardFormat, right : dotnet.System.Buffers.StandardFormat) -> Bool
    {
        return try! op_Equality(left: left, right: right);
    }
    // [IsSpecialName] System.Buffers.StandardFormat op_Implicit(System.Char)
// docid: M:System.Buffers.StandardFormat.op_Implicit(System.Char)
    public class func op_Implicit(symbol : dotnet.System.Char) throws -> dotnet.System.Buffers.StandardFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_StandardFormat__op_Implicit_0__1__Char(&__thrown, symbol.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.StandardFormat(hndl : __return);
        }
    }
// TODO conversion to Self [IsSpecialName] System.Buffers.StandardFormat op_Implicit(System.Char)
    public convenience init(symbol : dotnet.System.Char) 
    {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_StandardFormat__op_Implicit_0__1__Char(&__thrown, symbol.get_value());
        assert(__thrown == nil);
            self.init(hndl: __return);
    }
    // [IsSpecialName] bool op_Inequality(System.Buffers.StandardFormat, System.Buffers.StandardFormat)
// docid: M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)
    /**
    Determines whether two  instances are unequal.

    - Parameter left: The first format to compare.
    - Parameter right: The second format to compare.
    - Returns: 
         if the two formats are unequal; otherwise, .

    */
    public class func op_Inequality(left : dotnet.System.Buffers.StandardFormat, right : dotnet.System.Buffers.StandardFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_bool__op_Inequality_0__2__StandardFormat_StandardFormat(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static func != (left : dotnet.System.Buffers.StandardFormat, right : dotnet.System.Buffers.StandardFormat) -> Bool
    {
        return try! op_Inequality(left: left, right: right);
    }
// TODO COPE (write_all_methods) (span) System.Buffers.StandardFormat Parse(System.ReadOnlySpan<System.Char>)
    // System.Buffers.StandardFormat Parse(System.String)
// docid: M:System.Buffers.StandardFormat.Parse(System.String)
    /**
    Converts a classic .NET standard format string to a  instance.

    - Parameter format: A classic .NET standard format string.
    - Returns: A format.

    */
    public class func Parse(format : Optional<dotnet.System.String>) throws -> dotnet.System.Buffers.StandardFormat {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_StandardFormat__Parse_0__1__String(&__thrown, format?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.StandardFormat(hndl : __return);
        }
    }
    // System.String ToString()
// docid: M:System.Buffers.StandardFormat.ToString
    /**
    Returns the string representation of this format.

    - Returns: The string representation of this format.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Char>, ref System.Buffers.StandardFormat)
    // [IsSpecialName] bool get_HasPrecision()
// docid: M:System.Buffers.StandardFormat.get_HasPrecision
    public func get_HasPrecision() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_bool__get_HasPrecision_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsDefault()
// docid: M:System.Buffers.StandardFormat.get_IsDefault
    public func get_IsDefault() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_bool__get_IsDefault_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Byte get_Precision()
// docid: M:System.Buffers.StandardFormat.get_Precision
    public func get_Precision() throws -> Swift.UInt8 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_u8__get_Precision_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Char get_Symbol()
// docid: M:System.Buffers.StandardFormat.get_Symbol
    public func get_Symbol() throws -> dotnet.System.Char {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_StandardFormat_Char__get_Symbol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Char(val: __return);
        }
    }
} // StandardFormat


}
// System.Buffers.Binary
extension System.Buffers.Binary {
// type: System.Buffers.Binary.BinaryPrimitives
public struct BinaryPrimitives {
// TODO COPE (write_all_methods) (span) System.Double ReadDoubleBigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Double ReadDoubleLittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Half ReadHalfBigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Half ReadHalfLittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int16 ReadInt16BigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int16 ReadInt16LittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 ReadInt32BigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 ReadInt32LittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int64 ReadInt64BigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int64 ReadInt64LittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Single ReadSingleBigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Single ReadSingleLittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.UInt16 ReadUInt16BigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.UInt16 ReadUInt16LittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.UInt32 ReadUInt32BigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.UInt32 ReadUInt32LittleEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.UInt64 ReadUInt64BigEndian(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.UInt64 ReadUInt64LittleEndian(System.ReadOnlySpan<System.Byte>)
    // System.Byte ReverseEndianness(System.Byte)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value, which effectively does nothing for a .

    - Parameter value: The value to reverse.
    - Returns: The passed-in value, unmodified.

    */
    public static func ReverseEndianness(value : Swift.UInt8) throws -> Swift.UInt8 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_u8__ReverseEndianness_0__1__u8(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int16 ReverseEndianness(System.Int16)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value.

    - Parameter value: The value to reverse.
    - Returns: The reversed value.

    */
    public static func ReverseEndianness(value : Swift.Int16) throws -> Swift.Int16 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_i16__ReverseEndianness_0__1__i16(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 ReverseEndianness(System.Int32)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value.

    - Parameter value: The value to reverse.
    - Returns: The reversed value.

    */
    public static func ReverseEndianness(value : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_i32__ReverseEndianness_0__1__i32(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 ReverseEndianness(System.Int64)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value.

    - Parameter value: The value to reverse.
    - Returns: The reversed value.

    */
    public static func ReverseEndianness(value : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_i64__ReverseEndianness_0__1__i64(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.SByte ReverseEndianness(System.SByte)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value, which effectively does nothing for an .

    - Parameter value: The value to reverse.
    - Returns: The passed-in value, unmodified.

    */
    public static func ReverseEndianness(value : Swift.Int8) throws -> Swift.Int8 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_i8__ReverseEndianness_0__1__i8(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt16 ReverseEndianness(System.UInt16)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value.

    - Parameter value: The value to reverse.
    - Returns: The reversed value.

    */
    public static func ReverseEndianness(value : Swift.UInt16) throws -> Swift.UInt16 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_u16__ReverseEndianness_0__1__u16(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 ReverseEndianness(System.UInt32)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value.

    - Parameter value: The value to reverse.
    - Returns: The reversed value.

    */
    public static func ReverseEndianness(value : Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_u32__ReverseEndianness_0__1__u32(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 ReverseEndianness(System.UInt64)
// docid: M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)
    /**
    Reverses a primitive value by performing an endianness swap of the specified  value.

    - Parameter value: The value to reverse.
    - Returns: The reversed value.

    */
    public static func ReverseEndianness(value : Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Binary_BinaryPrimitives_u64__ReverseEndianness_0__1__u64(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryReadDoubleBigEndian(System.ReadOnlySpan<System.Byte>, ref System.Double)
// TODO COPE (write_all_methods) (span) bool TryReadDoubleLittleEndian(System.ReadOnlySpan<System.Byte>, ref System.Double)
// TODO COPE (write_all_methods) (span) bool TryReadHalfBigEndian(System.ReadOnlySpan<System.Byte>, ref System.Half)
// TODO COPE (write_all_methods) (span) bool TryReadHalfLittleEndian(System.ReadOnlySpan<System.Byte>, ref System.Half)
// TODO COPE (write_all_methods) (span) bool TryReadInt16BigEndian(System.ReadOnlySpan<System.Byte>, ref System.Int16)
// TODO COPE (write_all_methods) (span) bool TryReadInt16LittleEndian(System.ReadOnlySpan<System.Byte>, ref System.Int16)
// TODO COPE (write_all_methods) (span) bool TryReadInt32BigEndian(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryReadInt32LittleEndian(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryReadInt64BigEndian(System.ReadOnlySpan<System.Byte>, ref System.Int64)
// TODO COPE (write_all_methods) (span) bool TryReadInt64LittleEndian(System.ReadOnlySpan<System.Byte>, ref System.Int64)
// TODO COPE (write_all_methods) (span) bool TryReadSingleBigEndian(System.ReadOnlySpan<System.Byte>, ref System.Single)
// TODO COPE (write_all_methods) (span) bool TryReadSingleLittleEndian(System.ReadOnlySpan<System.Byte>, ref System.Single)
// TODO COPE (write_all_methods) (span) bool TryReadUInt16BigEndian(System.ReadOnlySpan<System.Byte>, ref System.UInt16)
// TODO COPE (write_all_methods) (span) bool TryReadUInt16LittleEndian(System.ReadOnlySpan<System.Byte>, ref System.UInt16)
// TODO COPE (write_all_methods) (span) bool TryReadUInt32BigEndian(System.ReadOnlySpan<System.Byte>, ref System.UInt32)
// TODO COPE (write_all_methods) (span) bool TryReadUInt32LittleEndian(System.ReadOnlySpan<System.Byte>, ref System.UInt32)
// TODO COPE (write_all_methods) (span) bool TryReadUInt64BigEndian(System.ReadOnlySpan<System.Byte>, ref System.UInt64)
// TODO COPE (write_all_methods) (span) bool TryReadUInt64LittleEndian(System.ReadOnlySpan<System.Byte>, ref System.UInt64)
// TODO COPE (write_all_methods) (span) bool TryWriteDoubleBigEndian(System.Span<System.Byte>, System.Double)
// TODO COPE (write_all_methods) (span) bool TryWriteDoubleLittleEndian(System.Span<System.Byte>, System.Double)
// TODO COPE (write_all_methods) (span) bool TryWriteHalfBigEndian(System.Span<System.Byte>, System.Half)
// TODO COPE (write_all_methods) (span) bool TryWriteHalfLittleEndian(System.Span<System.Byte>, System.Half)
// TODO COPE (write_all_methods) (span) bool TryWriteInt16BigEndian(System.Span<System.Byte>, System.Int16)
// TODO COPE (write_all_methods) (span) bool TryWriteInt16LittleEndian(System.Span<System.Byte>, System.Int16)
// TODO COPE (write_all_methods) (span) bool TryWriteInt32BigEndian(System.Span<System.Byte>, System.Int32)
// TODO COPE (write_all_methods) (span) bool TryWriteInt32LittleEndian(System.Span<System.Byte>, System.Int32)
// TODO COPE (write_all_methods) (span) bool TryWriteInt64BigEndian(System.Span<System.Byte>, System.Int64)
// TODO COPE (write_all_methods) (span) bool TryWriteInt64LittleEndian(System.Span<System.Byte>, System.Int64)
// TODO COPE (write_all_methods) (span) bool TryWriteSingleBigEndian(System.Span<System.Byte>, System.Single)
// TODO COPE (write_all_methods) (span) bool TryWriteSingleLittleEndian(System.Span<System.Byte>, System.Single)
// TODO COPE (write_all_methods) (span) bool TryWriteUInt16BigEndian(System.Span<System.Byte>, System.UInt16)
// TODO COPE (write_all_methods) (span) bool TryWriteUInt16LittleEndian(System.Span<System.Byte>, System.UInt16)
// TODO COPE (write_all_methods) (span) bool TryWriteUInt32BigEndian(System.Span<System.Byte>, System.UInt32)
// TODO COPE (write_all_methods) (span) bool TryWriteUInt32LittleEndian(System.Span<System.Byte>, System.UInt32)
// TODO COPE (write_all_methods) (span) bool TryWriteUInt64BigEndian(System.Span<System.Byte>, System.UInt64)
// TODO COPE (write_all_methods) (span) bool TryWriteUInt64LittleEndian(System.Span<System.Byte>, System.UInt64)
// TODO COPE (write_all_methods) (span) void WriteDoubleBigEndian(System.Span<System.Byte>, System.Double)
// TODO COPE (write_all_methods) (span) void WriteDoubleLittleEndian(System.Span<System.Byte>, System.Double)
// TODO COPE (write_all_methods) (span) void WriteHalfBigEndian(System.Span<System.Byte>, System.Half)
// TODO COPE (write_all_methods) (span) void WriteHalfLittleEndian(System.Span<System.Byte>, System.Half)
// TODO COPE (write_all_methods) (span) void WriteInt16BigEndian(System.Span<System.Byte>, System.Int16)
// TODO COPE (write_all_methods) (span) void WriteInt16LittleEndian(System.Span<System.Byte>, System.Int16)
// TODO COPE (write_all_methods) (span) void WriteInt32BigEndian(System.Span<System.Byte>, System.Int32)
// TODO COPE (write_all_methods) (span) void WriteInt32LittleEndian(System.Span<System.Byte>, System.Int32)
// TODO COPE (write_all_methods) (span) void WriteInt64BigEndian(System.Span<System.Byte>, System.Int64)
// TODO COPE (write_all_methods) (span) void WriteInt64LittleEndian(System.Span<System.Byte>, System.Int64)
// TODO COPE (write_all_methods) (span) void WriteSingleBigEndian(System.Span<System.Byte>, System.Single)
// TODO COPE (write_all_methods) (span) void WriteSingleLittleEndian(System.Span<System.Byte>, System.Single)
// TODO COPE (write_all_methods) (span) void WriteUInt16BigEndian(System.Span<System.Byte>, System.UInt16)
// TODO COPE (write_all_methods) (span) void WriteUInt16LittleEndian(System.Span<System.Byte>, System.UInt16)
// TODO COPE (write_all_methods) (span) void WriteUInt32BigEndian(System.Span<System.Byte>, System.UInt32)
// TODO COPE (write_all_methods) (span) void WriteUInt32LittleEndian(System.Span<System.Byte>, System.UInt32)
// TODO COPE (write_all_methods) (span) void WriteUInt64BigEndian(System.Span<System.Byte>, System.UInt64)
// TODO COPE (write_all_methods) (span) void WriteUInt64LittleEndian(System.Span<System.Byte>, System.UInt64)
} // BinaryPrimitives


}

// System.Buffers.Text
extension System.Buffers.Text {
// type: System.Buffers.Text.Base64
public struct Base64 {
// TODO COPE (write_all_methods) (span) System.Buffers.OperationStatus DecodeFromUtf8(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32, ref System.Int32, bool)
// TODO COPE (write_all_methods) (span) System.Buffers.OperationStatus DecodeFromUtf8InPlace(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) System.Buffers.OperationStatus EncodeToUtf8(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32, ref System.Int32, bool)
// TODO COPE (write_all_methods) (span) System.Buffers.OperationStatus EncodeToUtf8InPlace(System.Span<System.Byte>, System.Int32, ref System.Int32)
    // System.Int32 GetMaxDecodedFromUtf8Length(System.Int32)
// docid: M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)
    /**
    Returns the maximum length (in bytes) of the result if you were to decode base-64 encoded text within a byte span with the specified length.

    - Parameter length: The size of the byte span.
    - Returns: The maximum length (in bytes) of the result.

    */
    public static func GetMaxDecodedFromUtf8Length(length : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Text_Base64_i32__GetMaxDecodedFromUtf8Length_0__1__i32(&__thrown, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetMaxEncodedToUtf8Length(System.Int32)
// docid: M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)
    /**
    Returns the maximum length (in bytes) of the result if you were to encode binary data within a byte span with the specified length.

    - Parameter length: The size of the byte span.
    - Returns: The maximum length (in bytes) of the result.

    */
    public static func GetMaxEncodedToUtf8Length(length : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Buffers_Text_Base64_i32__GetMaxEncodedToUtf8Length_0__1__i32(&__thrown, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // Base64


// type: System.Buffers.Text.Utf8Formatter
public struct Utf8Formatter {
// TODO COPE (write_all_methods) (span) bool TryFormat(bool, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Byte, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.DateTime, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.DateTimeOffset, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Decimal, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Double, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Guid, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Int16, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Int32, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Int64, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.SByte, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Single, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.TimeSpan, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.UInt16, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.UInt32, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
// TODO COPE (write_all_methods) (span) bool TryFormat(System.UInt64, System.Span<System.Byte>, ref System.Int32, System.Buffers.StandardFormat)
} // Utf8Formatter


// type: System.Buffers.Text.Utf8Parser
public struct Utf8Parser {
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref bool, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Byte, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.DateTime, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.DateTimeOffset, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Decimal, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Double, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Guid, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Int16, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Int32, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Int64, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.SByte, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.Single, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.TimeSpan, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.UInt16, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.UInt32, ref System.Int32, System.Char)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Byte>, ref System.UInt64, ref System.Int32, System.Char)
} // Utf8Parser


}


// System.Runtime
// System.Runtime.InteropServices
extension System.Runtime.InteropServices {
// type: System.Runtime.InteropServices.MemoryMarshal
public struct MemoryMarshal {
// TODO COPE (parm span of t): System.ReadOnlySpan<System.Byte> AsBytes<T>(System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Span<System.Byte> AsBytes<T>(System.Span<T>)
    // System.Memory<T> AsMemory<T>(System.ReadOnlyMemory<T>)
// docid: M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})
    /**
    Creates a  instance from a .

    - Parameter memory: The read-only memory buffer.
    - Returns: A memory block that represents the same memory as the .

    */
    public static func AsMemory<UT : SGBridgeGenericValue>(memory : dotnet.System.ReadOnlyMemory_1<UT>) throws -> dotnet.System.Memory_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_InteropServices_MemoryMarshal_System_Memory_UT___AsMemory_1__1__System_ReadOnlyMemory_UT_(UT.get_type_handle(), &__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (returns_byref): ref T AsRef<T>(System.ReadOnlySpan<System.Byte>)
// TODO COPE (returns_byref): ref T AsRef<T>(System.Span<System.Byte>)
// TODO COPE (parm span of t): System.ReadOnlySpan<TTo> Cast<TFrom, TTo>(System.ReadOnlySpan<TFrom>)
// TODO COPE (parm span of t): System.Span<TTo> Cast<TFrom, TTo>(System.Span<TFrom>)
// TODO COPE (write_all_methods) (unused generic param) System.Memory<T> CreateFromPinnedArray<T>(T[], System.Int32, System.Int32)
// TODO COPE (returns byreflike): System.ReadOnlySpan<T> CreateReadOnlySpan<T>(ref T, System.Int32)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Byte> CreateReadOnlySpanFromNullTerminated(System.Byte*)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> CreateReadOnlySpanFromNullTerminated(System.Char*)
// TODO COPE (returns byreflike): System.Span<T> CreateSpan<T>(ref T, System.Int32)
// TODO COPE (returns_byref): ref T GetArrayDataReference<T>(T[])
// TODO COPE (returns_byref): ref System.Byte GetArrayDataReference(System.Array)
// TODO COPE (returns_byref): ref T GetReference<T>(System.ReadOnlySpan<T>)
// TODO COPE (returns_byref): ref T GetReference<T>(System.Span<T>)
// TODO COPE (generic method and parm span): T Read<T>(System.ReadOnlySpan<System.Byte>)
    // System.Collections.Generic.IEnumerable<T> ToEnumerable<T>(System.ReadOnlyMemory<T>)
// docid: M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})
    /**
    Creates an  view of the given read-only memory buffer.

    - Parameter memory: A read-only memory buffer.
    - Returns: An enumerable view of .

    */
    public static func ToEnumerable<UT : SGBridgeGenericValue>(memory : dotnet.System.ReadOnlyMemory_1<UT>) throws -> dotnet.System.Collections.Generic.IEnumerable_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_InteropServices_MemoryMarshal_System_Collections_Generic_IEnumerable_UT___ToEnumerable_1__1__System_ReadOnlyMemory_UT_(UT.get_type_handle(), &__thrown, memory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
    // bool TryGetArray<T>(System.ReadOnlyMemory<T>, ref System.ArraySegment<T>)
// docid: M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)
    /**
    Tries to get an array segment from the underlying memory buffer. The return value indicates the success of the operation.

    - Parameter memory: A read-only memory buffer.
    - Parameter segment: When this method returns, contains the array segment retrieved from the underlying read-only memory buffer. If the method fails, the method returns a default array segment.
    - Returns: 
         if the method call succeeds;  otherwise.

    */
    public static func TryGetArray<UT : SGBridgeGenericValue>(memory : dotnet.System.ReadOnlyMemory_1<UT>, segment : inout Optional<dotnet.System.ArraySegment_1<UT>>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_segment = (segment != nil) ? (segment!.get_handle()) : nil;
        let __return = System_Runtime_InteropServices_MemoryMarshal_bool__TryGetArray_1__2__System_ReadOnlyMemory_UT__outSystem_ArraySegment_UT_(UT.get_type_handle(), &__thrown, memory.get_handle(), &_tmp_out_segment);
        let __h__tmp2_segment = _tmp_out_segment;
        let _tmp2_segment = (__h__tmp2_segment != nil) ? dotnet.System.ArraySegment_1<UT>(hndl: __h__tmp2_segment!) : nil;
            segment = _tmp2_segment;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) bool TryGetMemoryManager<T, TManager>(System.ReadOnlyMemory<T>, ref TManager)
// TODO COPE (write_all_methods) (unused generic param) bool TryGetMemoryManager<T, TManager>(System.ReadOnlyMemory<T>, ref TManager, ref System.Int32, ref System.Int32)
    // bool TryGetString(System.ReadOnlyMemory<System.Char>, ref System.String, ref System.Int32, ref System.Int32)
// docid: M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)
    /**
    Tries to get the underlying string from a .

    - Parameter memory: Read-only memory containing a block of characters.
    - Parameter text: When the method returns, the string contained in the memory buffer.
    - Parameter start: The starting location in .
    - Parameter length: The number of characters in .
    - Returns: 
         if the method successfully retrieves the underlying string; otherwise, .

    */
    public static func TryGetString(memory : dotnet.System.ReadOnlyMemory_1<dotnet.System.Char>, text : inout Optional<dotnet.System.String>, start : inout Swift.Int32, length : inout Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_text = (text != nil) ? (text!.get_handle()) : nil;
            var _tmp_out_start = start;
            var _tmp_out_length = length;
        let __return = System_Runtime_InteropServices_MemoryMarshal_bool__TryGetString_0__4__System_ReadOnlyMemory_System_Char__outString_outi32_outi32(&__thrown, memory.get_handle(), &_tmp_out_text, &_tmp_out_start, &_tmp_out_length);
        let __h__tmp2_text = _tmp_out_text;
        let _tmp2_text = (__h__tmp2_text != nil) ? dotnet.System.String(hndl: __h__tmp2_text!) : nil;
            text = _tmp2_text;
        let _tmp2_start = _tmp_out_start;
            start = _tmp2_start;
        let _tmp2_length = _tmp_out_length;
            length = _tmp2_length;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (generic method and parm span): bool TryRead<T>(System.ReadOnlySpan<System.Byte>, ref T)
// TODO COPE (generic method and parm span): bool TryWrite<T>(System.Span<System.Byte>, ref T)
// TODO COPE (generic method and parm span): void Write<T>(System.Span<System.Byte>, ref T)
} // MemoryMarshal


// type: System.Runtime.InteropServices.SequenceMarshal
public struct SequenceMarshal {
    // bool TryGetArray<T>(System.Buffers.ReadOnlySequence<T>, ref System.ArraySegment<T>)
// docid: M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)
    /**
    Gets an array segment from the underlying read-only sequence.

    - Parameter sequence: The read-only sequence from which the array segment will be retrieved.
    - Parameter segment: The returned array segment.
    - Returns: 
         if it's possible to retrieve the array segment; otherwise,  and a default array segment is returned.

    */
    public static func TryGetArray<UT : SGBridgeGenericValue>(sequence : dotnet.System.Buffers.ReadOnlySequence_1<UT>, segment : inout Optional<dotnet.System.ArraySegment_1<UT>>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_segment = (segment != nil) ? (segment!.get_handle()) : nil;
        let __return = System_Runtime_InteropServices_SequenceMarshal_bool__TryGetArray_1__2__System_Buffers_ReadOnlySequence_UT__outSystem_ArraySegment_UT_(UT.get_type_handle(), &__thrown, sequence.get_handle(), &_tmp_out_segment);
        let __h__tmp2_segment = _tmp_out_segment;
        let _tmp2_segment = (__h__tmp2_segment != nil) ? dotnet.System.ArraySegment_1<UT>(hndl: __h__tmp2_segment!) : nil;
            segment = _tmp2_segment;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryGetReadOnlyMemory<T>(System.Buffers.ReadOnlySequence<T>, ref System.ReadOnlyMemory<T>)
// docid: M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)
    /**
    Attempts to retrieve a read-only memory from the specified read-only sequence.

    - Parameter sequence: The read-only sequence from which the memory will be retrieved.
    - Parameter memory: The returned read-only memory of type T.
    - Returns: 
         if the read-only memory can be retrieved; otherwise, .

    */
    public static func TryGetReadOnlyMemory<UT : SGBridgeGenericValue>(sequence : dotnet.System.Buffers.ReadOnlySequence_1<UT>, memory : inout Optional<dotnet.System.ReadOnlyMemory_1<UT>>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_memory = (memory != nil) ? (memory!.get_handle()) : nil;
        let __return = System_Runtime_InteropServices_SequenceMarshal_bool__TryGetReadOnlyMemory_1__2__System_Buffers_ReadOnlySequence_UT__outSystem_ReadOnlyMemory_UT_(UT.get_type_handle(), &__thrown, sequence.get_handle(), &_tmp_out_memory);
        let __h__tmp2_memory = _tmp_out_memory;
        let _tmp2_memory = (__h__tmp2_memory != nil) ? dotnet.System.ReadOnlyMemory_1<UT>(hndl: __h__tmp2_memory!) : nil;
            memory = _tmp2_memory;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryGetReadOnlySequenceSegment<T>(System.Buffers.ReadOnlySequence<T>, ref System.Buffers.ReadOnlySequenceSegment<T>, ref System.Int32, ref System.Buffers.ReadOnlySequenceSegment<T>, ref System.Int32)
// docid: M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)
    /**
    Attempts to retrieve a read-only sequence segment from the specified read-only sequence.

    - Parameter sequence: The read-only sequence from which the read-only sequence segment will be retrieved.
    - Parameter startSegment: The beginning read-only sequence segment.
    - Parameter startIndex: The initial position.
    - Parameter endSegment: The ending read-only sequence segment.
    - Parameter endIndex: The final position.
    - Returns: 
         if the read-only sequence segment can be retrieved; otherwise, .

    */
    public static func TryGetReadOnlySequenceSegment<UT : SGBridgeGenericValue>(sequence : dotnet.System.Buffers.ReadOnlySequence_1<UT>, startSegment : inout Optional<dotnet.System.Buffers.ReadOnlySequenceSegment_1<UT>>, startIndex : inout Swift.Int32, endSegment : inout Optional<dotnet.System.Buffers.ReadOnlySequenceSegment_1<UT>>, endIndex : inout Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_startSegment = (startSegment != nil) ? (startSegment!.get_handle()) : nil;
            var _tmp_out_startIndex = startIndex;
            var _tmp_out_endSegment = (endSegment != nil) ? (endSegment!.get_handle()) : nil;
            var _tmp_out_endIndex = endIndex;
        let __return = System_Runtime_InteropServices_SequenceMarshal_bool__TryGetReadOnlySequenceSegment_1__5__System_Buffers_ReadOnlySequence_UT__outSystem_Buffers_ReadOnlySequenceSegment_UT__outi32_outSystem_Buffers_ReadOnlySequenceSegment_UT__outi32(UT.get_type_handle(), &__thrown, sequence.get_handle(), &_tmp_out_startSegment, &_tmp_out_startIndex, &_tmp_out_endSegment, &_tmp_out_endIndex);
        let __h__tmp2_startSegment = _tmp_out_startSegment;
        let _tmp2_startSegment = (__h__tmp2_startSegment != nil) ? dotnet.System.Buffers.ReadOnlySequenceSegment_1<UT>(hndl: __h__tmp2_startSegment!) : nil;
            startSegment = _tmp2_startSegment;
        let _tmp2_startIndex = _tmp_out_startIndex;
            startIndex = _tmp2_startIndex;
        let __h__tmp2_endSegment = _tmp_out_endSegment;
        let _tmp2_endSegment = (__h__tmp2_endSegment != nil) ? dotnet.System.Buffers.ReadOnlySequenceSegment_1<UT>(hndl: __h__tmp2_endSegment!) : nil;
            endSegment = _tmp2_endSegment;
        let _tmp2_endIndex = _tmp_out_endIndex;
            endIndex = _tmp2_endIndex;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (parm byref span): bool TryRead<T>(ref System.Buffers.SequenceReader<System.Byte>, ref T)
} // SequenceMarshal


}


// System.Text
extension System.Text {
// type: System.Text.EncodingExtensions
public struct EncodingExtensions {
    // void Convert(System.Text.Decoder, ref System.Buffers.ReadOnlySequence<System.Byte>, System.Buffers.IBufferWriter<System.Char>, bool, ref System.Int64, ref bool)
// docid: M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)
    /**
    Converts a  to UTF-16 encoded characters and writes the result to .

    - Parameter decoder: The decoder instance that can convert bytes to  values.
    - Parameter bytes: A sequence of bytes to decode.
    - Parameter writer: The buffer to which the decoded characters will be written.
    - Parameter flush: 
         to indicate no further data is to be converted; otherwise .
    - Parameter charsUsed: When this method returns, contains the count of characters that were written to .
    - Parameter completed: When this method returns, contains  if  contains no partial internal state; otherwise, .
 If  is , this will always be set to  when the method returns.
    */
    public static func Convert(decoder : dotnet.System.Text.Decoder, bytes : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>, writer : dotnet.System.Buffers.IBufferWriter_1<dotnet.System.Char>, flush : Bool, charsUsed : inout Swift.Int64, completed : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_in_bytes = (bytes != nil) ? (bytes!.get_handle()) : nil;
            var _tmp_out_charsUsed = charsUsed;
            var _tmp_out_completed = Swift.Int32(completed ? 1 : 0);
        System_Text_EncodingExtensions_void__Convert_0__6__Decoder_inSystem_Buffers_ReadOnlySequence_u8__System_Buffers_IBufferWriter_System_Char__bool_outi64_outbool(&__thrown, decoder.get_handle(), &_tmp_in_bytes, writer.get_handle(), Swift.Int32(flush ? 1 : 0), &_tmp_out_charsUsed, &_tmp_out_completed);
        let _tmp2_charsUsed = _tmp_out_charsUsed;
            charsUsed = _tmp2_charsUsed;
        let _tmp2_completed = (_tmp_out_completed) != 0;
            completed = _tmp2_completed;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Convert(System.Text.Decoder, System.ReadOnlySpan<System.Byte>, System.Buffers.IBufferWriter<System.Char>, bool, ref System.Int64, ref bool)
    // void Convert(System.Text.Encoder, ref System.Buffers.ReadOnlySequence<System.Char>, System.Buffers.IBufferWriter<System.Byte>, bool, ref System.Int64, ref bool)
// docid: M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)
    /**
    Converts a  to encoded bytes and writes the result to .

    - Parameter encoder: The encoder instance that can convert  values to bytes.
    - Parameter chars: A sequence of characters to encode.
    - Parameter writer: The buffer to which the encoded bytes will be written.
    - Parameter flush: 
         to indicate no further data is to be converted; otherwise .
    - Parameter bytesUsed: When this method returns, contains the count of s which were written to .
    - Parameter completed: When this method returns, contains  if all input up until  was converted; otherwise, . If  is , this will always be set to  when the method returns.
    */
    public static func Convert(encoder : dotnet.System.Text.Encoder, chars : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<dotnet.System.Char>>, writer : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>, flush : Bool, bytesUsed : inout Swift.Int64, completed : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_in_chars = (chars != nil) ? (chars!.get_handle()) : nil;
            var _tmp_out_bytesUsed = bytesUsed;
            var _tmp_out_completed = Swift.Int32(completed ? 1 : 0);
        System_Text_EncodingExtensions_void__Convert_0__6__Encoder_inSystem_Buffers_ReadOnlySequence_System_Char__System_Buffers_IBufferWriter_u8__bool_outi64_outbool(&__thrown, encoder.get_handle(), &_tmp_in_chars, writer.get_handle(), Swift.Int32(flush ? 1 : 0), &_tmp_out_bytesUsed, &_tmp_out_completed);
        let _tmp2_bytesUsed = _tmp_out_bytesUsed;
            bytesUsed = _tmp2_bytesUsed;
        let _tmp2_completed = (_tmp_out_completed) != 0;
            completed = _tmp2_completed;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Convert(System.Text.Encoder, System.ReadOnlySpan<System.Char>, System.Buffers.IBufferWriter<System.Byte>, bool, ref System.Int64, ref bool)
    // System.Byte[] GetBytes(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Char>)
// docid: M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)
    /**
    Encodes the specified  into a  array using the specified .

    - Parameter encoding: The encoding that represents how the data in  should be encoded.
    - Parameter chars: The sequence to encode to bytes.
    - Returns: A  array that represents the encoded contents of .

    */
    public static func GetBytes(encoding : dotnet.System.Text.Encoding, chars : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<dotnet.System.Char>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
            var _tmp_in_chars = (chars != nil) ? (chars!.get_handle()) : nil;
        let __return = System_Text_EncodingExtensions_u8Array__GetBytes_0__2__Encoding_inSystem_Buffers_ReadOnlySequence_System_Char_(&__thrown, encoding.get_handle(), &_tmp_in_chars);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Int64 GetBytes(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Char>, System.Buffers.IBufferWriter<System.Byte>)
// docid: M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})
    /**
    Decodes the specified  to s using the specified  and writes the result to .

    - Parameter encoding: The encoding that represents how the data in  should be encoded.
    - Parameter chars: The  whose contents should be encoded.
    - Parameter writer: The buffer to which the encoded bytes will be written.
    - Returns: The number of bytes written to .

    */
    public static func GetBytes(encoding : dotnet.System.Text.Encoding, chars : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<dotnet.System.Char>>, writer : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_in_chars = (chars != nil) ? (chars!.get_handle()) : nil;
        let __return = System_Text_EncodingExtensions_i64__GetBytes_0__3__Encoding_inSystem_Buffers_ReadOnlySequence_System_Char__System_Buffers_IBufferWriter_u8_(&__thrown, encoding.get_handle(), &_tmp_in_chars, writer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 GetBytes(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Char>, System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int64 GetBytes(System.Text.Encoding, System.ReadOnlySpan<System.Char>, System.Buffers.IBufferWriter<System.Byte>)
    // System.Int64 GetChars(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Byte>, System.Buffers.IBufferWriter<System.Char>)
// docid: M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})
    /**
    Decodes the specified  to s using the specified  and writes the result to .

    - Parameter encoding: The encoding that represents how the data in  should be decoded.
    - Parameter bytes: The sequence whose bytes should be decoded.
    - Parameter writer: The buffer to which the decoded chars will be written.
    - Returns: The number of chars written to .

    */
    public static func GetChars(encoding : dotnet.System.Text.Encoding, bytes : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>, writer : dotnet.System.Buffers.IBufferWriter_1<dotnet.System.Char>) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_in_bytes = (bytes != nil) ? (bytes!.get_handle()) : nil;
        let __return = System_Text_EncodingExtensions_i64__GetChars_0__3__Encoding_inSystem_Buffers_ReadOnlySequence_u8__System_Buffers_IBufferWriter_System_Char_(&__thrown, encoding.get_handle(), &_tmp_in_bytes, writer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 GetChars(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Byte>, System.Span<System.Char>)
// TODO COPE (write_all_methods) (span) System.Int64 GetChars(System.Text.Encoding, System.ReadOnlySpan<System.Byte>, System.Buffers.IBufferWriter<System.Char>)
    // System.String GetString(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Byte>)
// docid: M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)
    /**
    Decodes the specified  into a  using the specified .

    - Parameter encoding: The encoding that represents how the data in  is encoded.
    - Parameter bytes: The sequence to decode into characters.
    - Returns: A  which represents the decoded contents of .

    */
    public static func GetString(encoding : dotnet.System.Text.Encoding, bytes : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
            var _tmp_in_bytes = (bytes != nil) ? (bytes!.get_handle()) : nil;
        let __return = System_Text_EncodingExtensions_String__GetString_0__2__Encoding_inSystem_Buffers_ReadOnlySequence_u8_(&__thrown, encoding.get_handle(), &_tmp_in_bytes);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // EncodingExtensions


}


public protocol System_Buffers_IBufferWriter_1
    :
    SGBridgeGetHandle
{
    associatedtype T_IBufferWriter_1 : SGBridgeGenericValue;
}

// TODO COPE (parm span of t): void CopyTo<T>(ref System.Buffers.ReadOnlySequence<T>, System.Span<T>)
// EXTENSION METHOD System.Nullable<System.SequencePosition> PositionOf<T>(ref System.Buffers.ReadOnlySequence<T>, T)
// TODO COPE extension method on byref type

// EXTENSION METHOD T[] ToArray<T>(ref System.Buffers.ReadOnlySequence<T>)
// TODO COPE extension method (unused generic param) T[] ToArray<T>(ref System.Buffers.ReadOnlySequence<T>)

// TODO COPE (parm span of t): void Write<T>(System.Buffers.IBufferWriter<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm byref span): bool TryReadBigEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int16)
// TODO COPE (parm byref span): bool TryReadBigEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int32)
// TODO COPE (parm byref span): bool TryReadBigEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int64)
// TODO COPE (parm byref span): bool TryReadLittleEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int16)
// TODO COPE (parm byref span): bool TryReadLittleEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int32)
// TODO COPE (parm byref span): bool TryReadLittleEndian(ref System.Buffers.SequenceReader<System.Byte>, ref System.Int64)
// EXTENSION METHOD System.ReadOnlyMemory<System.Char> AsMemory(System.String)
extension dotnet.System.String {
    public func AsMemory() throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        return try dotnet.System.MemoryExtensions.AsMemory(text: self);
    }
}

// EXTENSION METHOD System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Index)
extension dotnet.System.String {
    public func AsMemory(startIndex : dotnet.System.Index) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        return try dotnet.System.MemoryExtensions.AsMemory(text: self, startIndex: startIndex);
    }
}

// EXTENSION METHOD System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Int32)
extension dotnet.System.String {
    public func AsMemory(start : Swift.Int32) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        return try dotnet.System.MemoryExtensions.AsMemory(text: self, start: start);
    }
}

// EXTENSION METHOD System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Int32, System.Int32)
extension dotnet.System.String {
    public func AsMemory(start : Swift.Int32, length : Swift.Int32) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        return try dotnet.System.MemoryExtensions.AsMemory(text: self, start: start, length: length);
    }
}

// EXTENSION METHOD System.ReadOnlyMemory<System.Char> AsMemory(System.String, System.Range)
extension dotnet.System.String {
    public func AsMemory(range : dotnet.System.Range) throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> {
        return try dotnet.System.MemoryExtensions.AsMemory(text: self, range: range);
    }
}

// EXTENSION METHOD System.Memory<T> AsMemory<T>(System.ArraySegment<T>)
extension dotnet.System.ArraySegment_1 {
    public func AsMemory() throws -> dotnet.System.Memory_1<T> {
        return try dotnet.System.MemoryExtensions.AsMemory(segment: self);
    }
}

// EXTENSION METHOD System.Memory<T> AsMemory<T>(System.ArraySegment<T>, System.Int32)
extension dotnet.System.ArraySegment_1 {
    public func AsMemory(start : Swift.Int32) throws -> dotnet.System.Memory_1<T> {
        return try dotnet.System.MemoryExtensions.AsMemory(segment: self, start: start);
    }
}

// EXTENSION METHOD System.Memory<T> AsMemory<T>(System.ArraySegment<T>, System.Int32, System.Int32)
extension dotnet.System.ArraySegment_1 {
    public func AsMemory(start : Swift.Int32, length : Swift.Int32) throws -> dotnet.System.Memory_1<T> {
        return try dotnet.System.MemoryExtensions.AsMemory(segment: self, start: start, length: length);
    }
}

// EXTENSION METHOD System.Memory<T> AsMemory<T>(T[])
// TODO COPE extension method (unused generic param) System.Memory<T> AsMemory<T>(T[])

// EXTENSION METHOD System.Memory<T> AsMemory<T>(T[], System.Index)
// TODO COPE extension method (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Index)

// EXTENSION METHOD System.Memory<T> AsMemory<T>(T[], System.Int32)
// TODO COPE extension method (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Int32)

// EXTENSION METHOD System.Memory<T> AsMemory<T>(T[], System.Int32, System.Int32)
// TODO COPE extension method (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Int32, System.Int32)

// EXTENSION METHOD System.Memory<T> AsMemory<T>(T[], System.Range)
// TODO COPE extension method (unused generic param) System.Memory<T> AsMemory<T>(T[], System.Range)

// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> AsSpan(System.String)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> AsSpan(System.String, System.Int32)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> AsSpan(System.String, System.Int32, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Index)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Int32, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(System.ArraySegment<T>, System.Range)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[])
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Index)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Int32, System.Int32)
// TODO COPE (returns byreflike): System.Span<T> AsSpan<T>(T[], System.Range)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T>(System.ReadOnlySpan<T>, System.IComparable<T>)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T>(System.Span<T>, System.IComparable<T>)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparer>(System.ReadOnlySpan<T>, T, TComparer)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparable>(System.ReadOnlySpan<T>, TComparable)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparer>(System.Span<T>, T, TComparer)
// TODO COPE (parm span of t): System.Int32 BinarySearch<T, TComparable>(System.Span<T>, TComparable)
// EXTENSION METHOD System.Int32 CompareTo(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE extension method (span) System.Int32 CompareTo(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)

// EXTENSION METHOD bool Contains(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE extension method (span) bool Contains(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)

// TODO COPE (parm span of t): bool Contains<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): bool Contains<T>(System.Span<T>, T)
// EXTENSION METHOD void CopyTo<T>(T[], System.Memory<T>)
// TODO COPE extension method on array type

// TODO COPE (parm span of t): void CopyTo<T>(T[], System.Span<T>)
// EXTENSION METHOD bool EndsWith(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE extension method (span) bool EndsWith(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)

// TODO COPE (parm span of t): bool EndsWith<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool EndsWith<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (returns byreflike): System.Text.SpanLineEnumerator EnumerateLines(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Text.SpanLineEnumerator EnumerateLines(System.Span<System.Char>)
// TODO COPE (returns byreflike): System.Text.SpanRuneEnumerator EnumerateRunes(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Text.SpanRuneEnumerator EnumerateRunes(System.Span<System.Char>)
// EXTENSION METHOD bool Equals(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE extension method (span) bool Equals(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)

// EXTENSION METHOD System.Int32 IndexOf(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE extension method (span) System.Int32 IndexOf(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)

// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.ReadOnlySpan<T>, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.ReadOnlySpan<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.Span<T>, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOfAny<T>(System.Span<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 IndexOf<T>(System.Span<T>, T)
// EXTENSION METHOD bool IsWhiteSpace(System.ReadOnlySpan<System.Char>)
// TODO COPE extension method (span) bool IsWhiteSpace(System.ReadOnlySpan<System.Char>)

// EXTENSION METHOD System.Int32 LastIndexOf(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE extension method (span) System.Int32 LastIndexOf(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)

// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.ReadOnlySpan<T>, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.ReadOnlySpan<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.Span<T>, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOfAny<T>(System.Span<T>, T, T, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 LastIndexOf<T>(System.Span<T>, T)
// TODO COPE (parm span of t): bool Overlaps<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool Overlaps<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>, ref System.Int32)
// TODO COPE (parm span of t): bool Overlaps<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool Overlaps<T>(System.Span<T>, System.ReadOnlySpan<T>, ref System.Int32)
// TODO COPE (parm span of t): void Reverse<T>(System.Span<T>)
// TODO COPE (parm span of t): System.Int32 SequenceCompareTo<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Int32 SequenceCompareTo<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>, System.Collections.Generic.IEqualityComparer<T>)
// TODO COPE (parm span of t): bool SequenceEqual<T>(System.Span<T>, System.ReadOnlySpan<T>, System.Collections.Generic.IEqualityComparer<T>)
// TODO COPE (parm span of t): void Sort<T>(System.Span<T>)
// TODO COPE (parm span of t): void Sort<T>(System.Span<T>, System.Comparison<T>)
// TODO COPE (parm span of t): void Sort<TKey, TValue>(System.Span<TKey>, System.Span<TValue>)
// TODO COPE (parm span of t): void Sort<TKey, TValue>(System.Span<TKey>, System.Span<TValue>, System.Comparison<TKey>)
// TODO COPE (parm span of t): void Sort<T, TComparer>(System.Span<T>, TComparer)
// TODO COPE (parm span of t): void Sort<TKey, TValue, TComparer>(System.Span<TKey>, System.Span<TValue>, TComparer)
// EXTENSION METHOD bool StartsWith(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)
// TODO COPE extension method (span) bool StartsWith(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.StringComparison)

// TODO COPE (parm span of t): bool StartsWith<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): bool StartsWith<T>(System.Span<T>, System.ReadOnlySpan<T>)
// EXTENSION METHOD System.Int32 ToLower(System.ReadOnlySpan<System.Char>, System.Span<System.Char>, System.Globalization.CultureInfo)
// TODO COPE extension method (span) System.Int32 ToLower(System.ReadOnlySpan<System.Char>, System.Span<System.Char>, System.Globalization.CultureInfo)

// EXTENSION METHOD System.Int32 ToLowerInvariant(System.ReadOnlySpan<System.Char>, System.Span<System.Char>)
// TODO COPE extension method (span) System.Int32 ToLowerInvariant(System.ReadOnlySpan<System.Char>, System.Span<System.Char>)

// EXTENSION METHOD System.Int32 ToUpper(System.ReadOnlySpan<System.Char>, System.Span<System.Char>, System.Globalization.CultureInfo)
// TODO COPE extension method (span) System.Int32 ToUpper(System.ReadOnlySpan<System.Char>, System.Span<System.Char>, System.Globalization.CultureInfo)

// EXTENSION METHOD System.Int32 ToUpperInvariant(System.ReadOnlySpan<System.Char>, System.Span<System.Char>)
// TODO COPE extension method (span) System.Int32 ToUpperInvariant(System.ReadOnlySpan<System.Char>, System.Span<System.Char>)

// EXTENSION METHOD System.Memory<System.Char> Trim(System.Memory<System.Char>)
extension dotnet.System.Memory_1 {
    public func Trim() throws -> dotnet.System.Memory_1<dotnet.System.Char> where T == dotnet.System.Char {
        return try dotnet.System.MemoryExtensions.Trim(memory: self);
    }
}

// EXTENSION METHOD System.ReadOnlyMemory<System.Char> Trim(System.ReadOnlyMemory<System.Char>)
extension dotnet.System.ReadOnlyMemory_1 {
    public func Trim() throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> where T == dotnet.System.Char {
        return try dotnet.System.MemoryExtensions.Trim(memory: self);
    }
}

// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> Trim(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> Trim(System.ReadOnlySpan<System.Char>, System.Char)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> Trim(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Span<System.Char> Trim(System.Span<System.Char>)
// EXTENSION METHOD System.Memory<System.Char> TrimEnd(System.Memory<System.Char>)
extension dotnet.System.Memory_1 {
    public func TrimEnd() throws -> dotnet.System.Memory_1<dotnet.System.Char> where T == dotnet.System.Char {
        return try dotnet.System.MemoryExtensions.TrimEnd(memory: self);
    }
}

// EXTENSION METHOD System.ReadOnlyMemory<System.Char> TrimEnd(System.ReadOnlyMemory<System.Char>)
extension dotnet.System.ReadOnlyMemory_1 {
    public func TrimEnd() throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> where T == dotnet.System.Char {
        return try dotnet.System.MemoryExtensions.TrimEnd(memory: self);
    }
}

// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimEnd(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimEnd(System.ReadOnlySpan<System.Char>, System.Char)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimEnd(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Span<System.Char> TrimEnd(System.Span<System.Char>)
// TODO COPE (parm span of t): System.Memory<T> TrimEnd<T>(System.Memory<T>, System.ReadOnlySpan<T>)
// EXTENSION METHOD System.Memory<T> TrimEnd<T>(System.Memory<T>, T)
extension dotnet.System.Memory_1 {
    public func TrimEnd(trimElement : T) throws -> dotnet.System.Memory_1<T> {
        return try dotnet.System.MemoryExtensions.TrimEnd(memory: self, trimElement: trimElement);
    }
}

// TODO COPE (parm span of t): System.ReadOnlyMemory<T> TrimEnd<T>(System.ReadOnlyMemory<T>, System.ReadOnlySpan<T>)
// EXTENSION METHOD System.ReadOnlyMemory<T> TrimEnd<T>(System.ReadOnlyMemory<T>, T)
extension dotnet.System.ReadOnlyMemory_1 {
    public func TrimEnd(trimElement : T) throws -> dotnet.System.ReadOnlyMemory_1<T> {
        return try dotnet.System.MemoryExtensions.TrimEnd(memory: self, trimElement: trimElement);
    }
}

// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimEnd<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimEnd<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Span<T> TrimEnd<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Span<T> TrimEnd<T>(System.Span<T>, T)
// EXTENSION METHOD System.Memory<System.Char> TrimStart(System.Memory<System.Char>)
extension dotnet.System.Memory_1 {
    public func TrimStart() throws -> dotnet.System.Memory_1<dotnet.System.Char> where T == dotnet.System.Char {
        return try dotnet.System.MemoryExtensions.TrimStart(memory: self);
    }
}

// EXTENSION METHOD System.ReadOnlyMemory<System.Char> TrimStart(System.ReadOnlyMemory<System.Char>)
extension dotnet.System.ReadOnlyMemory_1 {
    public func TrimStart() throws -> dotnet.System.ReadOnlyMemory_1<dotnet.System.Char> where T == dotnet.System.Char {
        return try dotnet.System.MemoryExtensions.TrimStart(memory: self);
    }
}

// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimStart(System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimStart(System.ReadOnlySpan<System.Char>, System.Char)
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Char> TrimStart(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (returns byreflike): System.Span<System.Char> TrimStart(System.Span<System.Char>)
// TODO COPE (parm span of t): System.Memory<T> TrimStart<T>(System.Memory<T>, System.ReadOnlySpan<T>)
// EXTENSION METHOD System.Memory<T> TrimStart<T>(System.Memory<T>, T)
extension dotnet.System.Memory_1 {
    public func TrimStart(trimElement : T) throws -> dotnet.System.Memory_1<T> {
        return try dotnet.System.MemoryExtensions.TrimStart(memory: self, trimElement: trimElement);
    }
}

// TODO COPE (parm span of t): System.ReadOnlyMemory<T> TrimStart<T>(System.ReadOnlyMemory<T>, System.ReadOnlySpan<T>)
// EXTENSION METHOD System.ReadOnlyMemory<T> TrimStart<T>(System.ReadOnlyMemory<T>, T)
extension dotnet.System.ReadOnlyMemory_1 {
    public func TrimStart(trimElement : T) throws -> dotnet.System.ReadOnlyMemory_1<T> {
        return try dotnet.System.MemoryExtensions.TrimStart(memory: self, trimElement: trimElement);
    }
}

// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimStart<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.ReadOnlySpan<T> TrimStart<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Span<T> TrimStart<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Span<T> TrimStart<T>(System.Span<T>, T)
// TODO COPE (parm span of t): System.Memory<T> Trim<T>(System.Memory<T>, System.ReadOnlySpan<T>)
// EXTENSION METHOD System.Memory<T> Trim<T>(System.Memory<T>, T)
extension dotnet.System.Memory_1 {
    public func Trim(trimElement : T) throws -> dotnet.System.Memory_1<T> {
        return try dotnet.System.MemoryExtensions.Trim(memory: self, trimElement: trimElement);
    }
}

// TODO COPE (parm span of t): System.ReadOnlyMemory<T> Trim<T>(System.ReadOnlyMemory<T>, System.ReadOnlySpan<T>)
// EXTENSION METHOD System.ReadOnlyMemory<T> Trim<T>(System.ReadOnlyMemory<T>, T)
extension dotnet.System.ReadOnlyMemory_1 {
    public func Trim(trimElement : T) throws -> dotnet.System.ReadOnlyMemory_1<T> {
        return try dotnet.System.MemoryExtensions.Trim(memory: self, trimElement: trimElement);
    }
}

// TODO COPE (parm span of t): System.ReadOnlySpan<T> Trim<T>(System.ReadOnlySpan<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.ReadOnlySpan<T> Trim<T>(System.ReadOnlySpan<T>, T)
// TODO COPE (parm span of t): System.Span<T> Trim<T>(System.Span<T>, System.ReadOnlySpan<T>)
// TODO COPE (parm span of t): System.Span<T> Trim<T>(System.Span<T>, T)
// TODO COPE (parm byref span): bool TryWrite(System.Span<System.Char>, ref System.MemoryExtensions.TryWriteInterpolatedStringHandler, ref System.Int32)
// TODO COPE (parm byref span): bool TryWrite(System.Span<System.Char>, System.IFormatProvider, ref System.MemoryExtensions.TryWriteInterpolatedStringHandler, ref System.Int32)
// EXTENSION METHOD void Convert(System.Text.Decoder, ref System.Buffers.ReadOnlySequence<System.Byte>, System.Buffers.IBufferWriter<System.Char>, bool, ref System.Int64, ref bool)
extension dotnet.System.Text.Decoder {
    public func Convert(bytes : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>, writer : dotnet.System.Buffers.IBufferWriter_1<dotnet.System.Char>, flush : Bool, charsUsed : inout Swift.Int64, completed : inout Bool) throws {
        try dotnet.System.Text.EncodingExtensions.Convert(decoder: self, bytes: &bytes, writer: writer, flush: flush, charsUsed: &charsUsed, completed: &completed);
    }
}

// EXTENSION METHOD void Convert(System.Text.Decoder, System.ReadOnlySpan<System.Byte>, System.Buffers.IBufferWriter<System.Char>, bool, ref System.Int64, ref bool)
// TODO COPE extension method (span) void Convert(System.Text.Decoder, System.ReadOnlySpan<System.Byte>, System.Buffers.IBufferWriter<System.Char>, bool, ref System.Int64, ref bool)

// EXTENSION METHOD void Convert(System.Text.Encoder, ref System.Buffers.ReadOnlySequence<System.Char>, System.Buffers.IBufferWriter<System.Byte>, bool, ref System.Int64, ref bool)
extension dotnet.System.Text.Encoder {
    public func Convert(chars : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<dotnet.System.Char>>, writer : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>, flush : Bool, bytesUsed : inout Swift.Int64, completed : inout Bool) throws {
        try dotnet.System.Text.EncodingExtensions.Convert(encoder: self, chars: &chars, writer: writer, flush: flush, bytesUsed: &bytesUsed, completed: &completed);
    }
}

// EXTENSION METHOD void Convert(System.Text.Encoder, System.ReadOnlySpan<System.Char>, System.Buffers.IBufferWriter<System.Byte>, bool, ref System.Int64, ref bool)
// TODO COPE extension method (span) void Convert(System.Text.Encoder, System.ReadOnlySpan<System.Char>, System.Buffers.IBufferWriter<System.Byte>, bool, ref System.Int64, ref bool)

// EXTENSION METHOD System.Byte[] GetBytes(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Char>)
extension dotnet.System.Text.Encoding {
    public func GetBytes(chars : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<dotnet.System.Char>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        return try dotnet.System.Text.EncodingExtensions.GetBytes(encoding: self, chars: &chars);
    }
}

// EXTENSION METHOD System.Int64 GetBytes(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Char>, System.Buffers.IBufferWriter<System.Byte>)
extension dotnet.System.Text.Encoding {
    public func GetBytes(chars : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<dotnet.System.Char>>, writer : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>) throws -> Swift.Int64 {
        return try dotnet.System.Text.EncodingExtensions.GetBytes(encoding: self, chars: &chars, writer: writer);
    }
}

// EXTENSION METHOD System.Int32 GetBytes(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Char>, System.Span<System.Byte>)
// TODO COPE extension method (span) System.Int32 GetBytes(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Char>, System.Span<System.Byte>)

// EXTENSION METHOD System.Int64 GetBytes(System.Text.Encoding, System.ReadOnlySpan<System.Char>, System.Buffers.IBufferWriter<System.Byte>)
// TODO COPE extension method (span) System.Int64 GetBytes(System.Text.Encoding, System.ReadOnlySpan<System.Char>, System.Buffers.IBufferWriter<System.Byte>)

// EXTENSION METHOD System.Int64 GetChars(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Byte>, System.Buffers.IBufferWriter<System.Char>)
extension dotnet.System.Text.Encoding {
    public func GetChars(bytes : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>, writer : dotnet.System.Buffers.IBufferWriter_1<dotnet.System.Char>) throws -> Swift.Int64 {
        return try dotnet.System.Text.EncodingExtensions.GetChars(encoding: self, bytes: &bytes, writer: writer);
    }
}

// EXTENSION METHOD System.Int32 GetChars(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Byte>, System.Span<System.Char>)
// TODO COPE extension method (span) System.Int32 GetChars(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Byte>, System.Span<System.Char>)

// EXTENSION METHOD System.Int64 GetChars(System.Text.Encoding, System.ReadOnlySpan<System.Byte>, System.Buffers.IBufferWriter<System.Char>)
// TODO COPE extension method (span) System.Int64 GetChars(System.Text.Encoding, System.ReadOnlySpan<System.Byte>, System.Buffers.IBufferWriter<System.Char>)

// EXTENSION METHOD System.String GetString(System.Text.Encoding, ref System.Buffers.ReadOnlySequence<System.Byte>)
extension dotnet.System.Text.Encoding {
    public func GetString(bytes : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>) throws -> dotnet.System.String {
        return try dotnet.System.Text.EncodingExtensions.GetString(encoding: self, bytes: &bytes);
    }
}

