// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
// System.Net
// System.Net.Sockets
extension System.Net.Sockets {
// type: System.Net.Sockets.IOControlCode
    /**
    Specifies the IO control codes supported by the  method.

    */
public struct IOControlCode : SGBridgeGenericValue {
    let v : Swift.Int64;
    public init(val: Swift.Int64) { self.v = val; }
    public func get_value() -> Swift.Int64 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_IOControlCode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int64(gval); }
    // static field: System.Net.Sockets.IOControlCode EnableCircularQueuing
    /**
    Replace the oldest queued datagram with an incoming datagram when the incoming message queues are full. This value is equal to the Winsock 2 SIO_ENABLE_CIRCULAR_QUEUEING constant.

    */
    public static var EnableCircularQueuing : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_EnableCircularQueuing());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode Flush
    /**
    Discard the contents of the sending queue. This value is equal to the Winsock 2 SIO_FLUSH constant.

    */
    public static var Flush : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_Flush());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode AddressListChange
    /**
    Enable receiving notification when the list of local interfaces for the socket's protocol family changes. This value is equal to the Winsock 2 SIO_ADDRESS_LIST_CHANGE constant.

    */
    public static var AddressListChange : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_AddressListChange());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode DataToRead
    /**
    Return the number of bytes available for reading. This value is equal to the Winsock 2 FIONREAD constant.

    */
    public static var DataToRead : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_DataToRead());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode OobDataRead
    /**
    Return information about out-of-band data waiting to be received. When using this control code on stream sockets, the return value indicates the number of bytes available.

    */
    public static var OobDataRead : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_OobDataRead());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode GetBroadcastAddress
    /**
    Return a SOCKADDR structure that contains the broadcast address for the address family of the current socket. The returned address can be used with the  method. This value is equal to the Winsock 2 SIO_GET_BROADCAST_ADDRESS constant. This value can be used on User Datagram Protocol (UDP) sockets only.

    */
    public static var GetBroadcastAddress : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_GetBroadcastAddress());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode AddressListQuery
    /**
    Return the list of local interfaces that the socket can bind to. This value is equal to the Winsock 2 SIO_ADDRESS_LIST_QUERY constant.

    */
    public static var AddressListQuery : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_AddressListQuery());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode QueryTargetPnpHandle
    /**
    Retrieve the underlying provider's SOCKET handle. This handle can be used to receive plug-and-play event notification. This value is equal to the Winsock 2 SIO_QUERY_TARGET_PNP_HANDLE constant.

    */
    public static var QueryTargetPnpHandle : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_QueryTargetPnpHandle());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode AsyncIO
    /**
    Enable notification for when data is waiting to be received. This value is equal to the Winsock 2 FIOASYNC constant.

    */
    public static var AsyncIO : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_AsyncIO());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode NonBlockingIO
    /**
    Control the blocking behavior of the socket. If the argument specified with this control code is zero, the socket is placed in blocking mode. If the argument is nonzero, the socket is placed in nonblocking mode. This value is equal to the Winsock 2 FIONBIO constant.

    */
    public static var NonBlockingIO : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_NonBlockingIO());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode AssociateHandle
    /**
    Associate this socket with the specified handle of a companion interface. Refer to the appropriate  protocol-specific annex in the Winsock 2 reference or documentation for the particular companion interface for additional details. It is recommended that the Component Object Model (COM) be used instead of this IOCTL to discover and track other interfaces that might be supported by a socket. This control code is present for backward compatibility with systems where COM is not available or cannot be used for some other reason. This value is equal to the Winsock 2 SIO_ASSOCIATE_HANDLE constant.

    */
    public static var AssociateHandle : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_AssociateHandle());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode MultipointLoopback
    /**
    Control whether multicast data sent by the socket appears as incoming data in the sockets receive queue. This value is equal to the Winsock 2 SIO_MULTIPOINT_LOOPBACK constant.

    */
    public static var MultipointLoopback : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_MultipointLoopback());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode MulticastScope
    /**
    Control the number of times a multicast packet can be forwarded by a router, also known as the Time to Live (TTL), or hop count. This value is equal to the Winsock 2 SIO_MULTICAST_SCOPE constant.

    */
    public static var MulticastScope : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_MulticastScope());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode SetQos
    /**
    Set the Quality of Service (QOS) attributes for the socket. QOS defines the bandwidth requirements for the socket. This value is equal to the Winsock 2 SIO_SET_QOS constant.

    */
    public static var SetQos : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_SetQos());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode SetGroupQos
    /**
    Set the Quality of Service (QOS) attributes for the socket group. This value is reserved for future use and is equal to the Winsock 2 SIO_SET_GROUP_QOS constant.

    */
    public static var SetGroupQos : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_SetGroupQos());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode RoutingInterfaceChange
    /**
    Enable receiving notification when the local interface used to access a remote endpoint changes. This value is equal to the Winsock 2 SIO_ROUTING_INTERFACE_CHANGE constant.

    */
    public static var RoutingInterfaceChange : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_RoutingInterfaceChange());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode NamespaceChange
    /**
    Control whether the socket receives notification when a namespace query becomes invalid. This control code is supported on Windows XP and later operating systems. This value is equal to the Winsock 2 SIO_NSP_NOTIFY_CHANGE constant.

    */
    public static var NamespaceChange : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_NamespaceChange());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode ReceiveAll
    /**
    Enable receiving all IPv4 packets on the network. The socket must have address family , the socket type must be , and the protocol type must be . The current user must belong to the Administrators group on the local computer, and the socket must be bound to a specific port. This value is equal to the Winsock 2 SIO_RCVALL constant.

    */
    public static var ReceiveAll : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_ReceiveAll());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode ReceiveAllMulticast
    /**
    Enable receiving all multicast IPv4 packets on the network. These are packets with destination addresses in the range 224.0.0.0 through 239.255.255.255. The socket must have address family , the socket type must be , and the protocol type must be . The current user must belong to the Administrators group on the local computer, and the socket must be bound to a specific port. This value is equal to the Winsock 2 SIO_RCVALL_MCAST constant.

    */
    public static var ReceiveAllMulticast : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_ReceiveAllMulticast());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode ReceiveAllIgmpMulticast
    /**
    Enable receiving all Internet Group Management Protocol (IGMP) packets on the network. The socket must have address family , the socket type must be , and the protocol type must be . The current user must belong to the Administrators group on the local computer, and the socket must be bound to a specific port. This value is equal to the Winsock 2 SIO_RCVALL_IGMPMCAST constant.

    */
    public static var ReceiveAllIgmpMulticast : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_ReceiveAllIgmpMulticast());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode KeepAliveValues
    /**
    Control sending TCP keep-alive packets and the interval at which they are sent. For additional information, see RFC 1122 section 4.2.3.6. This value is equal to the Winsock 2 SIO_KEEPALIVE_VALS constant.

    */
    public static var KeepAliveValues : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_KeepAliveValues());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode AbsorbRouterAlert
    /**
    This value is equal to the Winsock 2 SIO_ABSORB_RTRALERT constant.

    */
    public static var AbsorbRouterAlert : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_AbsorbRouterAlert());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode UnicastInterface
    /**
    Set the interface used for outgoing unicast packets. This value is equal to the Winsock 2 SIO_UCAST_IF constant.

    */
    public static var UnicastInterface : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_UnicastInterface());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode LimitBroadcasts
    /**
    This value is equal to the Winsock 2 SIO_LIMIT_BROADCASTS constant.

    */
    public static var LimitBroadcasts : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_LimitBroadcasts());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode BindToInterface
    /**
    Bind the socket to a specified interface index. This value is equal to the Winsock 2 SIO_INDEX_BIND constant.

    */
    public static var BindToInterface : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_BindToInterface());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode MulticastInterface
    /**
    Set the interface used for outgoing multicast packets. The interface is identified by its index.  This value is equal to the Winsock 2 SIO_INDEX_MCASTIF constant.

    */
    public static var MulticastInterface : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_MulticastInterface());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode AddMulticastGroupOnInterface
    /**
    Join a multicast group using an interface identified by its index. This value is equal to the Winsock 2 SIO_INDEX_ADD_MCAST constant.

    */
    public static var AddMulticastGroupOnInterface : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_AddMulticastGroupOnInterface());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode DeleteMulticastGroupFromInterface
    /**
    Remove the socket from a multicast group. This value is equal to the Winsock 2 SIO_INDEX_ADD_MCAST constant.

    */
    public static var DeleteMulticastGroupFromInterface : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_DeleteMulticastGroupFromInterface());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode GetExtensionFunctionPointer
    /**
    Obtain provider-specific functions that are not part of the Winsock specification. Functions are specified using their provider-assigned GUID. This value is equal to the Winsock 2 SIO_GET_EXTENSION_FUNCTION_POINTER constant.

    */
    public static var GetExtensionFunctionPointer : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_GetExtensionFunctionPointer());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode GetQos
    /**
    Retrieve the QOS structure associated with the socket. This value is equal to the Winsock 2 SIO_GET_QOS constant.

    */
    public static var GetQos : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_GetQos());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode GetGroupQos
    /**
    Return the Quality of Service (QOS) attributes for the socket group. This value is reserved for future use, and is equal to the Winsock 2 SIO_GET_GROUP_QOS constant.

    */
    public static var GetGroupQos : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_GetGroupQos());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode TranslateHandle
    /**
    Return a handle for the socket that is valid in the context of a companion interface. This value is equal to the Winsock 2 SIO_TRANSLATE_HANDLE constant.

    */
    public static var TranslateHandle : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_TranslateHandle());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode RoutingInterfaceQuery
    /**
    Return the interface addresses that can be used to connect to the specified remote address. This value is equal to the Winsock 2 SIO_ROUTING_INTERFACE_QUERY constant.

    */
    public static var RoutingInterfaceQuery : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_RoutingInterfaceQuery());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IOControlCode AddressListSort
    /**
    Sort the structure returned by the  field and add scope ID information for IPv6 addresses. This control code is supported on Windows XP and later operating systems. This value is equal to the Winsock 2 SIO_ADDRESS_LIST_SORT constant.

    */
    public static var AddressListSort : dotnet.System.Net.Sockets.IOControlCode {
        get {
        let __return = dotnet.System.Net.Sockets.IOControlCode(val: System_Net_Sockets_IOControlCode_get_AddressListSort());
            return __return;
        }
    }
} // IOControlCode


// type: System.Net.Sockets.IPPacketInformation
// boxed value type
    /**
    Presents the packet information from a call to  or .

    */
public final class IPPacketInformation
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_IPPacketInformation_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the origin information of the packet that was received as a result of calling the  method or  method.

    */
    public var Address : dotnet.System.Net.IPAddress {
        get {
            return try! get_Address();
        }
    }
    /**
    Gets the network interface information that is associated with a call to  or .

    */
    public var Interface : Swift.Int32 {
        get {
            return try! get_Interface();
        }
    }
    public override init() {
        let h = System_Net_Sockets_IPPacketInformation_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Object)
// docid: M:System.Net.Sockets.IPPacketInformation.Equals(System.Object)
    /**
    Returns a value that indicates whether this instance is equal to a specified object.

    - Parameter comparand: The object to compare with this instance.
    - Returns: 
         if  is an instance of  and equals the value of the instance; otherwise, .

    */
    public func Equals(comparand : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPPacketInformation_bool__Equals_0__1__Object(&__thrown, self.get_handle(), comparand?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.Sockets.IPPacketInformation.GetHashCode
    /**
    Returns the hash code for this instance.

    - Returns: An Int32 hash code.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPPacketInformation_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Net.Sockets.IPPacketInformation, System.Net.Sockets.IPPacketInformation)
// docid: M:System.Net.Sockets.IPPacketInformation.op_Equality(System.Net.Sockets.IPPacketInformation,System.Net.Sockets.IPPacketInformation)
    /**
    Tests whether two specified  instances are equivalent.

    - Parameter packetInformation1: The  instance that is to the left of the equality operator.
    - Parameter packetInformation2: The  instance that is to the right of the equality operator.
    - Returns: 
         if  and  are equal; otherwise, .

    */
    public class func op_Equality(packetInformation1 : dotnet.System.Net.Sockets.IPPacketInformation, packetInformation2 : dotnet.System.Net.Sockets.IPPacketInformation) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPPacketInformation_bool__op_Equality_0__2__IPPacketInformation_IPPacketInformation(&__thrown, packetInformation1.get_handle(), packetInformation2.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Net.Sockets.IPPacketInformation, System.Net.Sockets.IPPacketInformation)
// docid: M:System.Net.Sockets.IPPacketInformation.op_Inequality(System.Net.Sockets.IPPacketInformation,System.Net.Sockets.IPPacketInformation)
    /**
    Tests whether two specified  instances are not equal.

    - Parameter packetInformation1: The  instance that is to the left of the inequality operator.
    - Parameter packetInformation2: The  instance that is to the right of the inequality operator.
    - Returns: 
         if  and  are unequal; otherwise, .

    */
    public class func op_Inequality(packetInformation1 : dotnet.System.Net.Sockets.IPPacketInformation, packetInformation2 : dotnet.System.Net.Sockets.IPPacketInformation) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPPacketInformation_bool__op_Inequality_0__2__IPPacketInformation_IPPacketInformation(&__thrown, packetInformation1.get_handle(), packetInformation2.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.IPAddress get_Address()
// docid: M:System.Net.Sockets.IPPacketInformation.get_Address
    public func get_Address() throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPPacketInformation_IPAddress__get_Address_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Interface()
// docid: M:System.Net.Sockets.IPPacketInformation.get_Interface
    public func get_Interface() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPPacketInformation_i32__get_Interface_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // IPPacketInformation


// type: System.Net.Sockets.IPProtectionLevel
    /**
    A value that enables restriction of an IPv6 socket to a specified scope, such as addresses with the same link local or site local prefix.

    */
public struct IPProtectionLevel : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_IPProtectionLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.IPProtectionLevel Unspecified
    /**
    The IP protection level is unspecified. On Windows 7 and Windows Server 2008 R2, the default value for the IP Protection level on a socket is unspecified.

    */
    public static var Unspecified : dotnet.System.Net.Sockets.IPProtectionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.IPProtectionLevel(val: System_Net_Sockets_IPProtectionLevel_get_Unspecified());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IPProtectionLevel Unrestricted
    /**
    The IP protection level is unrestricted. This value would be used by applications designed to operate across the Internet, including applications taking advantage of IPv6 NAT traversal capabilities built into Windows (Teredo, for example). These applications may bypass IPv4 firewalls, so applications must be hardened against Internet attacks directed at the opened port. On Windows Server 2008 R2 and Windows Vista, the default value for the IP Protection level on a socket is unrestricted.

    */
    public static var Unrestricted : dotnet.System.Net.Sockets.IPProtectionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.IPProtectionLevel(val: System_Net_Sockets_IPProtectionLevel_get_Unrestricted());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IPProtectionLevel EdgeRestricted
    /**
    The IP protection level is edge restricted. This value would be used by applications designed to operate across the Internet. This setting does not allow Network Address Translation (NAT) traversal using the Windows Teredo implementation. These applications may bypass IPv4 firewalls, so applications must be hardened against Internet attacks directed at the opened port. On Windows Server 2003 and Windows XP, the default value for the IP Protection level on a socket is edge restricted.

    */
    public static var EdgeRestricted : dotnet.System.Net.Sockets.IPProtectionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.IPProtectionLevel(val: System_Net_Sockets_IPProtectionLevel_get_EdgeRestricted());
            return __return;
        }
    }
    // static field: System.Net.Sockets.IPProtectionLevel Restricted
    /**
    The IP protection level is restricted. This value would be used by intranet applications that do not implement Internet scenarios. These applications are generally not tested or hardened against Internet-style attacks. This setting will limit the received traffic to link-local only.

    */
    public static var Restricted : dotnet.System.Net.Sockets.IPProtectionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.IPProtectionLevel(val: System_Net_Sockets_IPProtectionLevel_get_Restricted());
            return __return;
        }
    }
} // IPProtectionLevel


// type: System.Net.Sockets.IPv6MulticastOption
    /**
    Contains option values for joining an IPv6 multicast group.

    */
open class IPv6MulticastOption
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_IPv6MulticastOption_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_IPv6MulticastOption_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Net.IPAddress)
// docid: M:System.Net.Sockets.IPv6MulticastOption.#ctor(System.Net.IPAddress)
    /**
    Initializes a new version of the  class for the specified IP multicast group.

    - Parameter group: The  of the multicast group.
    */
    public init(group : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_IPv6MulticastOption_ctor_0__1__IPAddress(&__thrown, group.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPAddress, System.Int64)
// docid: M:System.Net.Sockets.IPv6MulticastOption.#ctor(System.Net.IPAddress,System.Int64)
    /**
    Initializes a new instance of the  class with the specified IP multicast group and the local interface address.

    - Parameter group: The group .
    - Parameter ifindex: The local interface address.
    */
    public init(group : dotnet.System.Net.IPAddress, ifindex : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_IPv6MulticastOption_ctor_0__2__IPAddress_i64(&__thrown, group.get_handle(), ifindex);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Net.IPAddress get_Group()
// docid: M:System.Net.Sockets.IPv6MulticastOption.get_Group
    open func get_Group() throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPv6MulticastOption_IPAddress__get_Group_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Group(System.Net.IPAddress)
// docid: M:System.Net.Sockets.IPv6MulticastOption.set_Group(System.Net.IPAddress)
    open func set_Group(value : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_IPv6MulticastOption_void__set_Group_0__1__IPAddress(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_InterfaceIndex()
// docid: M:System.Net.Sockets.IPv6MulticastOption.get_InterfaceIndex
    open func get_InterfaceIndex() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_IPv6MulticastOption_i64__get_InterfaceIndex_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_InterfaceIndex(System.Int64)
// docid: M:System.Net.Sockets.IPv6MulticastOption.set_InterfaceIndex(System.Int64)
    open func set_InterfaceIndex(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_IPv6MulticastOption_void__set_InterfaceIndex_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the IP address of a multicast group.

    */
    open var Group : dotnet.System.Net.IPAddress {
        get {
            return try! get_Group();
        }
        set(v) {
            return try! set_Group(value: v);
        }
    }
    /**
    Gets or sets the interface index that is associated with a multicast group.

    */
    open var InterfaceIndex : Swift.Int64 {
        get {
            return try! get_InterfaceIndex();
        }
        set(v) {
            return try! set_InterfaceIndex(value: v);
        }
    }
} // IPv6MulticastOption


// type: System.Net.Sockets.LingerOption
    /**
    Specifies whether a  will remain connected after a call to the  or  methods and the length of time it will remain connected, if data remains to be sent.

    */
open class LingerOption
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_LingerOption_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_LingerOption_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(bool, System.Int32)
// docid: M:System.Net.Sockets.LingerOption.#ctor(System.Boolean,System.Int32)
    /**
    Initializes a new instance of the  class.

    - Parameter enable: 
         to remain connected after the  method is called; otherwise, .
    - Parameter seconds: The number of seconds to remain connected after the  method is called.
    */
    public init(enable : Bool, seconds : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_LingerOption_ctor_0__2__bool_i32(&__thrown, Swift.Int32(enable ? 1 : 0), seconds);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_Enabled()
// docid: M:System.Net.Sockets.LingerOption.get_Enabled
    open func get_Enabled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_LingerOption_bool__get_Enabled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Enabled(bool)
// docid: M:System.Net.Sockets.LingerOption.set_Enabled(System.Boolean)
    open func set_Enabled(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_LingerOption_void__set_Enabled_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_LingerTime()
// docid: M:System.Net.Sockets.LingerOption.get_LingerTime
    open func get_LingerTime() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_LingerOption_i32__get_LingerTime_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_LingerTime(System.Int32)
// docid: M:System.Net.Sockets.LingerOption.set_LingerTime(System.Int32)
    open func set_LingerTime(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_LingerOption_void__set_LingerTime_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets a value that indicates whether to linger after the  is closed.

    */
    open var Enabled : Bool {
        get {
            return try! get_Enabled();
        }
        set(v) {
            return try! set_Enabled(value: v);
        }
    }
    /**
    Gets or sets the amount of time to remain connected after calling the  method if data remains to be sent.

    */
    open var LingerTime : Swift.Int32 {
        get {
            return try! get_LingerTime();
        }
        set(v) {
            return try! set_LingerTime(value: v);
        }
    }
} // LingerOption


// type: System.Net.Sockets.MulticastOption
    /**
    Contains  values used to join and drop multicast groups.

    */
open class MulticastOption
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_MulticastOption_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_MulticastOption_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Net.IPAddress)
// docid: M:System.Net.Sockets.MulticastOption.#ctor(System.Net.IPAddress)
    /**
    Initializes a new version of the  class for the specified IP multicast group.

    - Parameter group: The IP address of the multicast group.
    */
    public init(group : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_MulticastOption_ctor_0__1__IPAddress(&__thrown, group.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.MulticastOption.#ctor(System.Net.IPAddress,System.Int32)
    /**
    Initializes a new instance of the  class with the specified IP multicast group address and interface index.

    - Parameter group: The IP address of the multicast group.
    - Parameter interfaceIndex: The index of the interface that's used to send and receive multicast packets.
    */
    public init(group : dotnet.System.Net.IPAddress, interfaceIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_MulticastOption_ctor_0__2__IPAddress_i32(&__thrown, group.get_handle(), interfaceIndex);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPAddress, System.Net.IPAddress)
// docid: M:System.Net.Sockets.MulticastOption.#ctor(System.Net.IPAddress,System.Net.IPAddress)
    /**
    Initializes a new instance of the  class with the specified IP multicast group address and local IP address associated with a network interface.

    - Parameter group: The group IP address.
    - Parameter mcint: The local IP address.
    */
    public init(group : dotnet.System.Net.IPAddress, mcint : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_MulticastOption_ctor_0__2__IPAddress_IPAddress(&__thrown, group.get_handle(), mcint.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Net.IPAddress get_Group()
// docid: M:System.Net.Sockets.MulticastOption.get_Group
    open func get_Group() throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_MulticastOption_IPAddress__get_Group_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Group(System.Net.IPAddress)
// docid: M:System.Net.Sockets.MulticastOption.set_Group(System.Net.IPAddress)
    open func set_Group(value : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_MulticastOption_void__set_Group_0__1__IPAddress(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_InterfaceIndex()
// docid: M:System.Net.Sockets.MulticastOption.get_InterfaceIndex
    open func get_InterfaceIndex() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_MulticastOption_i32__get_InterfaceIndex_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_InterfaceIndex(System.Int32)
// docid: M:System.Net.Sockets.MulticastOption.set_InterfaceIndex(System.Int32)
    open func set_InterfaceIndex(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_MulticastOption_void__set_InterfaceIndex_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.IPAddress get_LocalAddress()
// docid: M:System.Net.Sockets.MulticastOption.get_LocalAddress
    open func get_LocalAddress() throws -> Optional<dotnet.System.Net.IPAddress> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_MulticastOption_IPAddress__get_LocalAddress_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.IPAddress(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LocalAddress(System.Net.IPAddress)
// docid: M:System.Net.Sockets.MulticastOption.set_LocalAddress(System.Net.IPAddress)
    open func set_LocalAddress(value : Optional<dotnet.System.Net.IPAddress>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_MulticastOption_void__set_LocalAddress_0__1__IPAddress(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the IP address of a multicast group.

    */
    open var Group : dotnet.System.Net.IPAddress {
        get {
            return try! get_Group();
        }
        set(v) {
            return try! set_Group(value: v);
        }
    }
    /**
    Gets or sets the index of the interface that's used to send and receive multicast packets.

    */
    open var InterfaceIndex : Swift.Int32 {
        get {
            return try! get_InterfaceIndex();
        }
        set(v) {
            return try! set_InterfaceIndex(value: v);
        }
    }
    /**
    Gets or sets the local address associated with a multicast group.

    */
    open var LocalAddress : Optional<dotnet.System.Net.IPAddress> {
        get {
            return try! get_LocalAddress();
        }
        set(v) {
            return try! set_LocalAddress(value: v!);
        }
    }
} // MulticastOption


// type: System.Net.Sockets.NetworkStream
    /**
    Provides the underlying stream of data for network access.

    */
open class NetworkStream
    :
    dotnet.System.IO.Stream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_NetworkStream_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_NetworkStream_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Net.Sockets.Socket)
// docid: M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
    /**
    Creates a new instance of the  class for the specified .

    - Parameter socket: The  that the  will use to send and receive data.
    */
    public init(socket : dotnet.System.Net.Sockets.Socket) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_NetworkStream_ctor_0__1__Socket(&__thrown, socket.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.Socket, bool)
// docid: M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
    /**
    Initializes a new instance of the  class for the specified  with the specified  ownership.

    - Parameter socket: The  that the  will use to send and receive data.
    - Parameter ownsSocket: Set to  to indicate that the  will take ownership of the ; otherwise, .
    */
    public init(socket : dotnet.System.Net.Sockets.Socket, ownsSocket : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_NetworkStream_ctor_0__2__Socket_bool(&__thrown, socket.get_handle(), Swift.Int32(ownsSocket ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.Socket, System.IO.FileAccess)
// docid: M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
    /**
    Creates a new instance of the  class for the specified  with the specified access rights.

    - Parameter socket: The  that the  will use to send and receive data.
    - Parameter access: A bitwise combination of the  values that specify the type of access given to the  over the provided .
    */
    public init(socket : dotnet.System.Net.Sockets.Socket, access : dotnet.System.IO.FileAccess) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_NetworkStream_ctor_0__2__Socket_FileAccess(&__thrown, socket.get_handle(), access.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.Socket, System.IO.FileAccess, bool)
// docid: M:System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
    /**
    Creates a new instance of the  class for the specified  with the specified access rights and the specified  ownership.

    - Parameter socket: The  that the  will use to send and receive data.
    - Parameter access: A bitwise combination of the  values that specifies the type of access given to the  over the provided .
    - Parameter ownsSocket: Set to  to indicate that the  will take ownership of the ; otherwise, .
    */
    public init(socket : dotnet.System.Net.Sockets.Socket, access : dotnet.System.IO.FileAccess, ownsSocket : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_NetworkStream_ctor_0__3__Socket_FileAccess_bool(&__thrown, socket.get_handle(), access.get_value(), Swift.Int32(ownsSocket ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read from the .

    - Parameter buffer: An array of type  that is the location in memory to store data read from the .
    - Parameter offset: The location in  to begin storing the data.
    - Parameter count: The number of bytes to read from the .
    - Parameter callback: The  delegate that is executed when  completes.
    - Parameter state: An object that contains any additional user-defined data.
    - Returns: An  that represents the asynchronous call.

    */
    open override func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open override func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write to a stream.

    - Parameter buffer: An array of type  that contains the data to write to the .
    - Parameter offset: The location in  to begin sending the data.
    - Parameter count: The number of bytes to write to the .
    - Parameter callback: The  delegate that is executed when  completes.
    - Parameter state: An object that contains any additional user-defined data.
    - Returns: An  that represents the asynchronous call.

    */
    open override func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open override func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, callback: del_callback, state: state);
    }
    // void Close(System.Int32)
// docid: M:System.Net.Sockets.NetworkStream.Close(System.Int32)
    /**
    Closes the  after waiting the specified time to allow data to be sent.

    - Parameter timeout: A 32-bit signed integer that specifies the number of milliseconds to wait to send any remaining data before closing.
    */
    open func Close(timeout : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__Close_0__1__i32(&__thrown, self.get_handle(), timeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
    /**
    Handles the end of an asynchronous read.

    - Parameter asyncResult: An  that represents an asynchronous call.
    - Returns: The number of bytes read from the .

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
    /**
    Handles the end of an asynchronous write.

    - Parameter asyncResult: The  that represents the asynchronous call.
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.Net.Sockets.NetworkStream.Flush
    /**
    Flushes data from the stream. This method is reserved for future use.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Flushes data from the stream as an asynchronous operation.

    - Parameter cancellationToken: A cancellation token used to propagate notification that this  operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads data from the  and stores it to a byte array.

    - Parameter buffer: An array of type  that is the location in memory to store data read from the .
    - Parameter offset: The location in  to begin storing the data to.
    - Parameter count: The number of bytes to read from the .
    - Returns: The number of bytes read from the .

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Read(System.Span<System.Byte>)
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.NetworkStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Reads data from the  and stores it to a specified range of a byte array as an asynchronous operation.

    - Parameter buffer: The buffer to write the data into.
    - Parameter offset: The location in  to begin storing the data to.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Parameter count: The number of bytes to read from the .
    - Returns: A task that represents the asynchronous read operation. The value of its  property contains the total number of bytes read into .

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.NetworkStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Reads data from the  and stores it in a byte memory range as an asynchronous operation.

    - Parameter buffer: The buffer to write the data to.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that represents the asynchronous read operation. The value of its  property contains the total number of bytes read into .

    */
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.Net.Sockets.NetworkStream.ReadByte
    /**
    Reads a byte from the  and advances the position within the stream by one byte, or returns -1 if at the end of the stream.

    - Returns: The unsigned byte cast to an , or -1 if at the end of the stream.

    */
    open override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    Sets the current position of the stream to the given value. This method is not currently supported and always throws a .

    - Parameter offset: This parameter is not used.
    - Parameter origin: This parameter is not used.
    - Returns: The position in the stream.

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.Net.Sockets.NetworkStream.SetLength(System.Int64)
    /**
    Sets the length of the stream. This method always throws a .

    - Parameter value: This parameter is not used.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Writes data to the  from a specified range of a byte array.

    - Parameter buffer: An array of type  that contains the data to write to the .
    - Parameter offset: The location in  from which to start writing data.
    - Parameter count: The number of bytes to write to the .
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Write(System.ReadOnlySpan<System.Byte>)
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.NetworkStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Writes data to the  from the specified range of a byte array as an asynchronous operation.

    - Parameter buffer: A byte array that contains the data to write to the .
    - Parameter offset: The location in  from which to start writing data.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Parameter count: The number of bytes to write to the .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.NetworkStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Writes data to the  from a read-only memory byte memory range as an asynchronous operation.

    - Parameter buffer: A region of memory that contains the data to write to the .
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void WriteByte(System.Byte)
// docid: M:System.Net.Sockets.NetworkStream.WriteByte(System.Byte)
    /**
    Writes a byte to the current position in the  and advances the position within the stream by one byte.

    - Parameter value: The byte to write to the stream.
    */
    open override func WriteByte(value : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__WriteByte_0__1__u8(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.Net.Sockets.NetworkStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.Net.Sockets.NetworkStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanTimeout()
// docid: M:System.Net.Sockets.NetworkStream.get_CanTimeout
    open override func get_CanTimeout() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_bool__get_CanTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.Net.Sockets.NetworkStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_DataAvailable()
// docid: M:System.Net.Sockets.NetworkStream.get_DataAvailable
    open func get_DataAvailable() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_bool__get_DataAvailable_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.Net.Sockets.NetworkStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.Net.Sockets.NetworkStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.Net.Sockets.NetworkStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ReadTimeout()
// docid: M:System.Net.Sockets.NetworkStream.get_ReadTimeout
    open override func get_ReadTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i32__get_ReadTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ReadTimeout(System.Int32)
// docid: M:System.Net.Sockets.NetworkStream.set_ReadTimeout(System.Int32)
    open override func set_ReadTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__set_ReadTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.Socket get_Socket()
// docid: M:System.Net.Sockets.NetworkStream.get_Socket
    open func get_Socket() throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_Socket__get_Socket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_WriteTimeout()
// docid: M:System.Net.Sockets.NetworkStream.get_WriteTimeout
    open override func get_WriteTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_NetworkStream_i32__get_WriteTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_WriteTimeout(System.Int32)
// docid: M:System.Net.Sockets.NetworkStream.set_WriteTimeout(System.Int32)
    open override func set_WriteTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_NetworkStream_void__set_WriteTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a value that indicates whether the  supports reading.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a value that indicates whether the stream supports seeking. This property is not currently supported. This property always returns .

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Indicates whether timeout properties are usable for .

    */
    open override var CanTimeout : Bool {
        get {
            return try! get_CanTimeout();
        }
    }
    /**
    Gets a value that indicates whether the  supports writing.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    Gets a value that indicates whether data is available on the  to be read.

    */
    open var DataAvailable : Bool {
        get {
            return try! get_DataAvailable();
        }
    }
    /**
    Gets the length of the data available on the stream. This property is not currently supported and always throws a .

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets or sets the current position in the stream. This property is not currently supported and always throws a .

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
    /**
    Gets or sets the amount of time that a read operation blocks waiting for data.

    */
    open override var ReadTimeout : Swift.Int32 {
        get {
            return try! get_ReadTimeout();
        }
        set(v) {
            return try! set_ReadTimeout(value: v);
        }
    }
    /**
    Gets the underlying .

    */
    open var Socket : dotnet.System.Net.Sockets.Socket {
        get {
            return try! get_Socket();
        }
    }
    /**
    Gets or sets the amount of time that a write operation blocks waiting for data.

    */
    open override var WriteTimeout : Swift.Int32 {
        get {
            return try! get_WriteTimeout();
        }
        set(v) {
            return try! set_WriteTimeout(value: v);
        }
    }
} // NetworkStream


// type: System.Net.Sockets.ProtocolFamily
    /**
    Specifies the type of protocol that an instance of the  class can use.

    */
public struct ProtocolFamily : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_ProtocolFamily_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.ProtocolFamily Unknown
    /**
    Unknown protocol.

    */
    public static var Unknown : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Unknown());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Unspecified
    /**
    Unspecified protocol.

    */
    public static var Unspecified : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Unspecified());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Unix
    /**
    Unix local to host protocol.

    */
    public static var Unix : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Unix());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily InterNetwork
    /**
    IP version 4 protocol.

    */
    public static var InterNetwork : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_InterNetwork());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily ImpLink
    /**
    ARPANET IMP protocol.

    */
    public static var ImpLink : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_ImpLink());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Pup
    /**
    PUP protocol.

    */
    public static var Pup : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Pup());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Chaos
    /**
    MIT CHAOS protocol.

    */
    public static var Chaos : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Chaos());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Ipx
    /**
    IPX or SPX protocol.

    */
    public static var Ipx : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Ipx());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily NS
    /**
    Xerox NS protocol.

    */
    public static var NS : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_NS());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Iso
    /**
    ISO protocol.

    */
    public static var Iso : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Iso());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Osi
    /**
    OSI protocol.

    */
    public static var Osi : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Osi());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Ecma
    /**
    European Computer Manufacturers Association (ECMA) protocol.

    */
    public static var Ecma : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Ecma());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily DataKit
    /**
    DataKit protocol.

    */
    public static var DataKit : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_DataKit());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Ccitt
    /**
    CCITT protocol, such as X.25.

    */
    public static var Ccitt : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Ccitt());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Sna
    /**
    IBM SNA protocol.

    */
    public static var Sna : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Sna());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily DecNet
    /**
    DECNet protocol.

    */
    public static var DecNet : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_DecNet());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily DataLink
    /**
    Direct data link protocol.

    */
    public static var DataLink : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_DataLink());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Lat
    /**
    LAT protocol.

    */
    public static var Lat : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Lat());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily HyperChannel
    /**
    NSC HyperChannel protocol.

    */
    public static var HyperChannel : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_HyperChannel());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily AppleTalk
    /**
    AppleTalk protocol.

    */
    public static var AppleTalk : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_AppleTalk());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily NetBios
    /**
    NetBIOS protocol.

    */
    public static var NetBios : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_NetBios());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily VoiceView
    /**
    VoiceView protocol.

    */
    public static var VoiceView : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_VoiceView());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily FireFox
    /**
    FireFox protocol.

    */
    public static var FireFox : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_FireFox());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Banyan
    /**
    Banyan protocol.

    */
    public static var Banyan : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Banyan());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Atm
    /**
    Native ATM services protocol.

    */
    public static var Atm : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Atm());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily InterNetworkV6
    /**
    IP version 6 protocol.

    */
    public static var InterNetworkV6 : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_InterNetworkV6());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Cluster
    /**
    Microsoft Cluster products protocol.

    */
    public static var Cluster : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Cluster());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Ieee12844
    /**
    IEEE 1284.4 workgroup protocol.

    */
    public static var Ieee12844 : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Ieee12844());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Irda
    /**
    IrDA protocol.

    */
    public static var Irda : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Irda());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily NetworkDesigners
    /**
    Network Designers OSI gateway enabled protocol.

    */
    public static var NetworkDesigners : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_NetworkDesigners());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Max
    /**
    MAX protocol.

    */
    public static var Max : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Max());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily Packet
    /**
    Low-level Packet protocol.

    */
    public static var Packet : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_Packet());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolFamily ControllerAreaNetwork
    /**
    Controller Area Network protocol.

    */
    public static var ControllerAreaNetwork : dotnet.System.Net.Sockets.ProtocolFamily {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolFamily(val: System_Net_Sockets_ProtocolFamily_get_ControllerAreaNetwork());
            return __return;
        }
    }
} // ProtocolFamily


// type: System.Net.Sockets.ProtocolType
    /**
    Specifies the protocols that the  class supports.

    */
public struct ProtocolType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_ProtocolType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.ProtocolType Unknown
    /**
    Unknown protocol.

    */
    public static var Unknown : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Unknown());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IP
    /**
    Internet Protocol.

    */
    public static var IP : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IP());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPv6HopByHopOptions
    /**
    IPv6 Hop by Hop Options header.

    */
    public static var IPv6HopByHopOptions : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPv6HopByHopOptions());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Unspecified
    /**
    Unspecified protocol.

    */
    public static var Unspecified : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Unspecified());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Icmp
    /**
    Internet Control Message Protocol.

    */
    public static var Icmp : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Icmp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Igmp
    /**
    Internet Group Management Protocol.

    */
    public static var Igmp : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Igmp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Ggp
    /**
    Gateway To Gateway Protocol.

    */
    public static var Ggp : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Ggp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPv4
    /**
    Internet Protocol version 4.

    */
    public static var IPv4 : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPv4());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Tcp
    /**
    Transmission Control Protocol.

    */
    public static var Tcp : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Tcp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Pup
    /**
    PARC Universal Packet Protocol.

    */
    public static var Pup : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Pup());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Udp
    /**
    User Datagram Protocol.

    */
    public static var Udp : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Udp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Idp
    /**
    Internet Datagram Protocol.

    */
    public static var Idp : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Idp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPv6
    /**
    Internet Protocol version 6 (IPv6).

    */
    public static var IPv6 : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPv6());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPv6RoutingHeader
    /**
    IPv6 Routing header.

    */
    public static var IPv6RoutingHeader : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPv6RoutingHeader());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPv6FragmentHeader
    /**
    IPv6 Fragment header.

    */
    public static var IPv6FragmentHeader : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPv6FragmentHeader());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPSecEncapsulatingSecurityPayload
    /**
    IPv6 Encapsulating Security Payload header.

    */
    public static var IPSecEncapsulatingSecurityPayload : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPSecEncapsulatingSecurityPayload());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPSecAuthenticationHeader
    /**
    IPv6 Authentication header. For details, see RFC 2292 section 2.2.1, available at https://www.ietf.org.

    */
    public static var IPSecAuthenticationHeader : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPSecAuthenticationHeader());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IcmpV6
    /**
    Internet Control Message Protocol for IPv6.

    */
    public static var IcmpV6 : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IcmpV6());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPv6NoNextHeader
    /**
    IPv6 No next header.

    */
    public static var IPv6NoNextHeader : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPv6NoNextHeader());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType IPv6DestinationOptions
    /**
    IPv6 Destination Options header.

    */
    public static var IPv6DestinationOptions : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_IPv6DestinationOptions());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType ND
    /**
    Net Disk Protocol (unofficial).

    */
    public static var ND : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_ND());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Raw
    /**
    Raw IP packet protocol.

    */
    public static var Raw : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Raw());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Ipx
    /**
    Internet Packet Exchange Protocol.

    */
    public static var Ipx : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Ipx());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType Spx
    /**
    Sequenced Packet Exchange protocol.

    */
    public static var Spx : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_Spx());
            return __return;
        }
    }
    // static field: System.Net.Sockets.ProtocolType SpxII
    /**
    Sequenced Packet Exchange version 2 protocol.

    */
    public static var SpxII : dotnet.System.Net.Sockets.ProtocolType {
        get {
        let __return = dotnet.System.Net.Sockets.ProtocolType(val: System_Net_Sockets_ProtocolType_get_SpxII());
            return __return;
        }
    }
} // ProtocolType


// type: System.Net.Sockets.SafeSocketHandle
    /**
    Represents a wrapper class for a socket handle.

    */
public final class SafeSocketHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SafeSocketHandle_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_SafeSocketHandle_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Net.Sockets.SafeSocketHandle.#ctor
    /**
    Creates a .

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SafeSocketHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr, bool)
// docid: M:System.Net.Sockets.SafeSocketHandle.#ctor(System.IntPtr,System.Boolean)
    /**
    Initializes a new instance of the  class.

    - Parameter preexistingHandle: The pre-existing handle to use.
    - Parameter ownsHandle: 
         to reliably release the handle during the finalization phase;  to prevent reliable release (not recommended).
    */
    public init(preexistingHandle : dotnet.System.IntPtr, ownsHandle : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SafeSocketHandle_ctor_0__2__IntPtr_bool(&__thrown, preexistingHandle.get_value(), Swift.Int32(ownsHandle ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SafeSocketHandle


// type: System.Net.Sockets.SelectMode
    /**
    Defines the polling modes for the  method.

    */
public struct SelectMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SelectMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SelectMode SelectRead
    /**
    Read status mode.

    */
    public static var SelectRead : dotnet.System.Net.Sockets.SelectMode {
        get {
        let __return = dotnet.System.Net.Sockets.SelectMode(val: System_Net_Sockets_SelectMode_get_SelectRead());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SelectMode SelectWrite
    /**
    Write status mode.

    */
    public static var SelectWrite : dotnet.System.Net.Sockets.SelectMode {
        get {
        let __return = dotnet.System.Net.Sockets.SelectMode(val: System_Net_Sockets_SelectMode_get_SelectWrite());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SelectMode SelectError
    /**
    Error status mode.

    */
    public static var SelectError : dotnet.System.Net.Sockets.SelectMode {
        get {
        let __return = dotnet.System.Net.Sockets.SelectMode(val: System_Net_Sockets_SelectMode_get_SelectError());
            return __return;
        }
    }
} // SelectMode


// type: System.Net.Sockets.SendPacketsElement
    /**
    Represents an element in a  array.

    */
open class SendPacketsElement
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SendPacketsElement_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_SendPacketsElement_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class using the specified buffer.

    - Parameter buffer: A byte array of data to send using the  method.
    */
    public init(buffer : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__1__u8Array(&__thrown, buffer.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.Byte[],System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class using the specified range of the buffer.

    - Parameter buffer: A byte array of data to send using the  method.
    - Parameter offset: The offset, in bytes, from the beginning of the  to the location in the  to start sending the data specified in the  parameter.
    - Parameter count: The number of bytes to send starting from the  parameter. If  is zero, no bytes are sent.
    */
    public init(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__3__u8Array_i32_i32(&__thrown, buffer.get_handle(), offset, count);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Int32, System.Int32, bool)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class using the specified range of the buffer with an option to combine this element with the next element in a single send request from the sockets layer to the transport.

    - Parameter buffer: A byte array of data to send using the  method.
    - Parameter offset: The offset, in bytes, from the beginning of the  to the location in the  to start sending the data specified in the  parameter.
    - Parameter count: The number bytes to send starting from the  parameter. If  is zero, no bytes are sent.
    - Parameter endOfPacket: A Boolean value that specifies that this element should not be combined with the next element in a single send request from the sockets layer to the transport. This flag is used for granular control of the content of each message on a datagram or message-oriented socket.
    */
    public init(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, endOfPacket : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__4__u8Array_i32_i32_bool(&__thrown, buffer.get_handle(), offset, count, Swift.Int32(endOfPacket ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.ReadOnlyMemory<System.Byte>)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.ReadOnlyMemory{System.Byte})
    /**
    Initializes a new instance of the  class using the specified buffer.

    - Parameter buffer: A  of bytes to send using the  method.
    */
    public init(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__1__System_ReadOnlyMemory_u8_(&__thrown, buffer.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.ReadOnlyMemory<System.Byte>, bool)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.ReadOnlyMemory{System.Byte},System.Boolean)
    /**
    Initializes a new instance of the  class using the specified buffer with an option to combine this element with the next element in a single send request from the sockets layer to the transport.

    - Parameter buffer: A  of bytes to send using the  method.
    - Parameter endOfPacket: Specifies that this element should not be combined with the next element in a single send request from the sockets layer to the transport. This flag is used for granular control of the content of each message on a datagram or message-oriented socket.
    */
    public init(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, endOfPacket : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__2__System_ReadOnlyMemory_u8__bool(&__thrown, buffer.get_handle(), Swift.Int32(endOfPacket ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.FileStream)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.IO.FileStream)
    /**
    Initializes a new instance of the  class using the specified  object.

    - Parameter fileStream: The file to be transmitted using the  method.
    */
    public init(fileStream : dotnet.System.IO.FileStream) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__1__FileStream(&__thrown, fileStream.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.FileStream, System.Int64, System.Int32)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.IO.FileStream,System.Int64,System.Int32)
    /**
    Initializes a new instance of the  class using the specified range of a  object.

    - Parameter fileStream: The file to be transmitted using the  method.
    - Parameter offset: The offset, in bytes, from the beginning of the file to the location in the file to start sending the bytes in the file.
    - Parameter count: The number of bytes to send starting from the . If  is zero, the entire file is sent.
    */
    public init(fileStream : dotnet.System.IO.FileStream, offset : Swift.Int64, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__3__FileStream_i64_i32(&__thrown, fileStream.get_handle(), offset, count);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.FileStream, System.Int64, System.Int32, bool)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.IO.FileStream,System.Int64,System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class using the specified range of a  object with an option to combine this element with the next element in a single send request from the sockets layer to the transport.

    - Parameter fileStream: The file to be transmitted using the  method.
    - Parameter offset: TThe offset, in bytes, from the beginning of the file to the location in the file to start sending the bytes in the file.
    - Parameter count: The number of bytes to send starting from the offset parameter. If count is zero, the entire file is sent.
    - Parameter endOfPacket: Specifies that this element should not be combined with the next element in a single send request from the sockets layer to the transport. This flag is used for granular control of the content of each message on a datagram or message-oriented socket.
    */
    public init(fileStream : dotnet.System.IO.FileStream, offset : Swift.Int64, count : Swift.Int32, endOfPacket : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__4__FileStream_i64_i32_bool(&__thrown, fileStream.get_handle(), offset, count, Swift.Int32(endOfPacket ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.String)
    /**
    Initializes a new instance of the  class using the specified file.

    - Parameter filepath: The filename of the file to be transmitted using the  method.
    */
    public init(filepath : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__1__String(&__thrown, filepath.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32, System.Int32)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.String,System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class using the specified range of the file.

    - Parameter filepath: The filename of the file to be transmitted using the  method.
    - Parameter offset: The offset, in bytes, from the beginning of the file to the location in the file to start sending the file specified in the  parameter.
    - Parameter count: The number of bytes to send starting from the  parameter. If  is zero, the entire file is sent.
    */
    public init(filepath : dotnet.System.String, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__3__String_i32_i32(&__thrown, filepath.get_handle(), offset, count);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32, System.Int32, bool)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.String,System.Int32,System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class using the specified range of the file with an option to combine this element with the next element in a single send request from the sockets layer to the transport.

    - Parameter filepath: The filename of the file to be transmitted using the  method.
    - Parameter offset: The offset, in bytes, from the beginning of the file to the location in the file to start sending the file specified in the  parameter.
    - Parameter count: The number of bytes to send starting from the  parameter. If  is zero, the entire file is sent.
    - Parameter endOfPacket: A Boolean value that specifies that this element should not be combined with the next element in a single send request from the sockets layer to the transport. This flag is used for granular control of the content of each message on a datagram or message-oriented socket.
    */
    public init(filepath : dotnet.System.String, offset : Swift.Int32, count : Swift.Int32, endOfPacket : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__4__String_i32_i32_bool(&__thrown, filepath.get_handle(), offset, count, Swift.Int32(endOfPacket ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int64, System.Int32)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.String,System.Int64,System.Int32)
    /**
    Initializes a new instance of the  class using the specified range of the file.

    - Parameter filepath: The filename of the file to be transmitted using the  method.
    - Parameter offset: The offset, in bytes, from the beginning of the file to the location in the file to start sending the file specified in the  parameter.
    - Parameter count: The number of bytes to send starting from the . If  is zero, the entire file is sent.
    */
    public init(filepath : dotnet.System.String, offset : Swift.Int64, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__3__String_i64_i32(&__thrown, filepath.get_handle(), offset, count);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int64, System.Int32, bool)
// docid: M:System.Net.Sockets.SendPacketsElement.#ctor(System.String,System.Int64,System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class using the specified range of the file with an option to combine this element with the next element in a single send request from the sockets layer to the transport.

    - Parameter filepath: The filename of the file to be transmitted using the  method.
    - Parameter offset: The offset, in bytes, from the beginning of the file to the location in the file to start sending the file specified in the  parameter.
    - Parameter count: The number of bytes to send starting from the  parameter. If  is zero, the entire file is sent.
    - Parameter endOfPacket: Specifies that this element should not be combined with the next element in a single send request from the sockets layer to the transport. This flag is used for granular control of the content of each message on a datagram or message-oriented socket.
    */
    public init(filepath : dotnet.System.String, offset : Swift.Int64, count : Swift.Int32, endOfPacket : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SendPacketsElement_ctor_0__4__String_i64_i32_bool(&__thrown, filepath.get_handle(), offset, count, Swift.Int32(endOfPacket ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Byte[] get_Buffer()
// docid: M:System.Net.Sockets.SendPacketsElement.get_Buffer
    open func get_Buffer() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_u8Array__get_Buffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Net.Sockets.SendPacketsElement.get_Count
    open func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_EndOfPacket()
// docid: M:System.Net.Sockets.SendPacketsElement.get_EndOfPacket
    open func get_EndOfPacket() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_bool__get_EndOfPacket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_FilePath()
// docid: M:System.Net.Sockets.SendPacketsElement.get_FilePath
    open func get_FilePath() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_String__get_FilePath_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.IO.FileStream get_FileStream()
// docid: M:System.Net.Sockets.SendPacketsElement.get_FileStream
    open func get_FileStream() throws -> Optional<dotnet.System.IO.FileStream> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_FileStream__get_FileStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IO.FileStream(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Nullable<System.ReadOnlyMemory<System.Byte>> get_MemoryBuffer()
// docid: M:System.Net.Sockets.SendPacketsElement.get_MemoryBuffer
    open func get_MemoryBuffer() throws -> Optional<dotnet.System.ReadOnlyMemory_1<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_System_Nullable_System_System_ReadOnlyMemory_u8____get_MemoryBuffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.ReadOnlyMemory_1(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] System.Int32 get_Offset()
// docid: M:System.Net.Sockets.SendPacketsElement.get_Offset
    open func get_Offset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_i32__get_Offset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_OffsetLong()
// docid: M:System.Net.Sockets.SendPacketsElement.get_OffsetLong
    open func get_OffsetLong() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SendPacketsElement_i64__get_OffsetLong_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the buffer to be sent if the  object was initialized with a  parameter.

    */
    open var Buffer : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_Buffer();
        }
    }
    /**
    Gets the count of bytes to be sent.

    */
    open var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a Boolean value that indicates if this element should not be combined with the next element in a single send request from the sockets layer to the transport.

    */
    open var EndOfPacket : Bool {
        get {
            return try! get_EndOfPacket();
        }
    }
    /**
    Gets the filename of the file to send if the  object was initialized with a  parameter.

    */
    open var FilePath : Optional<dotnet.System.String> {
        get {
            return try! get_FilePath();
        }
    }
    /**
    Gets the object representation of the file to send if the  object was initialized with a  parameter.

    */
    open var FileStream : Optional<dotnet.System.IO.FileStream> {
        get {
            return try! get_FileStream();
        }
    }
    /**
    Gets the buffer to be sent if the  object was initialized with a buffer parameter.

    */
    open var MemoryBuffer : Optional<dotnet.System.ReadOnlyMemory_1<Swift.UInt8>> {
        get {
            return try! get_MemoryBuffer();
        }
    }
    /**
    Gets the offset, in bytes, from the beginning of the data buffer or file to the location in the buffer or file to start sending the data.

    */
    open var Offset : Swift.Int32 {
        get {
            return try! get_Offset();
        }
    }
    /**
    Gets the offset, in bytes, from the beginning of the data buffer or file to the location in the buffer or file to start sending the data.

    */
    open var OffsetLong : Swift.Int64 {
        get {
            return try! get_OffsetLong();
        }
    }
} // SendPacketsElement


// type: System.Net.Sockets.Socket
    /**
    Implements the Berkeley sockets interface.

    */
open class Socket
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_Socket_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_Socket_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Net.Sockets.SafeSocketHandle)
// docid: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SafeSocketHandle)
    /**
    Initializes a new instance of the  class for the specified socket handle.

    - Parameter handle: The socket handle for the socket that the  object will encapsulate.
    */
    public init(handle : dotnet.System.Net.Sockets.SafeSocketHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_Socket_ctor_0__1__SafeSocketHandle(&__thrown, handle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.AddressFamily, System.Net.Sockets.SocketType, System.Net.Sockets.ProtocolType)
// docid: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
    /**
    Initializes a new instance of the  class using the specified address family, socket type and protocol.

    - Parameter addressFamily: One of the  values.
    - Parameter socketType: One of the  values.
    - Parameter protocolType: One of the  values.
    */
    public init(addressFamily : dotnet.System.Net.Sockets.AddressFamily, socketType : dotnet.System.Net.Sockets.SocketType, protocolType : dotnet.System.Net.Sockets.ProtocolType) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_Socket_ctor_0__3__AddressFamily_SocketType_ProtocolType(&__thrown, addressFamily.get_value(), socketType.get_value(), protocolType.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.SocketInformation)
// docid: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)
    /**
    Initializes a new instance of the  class using the specified value returned from .

    - Parameter socketInformation: The socket information returned by .
    */
    public init(socketInformation : dotnet.System.Net.Sockets.SocketInformation) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_Socket_ctor_0__1__SocketInformation(&__thrown, socketInformation.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.SocketType, System.Net.Sockets.ProtocolType)
// docid: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
    /**
    Initializes a new instance of the  class using the specified socket type and protocol. If the operating system supports IPv6, this constructor creates a dual-mode socket; otherwise, it creates an IPv4 socket.

    - Parameter socketType: One of the  values.
    - Parameter protocolType: One of the  values.
    */
    public init(socketType : dotnet.System.Net.Sockets.SocketType, protocolType : dotnet.System.Net.Sockets.ProtocolType) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_Socket_ctor_0__2__SocketType_ProtocolType(&__thrown, socketType.get_value(), protocolType.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Net.Sockets.Socket Accept()
// docid: M:System.Net.Sockets.Socket.Accept
    /**
    Creates a new  for a newly created connection.

    - Returns: A  for a newly created connection.

    */
    open func Accept() throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_Socket__Accept_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptAsync()
// docid: M:System.Net.Sockets.Socket.AcceptAsync
    /**
    Accepts an incoming connection.

    - Returns: An asynchronous task that completes with the accepted Socket.

    */
    open func AcceptAsync() async throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_System_Net_Sockets_Socket___AcceptAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Sockets.Socket> AcceptAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.AcceptAsync(System.Threading.CancellationToken)
    /**
    Accepts an incoming connection.

    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes with the accepted Socket.

    */
    open func AcceptAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Sockets.Socket> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_ValueTask_System_Net_Sockets_Socket___AcceptAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptAsync(System.Net.Sockets.Socket)
// docid: M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.Socket)
    /**
    Accepts an incoming connection.

    - Parameter acceptSocket: The socket to use for accepting the connection.
    - Returns: An asynchronous task that completes with the accepted Socket.

    */
    open func AcceptAsync(acceptSocket : Optional<dotnet.System.Net.Sockets.Socket>) async throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_System_Net_Sockets_Socket___AcceptAsync_0__1__Socket(&__thrown, self.get_handle(), acceptSocket?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Sockets.Socket> AcceptAsync(System.Net.Sockets.Socket, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.Socket,System.Threading.CancellationToken)
    /**
    Accepts an incoming connection.

    - Parameter acceptSocket: The socket to use for accepting the connection.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes with the accepted Socket.

    */
    open func AcceptAsync(acceptSocket : Optional<dotnet.System.Net.Sockets.Socket>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Sockets.Socket> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_ValueTask_System_Net_Sockets_Socket___AcceptAsync_0__2__Socket_CancellationToken(&__thrown, self.get_handle(), acceptSocket?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Begins an asynchronous operation to accept an incoming connection attempt.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func AcceptAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__AcceptAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.IAsyncResult BeginAccept(System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous operation to accept an incoming connection attempt.

    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous  creation.

    */
    open func BeginAccept(callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginAccept_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAccept(callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginAccept(callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginAccept(System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.

    - Parameter receiveSize: The number of bytes to accept from the sender.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous  creation.

    */
    open func BeginAccept(receiveSize : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginAccept_0__3__i32_AsyncCallback_Object(&__thrown, self.get_handle(), receiveSize, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAccept(receiveSize : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginAccept(receiveSize: receiveSize, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginAccept(System.Net.Sockets.Socket, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.

    - Parameter acceptSocket: The accepted  object. This value may be .
    - Parameter receiveSize: The maximum number of bytes to receive.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  object that references the asynchronous  object creation.

    */
    open func BeginAccept(acceptSocket : Optional<dotnet.System.Net.Sockets.Socket>, receiveSize : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginAccept_0__4__Socket_i32_AsyncCallback_Object(&__thrown, self.get_handle(), acceptSocket?.get_handle() ?? nil, receiveSize, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAccept(acceptSocket : Optional<dotnet.System.Net.Sockets.Socket>, receiveSize : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginAccept(acceptSocket: acceptSocket, receiveSize: receiveSize, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginConnect(System.Net.EndPoint, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request for a remote host connection.

    - Parameter remoteEP: An  that represents the remote host.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous connection.

    */
    open func BeginConnect(remoteEP : dotnet.System.Net.EndPoint, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginConnect_0__3__EndPoint_AsyncCallback_Object(&__thrown, self.get_handle(), remoteEP.get_handle(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginConnect(remoteEP : dotnet.System.Net.EndPoint, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginConnect(remoteEP: remoteEP, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginConnect(System.Net.IPAddress, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request for a remote host connection. The host is specified by an  and a port number.

    - Parameter address: The  of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter requestCallback: An  delegate that references the method to invoke when the connect operation is complete.
    - Parameter state: A user-defined object that contains information about the connect operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous connection.

    */
    open func BeginConnect(address : dotnet.System.Net.IPAddress, port : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginConnect_0__4__IPAddress_i32_AsyncCallback_Object(&__thrown, self.get_handle(), address.get_handle(), port, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginConnect(address : dotnet.System.Net.IPAddress, port : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginConnect(address: address, port: port, requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginConnect(System.Net.IPAddress[], System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request for a remote host connection. The host is specified by an  array and a port number.

    - Parameter addresses: At least one , designating the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter requestCallback: An  delegate that references the method to invoke when the connect operation is complete.
    - Parameter state: A user-defined object that contains information about the connect operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous connections.

    */
    open func BeginConnect(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginConnect_0__4__IPAddressArray_i32_AsyncCallback_Object(&__thrown, self.get_handle(), addresses.get_handle(), port, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginConnect(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginConnect(addresses: addresses, port: port, requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginConnect(System.String, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.

    - Parameter host: The name of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter requestCallback: An  delegate that references the method to invoke when the connect operation is complete.
    - Parameter state: A user-defined object that contains information about the connect operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous connection.

    */
    open func BeginConnect(host : dotnet.System.String, port : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginConnect_0__4__String_i32_AsyncCallback_Object(&__thrown, self.get_handle(), host.get_handle(), port, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginConnect(host : dotnet.System.String, port : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginConnect(host: host, port: port, requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginDisconnect(bool, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request to disconnect from a remote endpoint.

    - Parameter reuseSocket: 
         if this socket can be reused after the connection is closed; otherwise, .
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  object that references the asynchronous operation.

    */
    open func BeginDisconnect(reuseSocket : Bool, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginDisconnect_0__3__bool_AsyncCallback_Object(&__thrown, self.get_handle(), Swift.Int32(reuseSocket ? 1 : 0), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginDisconnect(reuseSocket : Bool, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginDisconnect(reuseSocket: reuseSocket, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginReceive(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
    /**
    Begins to asynchronously receive data from a connected .

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter offset: The zero-based position in the  parameter at which to store the received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter callback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the receive operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous read.

    */
    open func BeginReceive(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginReceive_0__6__u8Array_i32_i32_SocketFlags_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginReceive(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginReceive(buffer: buffer, offset: offset, size: size, socketFlags: socketFlags, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginReceive(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)
    /**
    Begins to asynchronously receive data from a connected .

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter offset: The location in  to store the received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Parameter callback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the receive operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous read.

    */
    open func BeginReceive(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginReceive_0__7__u8Array_i32_i32_SocketFlags_outSocketError_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), &_tmp_out_errorCode, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open func BeginReceive(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginReceive(buffer: buffer, offset: offset, size: size, socketFlags: socketFlags, errorCode: &errorCode, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginReceive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
    /**
    Begins to asynchronously receive data from a connected .

    - Parameter buffers: An array of type  that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter callback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the receive operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous read.

    */
    open func BeginReceive(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginReceive_0__4__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags_AsyncCallback_Object(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginReceive(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginReceive(buffers: buffers, socketFlags: socketFlags, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginReceive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)
    /**
    Begins to asynchronously receive data from a connected .

    - Parameter buffers: An array of type  that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Parameter callback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the receive operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous read.

    */
    open func BeginReceive(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginReceive_0__5__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags_outSocketError_AsyncCallback_Object(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value(), &_tmp_out_errorCode, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open func BeginReceive(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginReceive(buffers: buffers, socketFlags: socketFlags, errorCode: &errorCode, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginReceiveFrom(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.EndPoint, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)
    /**
    Begins to asynchronously receive data from a specified network device.

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter offset: The zero-based position in the  parameter at which to store the data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An  that represents the source of the data.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous read.

    */
    open func BeginReceiveFrom(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = remoteEP.get_handle();
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginReceiveFrom_0__7__u8Array_i32_i32_SocketFlags_refEndPoint_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), &_tmp_ref_remoteEP, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        let _tmp2_remoteEP = dotnet.System.Net.EndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginReceiveFrom(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginReceiveFrom(buffer: buffer, offset: offset, size: size, socketFlags: socketFlags, remoteEP: &remoteEP, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginReceiveMessageFrom(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.EndPoint, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)
    /**
    Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified , and stores the endpoint and packet information.

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter offset: The zero-based position in the  parameter at which to store the data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An  that represents the source of the data.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous read.

    */
    open func BeginReceiveMessageFrom(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = remoteEP.get_handle();
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginReceiveMessageFrom_0__7__u8Array_i32_i32_SocketFlags_refEndPoint_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), &_tmp_ref_remoteEP, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        let _tmp2_remoteEP = dotnet.System.Net.EndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginReceiveMessageFrom(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginReceiveMessageFrom(buffer: buffer, offset: offset, size: size, socketFlags: socketFlags, remoteEP: &remoteEP, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginSend(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
    /**
    Sends data asynchronously to a connected .

    - Parameter buffer: An array of type  that contains the data to send.
    - Parameter offset: The zero-based position in the  parameter at which to begin sending data.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous send.

    */
    open func BeginSend(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginSend_0__6__u8Array_i32_i32_SocketFlags_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSend(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginSend(buffer: buffer, offset: offset, size: size, socketFlags: socketFlags, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginSend(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)
    /**
    Sends data asynchronously to a connected .

    - Parameter buffer: An array of type  that contains the data to send.
    - Parameter offset: The zero-based position in the  parameter at which to begin sending data.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous send.

    */
    open func BeginSend(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginSend_0__7__u8Array_i32_i32_SocketFlags_outSocketError_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), &_tmp_out_errorCode, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open func BeginSend(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginSend(buffer: buffer, offset: offset, size: size, socketFlags: socketFlags, errorCode: &errorCode, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginSend(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
    /**
    Sends data asynchronously to a connected .

    - Parameter buffers: An array of type  that contains the data to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous send.

    */
    open func BeginSend(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginSend_0__4__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags_AsyncCallback_Object(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSend(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginSend(buffers: buffers, socketFlags: socketFlags, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginSend(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)
    /**
    Sends data asynchronously to a connected .

    - Parameter buffers: An array of type  that contains the data to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous send.

    */
    open func BeginSend(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginSend_0__5__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags_outSocketError_AsyncCallback_Object(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value(), &_tmp_out_errorCode, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open func BeginSend(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginSend(buffers: buffers, socketFlags: socketFlags, errorCode: &errorCode, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginSendFile(System.String, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)
    /**
    Sends the file  to a connected  object using the  flag.

    - Parameter fileName: A string that contains the path and name of the file to send. This parameter can be .
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  object that represents the asynchronous send.

    */
    open func BeginSendFile(fileName : Optional<dotnet.System.String>, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginSendFile_0__3__String_AsyncCallback_Object(&__thrown, self.get_handle(), fileName?.get_handle() ?? nil, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSendFile(fileName : Optional<dotnet.System.String>, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginSendFile(fileName: fileName, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginSendFile(System.String, System.Byte[], System.Byte[], System.Net.Sockets.TransmitFileOptions, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)
    /**
    Sends a file and buffers of data asynchronously to a connected  object.

    - Parameter fileName: A string that contains the path and name of the file to be sent. This parameter can be .
    - Parameter preBuffer: The data to be sent before the file is sent. This parameter can be .
    - Parameter postBuffer: The data to be sent after the file is sent. This parameter can be .
    - Parameter flags: A bitwise combination of the enumeration values.
    - Parameter callback: An  delegate to be invoked when this operation completes. This parameter can be .
    - Parameter state: A user-defined object that contains state information for this request. This parameter can be .
    - Returns: An  object that represents the asynchronous operation.

    */
    open func BeginSendFile(fileName : Optional<dotnet.System.String>, preBuffer : Optional<dotnet.System_Arr<Swift.UInt8>>, postBuffer : Optional<dotnet.System_Arr<Swift.UInt8>>, flags : dotnet.System.Net.Sockets.TransmitFileOptions, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginSendFile_0__6__String_u8Array_u8Array_TransmitFileOptions_AsyncCallback_Object(&__thrown, self.get_handle(), fileName?.get_handle() ?? nil, (preBuffer?.get_handle()), (postBuffer?.get_handle()), flags.get_value(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSendFile(fileName : Optional<dotnet.System.String>, preBuffer : Optional<dotnet.System_Arr<Swift.UInt8>>, postBuffer : Optional<dotnet.System_Arr<Swift.UInt8>>, flags : dotnet.System.Net.Sockets.TransmitFileOptions, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginSendFile(fileName: fileName, preBuffer: preBuffer, postBuffer: postBuffer, flags: flags, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginSendTo(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)
    /**
    Sends data asynchronously to a specific remote host.

    - Parameter buffer: An array of type  that contains the data to send.
    - Parameter offset: The zero-based position in  at which to begin sending data.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An  that represents the remote device.
    - Parameter callback: The  delegate.
    - Parameter state: An object that contains state information for this request.
    - Returns: An  that references the asynchronous send.

    */
    open func BeginSendTo(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IAsyncResult__BeginSendTo_0__7__u8Array_i32_i32_SocketFlags_EndPoint_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), remoteEP.get_handle(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSendTo(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginSendTo(buffer: buffer, offset: offset, size: size, socketFlags: socketFlags, remoteEP: remoteEP, callback: del_callback, state: state);
    }
    // void Bind(System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    /**
    Associates a  with a local endpoint.

    - Parameter localEP: The local  to associate with the .
    */
    open func Bind(localEP : dotnet.System.Net.EndPoint) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Bind_0__1__EndPoint(&__thrown, self.get_handle(), localEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Cancels an asynchronous request for a remote host connection.

    - Parameter e: The  object used to request the connection to the remote host by calling one of the  methods.
    */
    open class func CancelConnectAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__CancelConnectAsync_0__1__SocketAsyncEventArgs(&__thrown, e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Close()
// docid: M:System.Net.Sockets.Socket.Close
    /**
    Closes the  connection and releases all associated resources.

    */
    open func Close() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Close_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Close(System.Int32)
// docid: M:System.Net.Sockets.Socket.Close(System.Int32)
    /**
    Closes the  connection and releases all associated resources with a specified timeout to allow queued data to be sent.

    - Parameter timeout: Wait up to  seconds to send any remaining data, then close the socket.
    */
    open func Close(timeout : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Close_0__1__i32(&__thrown, self.get_handle(), timeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    /**
    Establishes a connection to a remote host.

    - Parameter remoteEP: An  that represents the remote device.
    */
    open func Connect(remoteEP : dotnet.System.Net.EndPoint) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Connect_0__1__EndPoint(&__thrown, self.get_handle(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)
    /**
    Establishes a connection to a remote host. The host is specified by an IP address and a port number.

    - Parameter address: The IP address of the remote host.
    - Parameter port: The port number of the remote host.
    */
    open func Connect(address : dotnet.System.Net.IPAddress, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Connect_0__2__IPAddress_i32(&__thrown, self.get_handle(), address.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.IPAddress[], System.Int32)
// docid: M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)
    /**
    Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.

    - Parameter addresses: The IP addresses of the remote host.
    - Parameter port: The port number of the remote host.
    */
    open func Connect(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Connect_0__2__IPAddressArray_i32(&__thrown, self.get_handle(), addresses.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.String, System.Int32)
// docid: M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)
    /**
    Establishes a connection to a remote host. The host is specified by a host name and a port number.

    - Parameter host: The name of the remote host.
    - Parameter port: The port number of the remote host.
    */
    open func Connect(host : dotnet.System.String, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Connect_0__2__String_i32(&__thrown, self.get_handle(), host.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.EndPoint)
    /**
    Establishes a connection to a remote host.

    - Parameter remoteEP: The endpoint to connect to.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(remoteEP : dotnet.System.Net.EndPoint) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_Task__ConnectAsync_0__1__EndPoint(&__thrown, self.get_handle(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.EndPoint,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host.

    - Parameter remoteEP: The endpoint to connect to.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(remoteEP : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ValueTask__ConnectAsync_0__2__EndPoint_CancellationToken(&__thrown, self.get_handle(), remoteEP.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.IPAddress,System.Int32)
    /**
    Establishes a connection to a remote host.

    - Parameter address: The IPAddress of the remote host to connect to.
    - Parameter port: The port on the remote host to connect to.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(address : dotnet.System.Net.IPAddress, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_Task__ConnectAsync_0__2__IPAddress_i32(&__thrown, self.get_handle(), address.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.IPAddress, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.IPAddress,System.Int32,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host.

    - Parameter address: The IPAddress of the remote host to connect to.
    - Parameter port: The port on the remote host to connect to.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(address : dotnet.System.Net.IPAddress, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ValueTask__ConnectAsync_0__3__IPAddress_i32_CancellationToken(&__thrown, self.get_handle(), address.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.IPAddress[], System.Int32)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.IPAddress[],System.Int32)
    /**
    Establishes a connection to a remote host.

    - Parameter addresses: A list of IPAddresses for the remote host that will be used to attempt to connect to the remote host.
    - Parameter port: The port on the remote host to connect to.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_Task__ConnectAsync_0__2__IPAddressArray_i32(&__thrown, self.get_handle(), addresses.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.IPAddress[], System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.IPAddress[],System.Int32,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host.

    - Parameter addresses: A list of IPAddresses for the remote host that will be used to attempt to connect to the remote host.
    - Parameter port: The port on the remote host to connect to.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ValueTask__ConnectAsync_0__3__IPAddressArray_i32_CancellationToken(&__thrown, self.get_handle(), addresses.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.String, System.Int32)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.String,System.Int32)
    /**
    Establishes a connection to a remote host.

    - Parameter host: The hostname of the remote host to connect to.
    - Parameter port: The port on the remote host to connect to.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(host : dotnet.System.String, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_Task__ConnectAsync_0__2__String_i32(&__thrown, self.get_handle(), host.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.String, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.String,System.Int32,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host.

    - Parameter host: The hostname of the remote host to connect to.
    - Parameter port: The port on the remote host to connect to.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes when the connection is established.

    */
    open func ConnectAsync(host : dotnet.System.String, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ValueTask__ConnectAsync_0__3__String_i32_CancellationToken(&__thrown, self.get_handle(), host.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // bool ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Begins an asynchronous request for a connection to a remote host.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func ConnectAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__ConnectAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool ConnectAsync(System.Net.Sockets.SocketType, System.Net.Sockets.ProtocolType, System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Begins an asynchronous request for a connection to a remote host.

    - Parameter socketType: One of the  values.
    - Parameter protocolType: One of the  values.
    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open class func ConnectAsync(socketType : dotnet.System.Net.Sockets.SocketType, protocolType : dotnet.System.Net.Sockets.ProtocolType, e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__ConnectAsync_0__3__SocketType_ProtocolType_SocketAsyncEventArgs(&__thrown, socketType.get_value(), protocolType.get_value(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Disconnect(bool)
// docid: M:System.Net.Sockets.Socket.Disconnect(System.Boolean)
    /**
    Closes the socket connection and allows reuse of the socket.

    - Parameter reuseSocket: 
         if this socket can be reused after the current connection is closed; otherwise, .
    */
    open func Disconnect(reuseSocket : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Disconnect_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(reuseSocket ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Begins an asynchronous request to disconnect from a remote endpoint.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func DisconnectAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__DisconnectAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Threading.Tasks.ValueTask DisconnectAsync(bool, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.DisconnectAsync(System.Boolean,System.Threading.CancellationToken)
    /**
    Disconnects a connected socket from the remote host.

    - Parameter reuseSocket: Indicates whether the socket should be available for reuse after disconnect.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes when the socket is disconnected.

    */
    open func DisconnectAsync(reuseSocket : Bool, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ValueTask__DisconnectAsync_0__2__bool_CancellationToken(&__thrown, self.get_handle(), Swift.Int32(reuseSocket ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Net.Sockets.Socket.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Net.Sockets.SocketInformation DuplicateAndClose(System.Int32)
// docid: M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)
    /**
    Duplicates the socket reference for the target process, and closes the socket for this process.

    - Parameter targetProcessId: The ID of the target process where a duplicate of the socket reference is created.
    - Returns: The socket reference to be passed to the target process.

    */
    open func DuplicateAndClose(targetProcessId : Swift.Int32) throws -> dotnet.System.Net.Sockets.SocketInformation {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_SocketInformation__DuplicateAndClose_0__1__i32(&__thrown, self.get_handle(), targetProcessId);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SocketInformation(hndl : __return);
        }
    }
    // System.Net.Sockets.Socket EndAccept(ref System.Byte[], System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)
    /**
    Asynchronously accepts an incoming connection attempt and creates a new  object to handle remote host communication. This method returns a buffer that contains the initial data transferred.

    - Parameter buffer: An array of type  that contains the bytes transferred.
    - Parameter asyncResult: An  object that stores state information for this asynchronous operation as well as any user defined data.
    - Returns: A  object to handle communication with the remote host.

    */
    open func EndAccept(buffer : inout dotnet.System_Arr<Swift.UInt8>, asyncResult : dotnet.System.IAsyncResult) throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
            var _tmp_out_buffer = buffer.get_handle();
        let __return = System_Net_Sockets_Socket_Socket__EndAccept_0__2__outu8Array_IAsyncResult(&__thrown, self.get_handle(), &_tmp_out_buffer, asyncResult.get_handle());
        let _tmp2_buffer = dotnet.System_Arr<Swift.UInt8>(hndl: _tmp_out_buffer);
            buffer = _tmp2_buffer;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // System.Net.Sockets.Socket EndAccept(ref System.Byte[], ref System.Int32, System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)
    /**
    Asynchronously accepts an incoming connection attempt and creates a new  object to handle remote host communication. This method returns a buffer that contains the initial data and the number of bytes transferred.

    - Parameter buffer: An array of type  that contains the bytes transferred.
    - Parameter bytesTransferred: The number of bytes transferred.
    - Parameter asyncResult: An  object that stores state information for this asynchronous operation as well as any user defined data.
    - Returns: A  object to handle communication with the remote host.

    */
    open func EndAccept(buffer : inout dotnet.System_Arr<Swift.UInt8>, bytesTransferred : inout Swift.Int32, asyncResult : dotnet.System.IAsyncResult) throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
            var _tmp_out_buffer = buffer.get_handle();
            var _tmp_out_bytesTransferred = bytesTransferred;
        let __return = System_Net_Sockets_Socket_Socket__EndAccept_0__3__outu8Array_outi32_IAsyncResult(&__thrown, self.get_handle(), &_tmp_out_buffer, &_tmp_out_bytesTransferred, asyncResult.get_handle());
        let _tmp2_buffer = dotnet.System_Arr<Swift.UInt8>(hndl: _tmp_out_buffer);
            buffer = _tmp2_buffer;
        let _tmp2_bytesTransferred = _tmp_out_bytesTransferred;
            bytesTransferred = _tmp2_bytesTransferred;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // System.Net.Sockets.Socket EndAccept(System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)
    /**
    Asynchronously accepts an incoming connection attempt and creates a new  to handle remote host communication.

    - Parameter asyncResult: An  that stores state information for this asynchronous operation as well as any user defined data.
    - Returns: A  to handle communication with the remote host.

    */
    open func EndAccept(asyncResult : dotnet.System.IAsyncResult) throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_Socket__EndAccept_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // void EndConnect(System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)
    /**
    Ends a pending asynchronous connection request.

    - Parameter asyncResult: An  that stores state information and any user defined data for this asynchronous operation.
    */
    open func EndConnect(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__EndConnect_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EndDisconnect(System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)
    /**
    Ends a pending asynchronous disconnect request.

    - Parameter asyncResult: An  object that stores state information and any user-defined data for this asynchronous operation.
    */
    open func EndDisconnect(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__EndDisconnect_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 EndReceive(System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
    /**
    Ends a pending asynchronous read.

    - Parameter asyncResult: An  that stores state information and any user defined data for this asynchronous operation.
    - Returns: The number of bytes received.

    */
    open func EndReceive(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__EndReceive_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 EndReceive(System.IAsyncResult, ref System.Net.Sockets.SocketError)
// docid: M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)
    /**
    Ends a pending asynchronous read.

    - Parameter asyncResult: An  that stores state information and any user defined data for this asynchronous operation.
    - Parameter errorCode: A  object that stores the socket error.
    - Returns: The number of bytes received.

    */
    open func EndReceive(asyncResult : dotnet.System.IAsyncResult, errorCode : inout dotnet.System.Net.Sockets.SocketError) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_i32__EndReceive_0__2__IAsyncResult_outSocketError(&__thrown, self.get_handle(), asyncResult.get_handle(), &_tmp_out_errorCode);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 EndReceiveFrom(System.IAsyncResult, ref System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)
    /**
    Ends a pending asynchronous read from a specific endpoint.

    - Parameter asyncResult: An  that stores state information and any user defined data for this asynchronous operation.
    - Parameter endPoint: The source .
    - Returns: If successful, the number of bytes received. If unsuccessful, returns 0.

    */
    open func EndReceiveFrom(asyncResult : dotnet.System.IAsyncResult, endPoint : inout dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_endPoint = endPoint.get_handle();
        let __return = System_Net_Sockets_Socket_i32__EndReceiveFrom_0__2__IAsyncResult_refEndPoint(&__thrown, self.get_handle(), asyncResult.get_handle(), &_tmp_ref_endPoint);
        let _tmp2_endPoint = dotnet.System.Net.EndPoint(hndl: _tmp_ref_endPoint);
            endPoint = _tmp2_endPoint;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 EndReceiveMessageFrom(System.IAsyncResult, ref System.Net.Sockets.SocketFlags, ref System.Net.EndPoint, ref System.Net.Sockets.IPPacketInformation)
// docid: M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)
    /**
    Ends a pending asynchronous read from a specific endpoint. This method also reveals more information about the packet than .

    - Parameter asyncResult: An  that stores state information and any user defined data for this asynchronous operation.
    - Parameter socketFlags: A bitwise combination of the  values for the received packet.
    - Parameter endPoint: The source .
    - Parameter ipPacketInformation: The  and interface of the received packet.
    - Returns: If successful, the number of bytes received. If unsuccessful, returns 0.

    */
    open func EndReceiveMessageFrom(asyncResult : dotnet.System.IAsyncResult, socketFlags : inout dotnet.System.Net.Sockets.SocketFlags, endPoint : inout dotnet.System.Net.EndPoint, ipPacketInformation : inout dotnet.System.Net.Sockets.IPPacketInformation) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_socketFlags = socketFlags.get_value();
            var _tmp_ref_endPoint = endPoint.get_handle();
            var _tmp_out_ipPacketInformation = ipPacketInformation.get_handle();
        let __return = System_Net_Sockets_Socket_i32__EndReceiveMessageFrom_0__4__IAsyncResult_refSocketFlags_refEndPoint_outIPPacketInformation(&__thrown, self.get_handle(), asyncResult.get_handle(), &_tmp_ref_socketFlags, &_tmp_ref_endPoint, &_tmp_out_ipPacketInformation);
        let _tmp2_socketFlags = dotnet.System.Net.Sockets.SocketFlags(val: _tmp_ref_socketFlags);
            socketFlags = _tmp2_socketFlags;
        let _tmp2_endPoint = dotnet.System.Net.EndPoint(hndl: _tmp_ref_endPoint);
            endPoint = _tmp2_endPoint;
        let _tmp2_ipPacketInformation = dotnet.System.Net.Sockets.IPPacketInformation(hndl: _tmp_out_ipPacketInformation);
            ipPacketInformation = _tmp2_ipPacketInformation;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 EndSend(System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)
    /**
    Ends a pending asynchronous send.

    - Parameter asyncResult: An  that stores state information for this asynchronous operation.
    - Returns: If successful, the number of bytes sent to the ; otherwise, an invalid  error.

    */
    open func EndSend(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__EndSend_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 EndSend(System.IAsyncResult, ref System.Net.Sockets.SocketError)
// docid: M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)
    /**
    Ends a pending asynchronous send.

    - Parameter asyncResult: An  that stores state information for this asynchronous operation.
    - Parameter errorCode: A  object that stores the socket error.
    - Returns: If successful, the number of bytes sent to the ; otherwise, an invalid  error.

    */
    open func EndSend(asyncResult : dotnet.System.IAsyncResult, errorCode : inout dotnet.System.Net.Sockets.SocketError) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_i32__EndSend_0__2__IAsyncResult_outSocketError(&__thrown, self.get_handle(), asyncResult.get_handle(), &_tmp_out_errorCode);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndSendFile(System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)
    /**
    Ends a pending asynchronous send of a file.

    - Parameter asyncResult: An  object that stores state information for this asynchronous operation.
    */
    open func EndSendFile(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__EndSendFile_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 EndSendTo(System.IAsyncResult)
// docid: M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)
    /**
    Ends a pending asynchronous send to a specific location.

    - Parameter asyncResult: An  that stores state information and any user defined data for this asynchronous operation.
    - Returns: If successful, the number of bytes sent; otherwise, an invalid  error.

    */
    open func EndSendTo(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__EndSendTo_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 GetRawSocketOption(System.Int32, System.Int32, System.Span<System.Byte>)
    // System.Object GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName)
// docid: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
    /**
    Returns the value of a specified  option, represented as an object.

    - Parameter optionLevel: One of the  values.
    - Parameter optionName: One of the  values.
    - Returns: An object that represents the value of the option. When the  parameter is set to  the return value is an instance of the  class. When  is set to  or , the return value is an instance of the  class. When  is any other value, the return value is an integer.

    */
    open func GetSocketOption(optionLevel : dotnet.System.Net.Sockets.SocketOptionLevel, optionName : dotnet.System.Net.Sockets.SocketOptionName) throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_Object__GetSocketOption_0__2__SocketOptionLevel_SocketOptionName(&__thrown, self.get_handle(), optionLevel.get_value(), optionName.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Byte[])
// docid: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
    /**
    Returns the specified  option setting, represented as a byte array.

    - Parameter optionLevel: One of the  values.
    - Parameter optionName: One of the  values.
    - Parameter optionValue: An array of type  that is to receive the option setting.
    */
    open func GetSocketOption(optionLevel : dotnet.System.Net.Sockets.SocketOptionLevel, optionName : dotnet.System.Net.Sockets.SocketOptionName, optionValue : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__GetSocketOption_0__3__SocketOptionLevel_SocketOptionName_u8Array(&__thrown, self.get_handle(), optionLevel.get_value(), optionName.get_value(), optionValue.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Int32)
// docid: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    /**
    Returns the value of the specified  option in an array.

    - Parameter optionLevel: One of the  values.
    - Parameter optionName: One of the  values.
    - Parameter optionLength: The length, in bytes, of the expected return value.
    - Returns: An array of type  that contains the value of the socket option.

    */
    open func GetSocketOption(optionLevel : dotnet.System.Net.Sockets.SocketOptionLevel, optionName : dotnet.System.Net.Sockets.SocketOptionName, optionLength : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_u8Array__GetSocketOption_0__3__SocketOptionLevel_SocketOptionName_i32(&__thrown, self.get_handle(), optionLevel.get_value(), optionName.get_value(), optionLength);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Int32 IOControl(System.Int32, System.Byte[], System.Byte[])
// docid: M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])
    /**
    Sets low-level operating modes for the  using numerical control codes.

    - Parameter ioControlCode: An  value that specifies the control code of the operation to perform.
    - Parameter optionInValue: A  array that contains the input data required by the operation.
    - Parameter optionOutValue: A  array that contains the output data returned by the operation.
    - Returns: The number of bytes in the  parameter.

    */
    open func IOControl(ioControlCode : Swift.Int32, optionInValue : Optional<dotnet.System_Arr<Swift.UInt8>>, optionOutValue : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__IOControl_0__3__i32_u8Array_u8Array(&__thrown, self.get_handle(), ioControlCode, (optionInValue?.get_handle()), (optionOutValue?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 IOControl(System.Net.Sockets.IOControlCode, System.Byte[], System.Byte[])
// docid: M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])
    /**
    Sets low-level operating modes for the  using the  enumeration to specify control codes.

    - Parameter ioControlCode: A  value that specifies the control code of the operation to perform.
    - Parameter optionInValue: An array of type  that contains the input data required by the operation.
    - Parameter optionOutValue: An array of type  that contains the output data returned by the operation.
    - Returns: The number of bytes in the  parameter.

    */
    open func IOControl(ioControlCode : dotnet.System.Net.Sockets.IOControlCode, optionInValue : Optional<dotnet.System_Arr<Swift.UInt8>>, optionOutValue : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__IOControl_0__3__IOControlCode_u8Array_u8Array(&__thrown, self.get_handle(), ioControlCode.get_value(), (optionInValue?.get_handle()), (optionOutValue?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void Listen()
// docid: M:System.Net.Sockets.Socket.Listen
    /**
    Places a  in a listening state.

    */
    open func Listen() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Listen_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Listen(System.Int32)
// docid: M:System.Net.Sockets.Socket.Listen(System.Int32)
    /**
    Places a  in a listening state.

    - Parameter backlog: The maximum length of the pending connections queue.
    */
    open func Listen(backlog : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Listen_0__1__i32(&__thrown, self.get_handle(), backlog);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Poll(System.Int32, System.Net.Sockets.SelectMode)
// docid: M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
    /**
    Determines the status of the .

    - Parameter microSeconds: The time to wait for a response, in microseconds.
    - Parameter mode: One of the  values.
    - Returns: The status of the  based on the polling mode value passed in the  parameter.

  Mode Return Value if  has been called and a connection is pending;

 -or-

  if data is available for reading;

 -or-

  if the connection has been closed, reset, or terminated;

 otherwise, returns ., if processing a , and the connection has succeeded;

 -or-

  if data can be sent;

 otherwise, returns . if processing a  that does not block, and the connection has failed;

 -or-

  if  is not set and out-of-band data is available;

 otherwise, returns .

    */
    open func Poll(microSeconds : Swift.Int32, mode : dotnet.System.Net.Sockets.SelectMode) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__Poll_0__2__i32_SelectMode(&__thrown, self.get_handle(), microSeconds, mode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 Receive(System.Byte[])
// docid: M:System.Net.Sockets.Socket.Receive(System.Byte[])
    /**
    Receives data from a bound  into a receive buffer.

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Returns: The number of bytes received.

    */
    open func Receive(buffer : dotnet.System_Arr<Swift.UInt8>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Receive_0__1__u8Array(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Receive(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
    /**
    Receives the specified number of bytes from a bound  into the specified offset position of the receive buffer, using the specified .

    - Parameter buffer: An array of type  that is the storage location for received data.
    - Parameter offset: The location in  to store the received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes received.

    */
    open func Receive(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Receive_0__4__u8Array_i32_i32_SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Receive(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError)
// docid: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
    /**
    Receives data from a bound  into a receive buffer, using the specified .

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter offset: The position in the  parameter to store the received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Returns: The number of bytes received.

    */
    open func Receive(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_i32__Receive_0__5__u8Array_i32_i32_SocketFlags_outSocketError(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), &_tmp_out_errorCode);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Receive(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    /**
    Receives the specified number of bytes of data from a bound  into a receive buffer, using the specified .

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes received.

    */
    open func Receive(buffer : dotnet.System_Arr<Swift.UInt8>, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Receive_0__3__u8Array_i32_SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), size, socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Receive(System.Byte[], System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)
    /**
    Receives data from a bound  into a receive buffer, using the specified .

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes received.

    */
    open func Receive(buffer : dotnet.System_Arr<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Receive_0__2__u8Array_SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Receive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>)
// docid: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
    /**
    Receives data from a bound  into the list of receive buffers.

    - Parameter buffers: A list of s of type  that contains the received data.
    - Returns: The number of bytes received.

    */
    open func Receive(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Receive_0__1__System_Collections_Generic_IList_System_System_ArraySegment_u8__(&__thrown, self.get_handle(), buffers.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Receive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
    /**
    Receives data from a bound  into the list of receive buffers, using the specified .

    - Parameter buffers: A list of s of type  that contains the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes received.

    */
    open func Receive(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Receive_0__2__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Receive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError)
// docid: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
    /**
    Receives data from a bound  into the list of receive buffers, using the specified .

    - Parameter buffers: A list of s of type  that contains the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Returns: The number of bytes received.

    */
    open func Receive(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_i32__Receive_0__3__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags_outSocketError(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value(), &_tmp_out_errorCode);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Receive(System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 Receive(System.Span<System.Byte>, System.Net.Sockets.SocketFlags)
// TODO COPE (write_all_methods) (span) System.Int32 Receive(System.Span<System.Byte>, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError)
    // System.Threading.Tasks.Task<System.Int32> ReceiveAsync(System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.ReceiveAsync(System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)
    /**
    Receives data from a connected socket.

    - Parameter buffer: The buffer for the received data.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when receiving the data.
    - Returns: An asynchronous task that completes with the number of bytes received.

    */
    open func ReceiveAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_i32___ReceiveAsync_0__2__System_ArraySegment_u8__SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task<System.Int32> ReceiveAsync(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.ReceiveAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
    /**
    Receives data from a connected socket.

    - Parameter buffers: A list of buffers for the received data.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when receiving the data.
    - Returns: An asynchronous task that completes with the number of bytes received.

    */
    open func ReceiveAsync(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_i32___ReceiveAsync_0__2__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReceiveAsync(System.Memory<System.Byte>, System.Net.Sockets.SocketFlags, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.ReceiveAsync(System.Memory{System.Byte},System.Net.Sockets.SocketFlags,System.Threading.CancellationToken)
    /**
    Receives data from a connected socket.

    - Parameter buffer: The buffer for the received data.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when receiving the data.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes with the number of bytes received.

    */
    open func ReceiveAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_ValueTask_i32___ReceiveAsync_0__3__System_Memory_u8__SocketFlags_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Begins an asynchronous request to receive data from a connected  object.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func ReceiveAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__ReceiveAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 ReceiveFrom(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    /**
    Receives the specified number of bytes of data into the specified location of the data buffer, using the specified , and stores the endpoint.

    - Parameter buffer: An array of type  that is the storage location for received data.
    - Parameter offset: The position in the  parameter to store the received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An , passed by reference, that represents the remote server.
    - Returns: The number of bytes received.

    */
    open func ReceiveFrom(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = remoteEP.get_handle();
        let __return = System_Net_Sockets_Socket_i32__ReceiveFrom_0__5__u8Array_i32_i32_SocketFlags_refEndPoint(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), &_tmp_ref_remoteEP);
        let _tmp2_remoteEP = dotnet.System.Net.EndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 ReceiveFrom(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    /**
    Receives the specified number of bytes into the data buffer, using the specified , and stores the endpoint.

    - Parameter buffer: An array of type  that is the storage location for received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An , passed by reference, that represents the remote server.
    - Returns: The number of bytes received.

    */
    open func ReceiveFrom(buffer : dotnet.System_Arr<Swift.UInt8>, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = remoteEP.get_handle();
        let __return = System_Net_Sockets_Socket_i32__ReceiveFrom_0__4__u8Array_i32_SocketFlags_refEndPoint(&__thrown, self.get_handle(), buffer.get_handle(), size, socketFlags.get_value(), &_tmp_ref_remoteEP);
        let _tmp2_remoteEP = dotnet.System.Net.EndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 ReceiveFrom(System.Byte[], ref System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)
    /**
    Receives a datagram into the data buffer and stores the endpoint.

    - Parameter buffer: An array of type  that is the storage location for received data.
    - Parameter remoteEP: An , passed by reference, that represents the remote server.
    - Returns: The number of bytes received.

    */
    open func ReceiveFrom(buffer : dotnet.System_Arr<Swift.UInt8>, remoteEP : inout dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = remoteEP.get_handle();
        let __return = System_Net_Sockets_Socket_i32__ReceiveFrom_0__2__u8Array_refEndPoint(&__thrown, self.get_handle(), buffer.get_handle(), &_tmp_ref_remoteEP);
        let _tmp2_remoteEP = dotnet.System.Net.EndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 ReceiveFrom(System.Byte[], System.Net.Sockets.SocketFlags, ref System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    /**
    Receives a datagram into the data buffer, using the specified , and stores the endpoint.

    - Parameter buffer: An array of type  that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An , passed by reference, that represents the remote server.
    - Returns: The number of bytes received.

    */
    open func ReceiveFrom(buffer : dotnet.System_Arr<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = remoteEP.get_handle();
        let __return = System_Net_Sockets_Socket_i32__ReceiveFrom_0__3__u8Array_SocketFlags_refEndPoint(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), &_tmp_ref_remoteEP);
        let _tmp2_remoteEP = dotnet.System.Net.EndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 ReceiveFrom(System.Span<System.Byte>, ref System.Net.EndPoint)
// TODO COPE (write_all_methods) (span) System.Int32 ReceiveFrom(System.Span<System.Byte>, System.Net.Sockets.SocketFlags, ref System.Net.EndPoint)
    // System.Threading.Tasks.Task<System.Net.Sockets.SocketReceiveFromResult> ReceiveFromAsync(System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.ReceiveFromAsync(System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Receives data and returns the endpoint of the sending host.

    - Parameter buffer: The buffer for the received data.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when receiving the data.
    - Parameter remoteEndPoint: An endpoint of the same type as the endpoint of the remote host.
    - Returns: An asynchronous task that completes with a  containing the number of bytes received and the endpoint of the sending host.

    */
    open func ReceiveFromAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEndPoint : dotnet.System.Net.EndPoint) async throws -> dotnet.System.Net.Sockets.SocketReceiveFromResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_System_Net_Sockets_SocketReceiveFromResult___ReceiveFromAsync_0__3__System_ArraySegment_u8__SocketFlags_EndPoint(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEndPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Sockets.SocketReceiveFromResult> ReceiveFromAsync(System.Memory<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Memory{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.Threading.CancellationToken)
    /**
    Receives data and returns the endpoint of the sending host.

    - Parameter buffer: The buffer for the received data.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when receiving the data.
    - Parameter remoteEndPoint: An endpoint of the same type as the endpoint of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: An asynchronous task that completes with a  containing the number of bytes received and the endpoint of the sending host.

    */
    open func ReceiveFromAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEndPoint : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Sockets.SocketReceiveFromResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_ValueTask_System_Net_Sockets_SocketReceiveFromResult___ReceiveFromAsync_0__4__System_Memory_u8__SocketFlags_EndPoint_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEndPoint.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Begins to asynchronously receive data from a specified network device.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func ReceiveFromAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__ReceiveFromAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 ReceiveMessageFrom(System.Byte[], System.Int32, System.Int32, ref System.Net.Sockets.SocketFlags, ref System.Net.EndPoint, ref System.Net.Sockets.IPPacketInformation)
// docid: M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)
    /**
    Receives the specified number of bytes of data into the specified location of the data buffer, using the specified , and stores the endpoint and packet information.

    - Parameter buffer: An array of type  that is the storage location for received data.
    - Parameter offset: The position in the  parameter to store the received data.
    - Parameter size: The number of bytes to receive.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An , passed by reference, that represents the remote server.
    - Parameter ipPacketInformation: An  holding address and interface information.
    - Returns: The number of bytes received.

    */
    open func ReceiveMessageFrom(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : inout dotnet.System.Net.Sockets.SocketFlags, remoteEP : inout dotnet.System.Net.EndPoint, ipPacketInformation : inout dotnet.System.Net.Sockets.IPPacketInformation) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_socketFlags = socketFlags.get_value();
            var _tmp_ref_remoteEP = remoteEP.get_handle();
            var _tmp_out_ipPacketInformation = ipPacketInformation.get_handle();
        let __return = System_Net_Sockets_Socket_i32__ReceiveMessageFrom_0__6__u8Array_i32_i32_refSocketFlags_refEndPoint_outIPPacketInformation(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, &_tmp_ref_socketFlags, &_tmp_ref_remoteEP, &_tmp_out_ipPacketInformation);
        let _tmp2_socketFlags = dotnet.System.Net.Sockets.SocketFlags(val: _tmp_ref_socketFlags);
            socketFlags = _tmp2_socketFlags;
        let _tmp2_remoteEP = dotnet.System.Net.EndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        let _tmp2_ipPacketInformation = dotnet.System.Net.Sockets.IPPacketInformation(hndl: _tmp_out_ipPacketInformation);
            ipPacketInformation = _tmp2_ipPacketInformation;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 ReceiveMessageFrom(System.Span<System.Byte>, ref System.Net.Sockets.SocketFlags, ref System.Net.EndPoint, ref System.Net.Sockets.IPPacketInformation)
    // System.Threading.Tasks.Task<System.Net.Sockets.SocketReceiveMessageFromResult> ReceiveMessageFromAsync(System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Receives data and returns additional information about the sender of the message.

    - Parameter buffer: The buffer for the received data.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when receiving the data.
    - Parameter remoteEndPoint: An endpoint of the same type as the endpoint of the remote host.
    - Returns: An asynchronous task that completes with a  containing the number of bytes received and additional information about the sending host.

    */
    open func ReceiveMessageFromAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEndPoint : dotnet.System.Net.EndPoint) async throws -> dotnet.System.Net.Sockets.SocketReceiveMessageFromResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_System_Net_Sockets_SocketReceiveMessageFromResult___ReceiveMessageFromAsync_0__3__System_ArraySegment_u8__SocketFlags_EndPoint(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEndPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Sockets.SocketReceiveMessageFromResult> ReceiveMessageFromAsync(System.Memory<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Memory{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.Threading.CancellationToken)
    /**
    Receives data and returns additional information about the sender of the message.

    - Parameter buffer: The buffer for the received data.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when receiving the data.
    - Parameter remoteEndPoint: An endpoint of the same type as the endpoint of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: An asynchronous task that completes with a  containing the number of bytes received and additional information about the sending host.

    */
    open func ReceiveMessageFromAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEndPoint : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Sockets.SocketReceiveMessageFromResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_ValueTask_System_Net_Sockets_SocketReceiveMessageFromResult___ReceiveMessageFromAsync_0__4__System_Memory_u8__SocketFlags_EndPoint_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEndPoint.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified , and stores the endpoint and packet information.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func ReceiveMessageFromAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__ReceiveMessageFromAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Select(System.Collections.IList, System.Collections.IList, System.Collections.IList, System.Int32)
// docid: M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)
    /**
    Determines the status of one or more sockets.

    - Parameter checkRead: An  of  instances to check for readability.
    - Parameter checkWrite: An  of  instances to check for writability.
    - Parameter checkError: An  of  instances to check for errors.
    - Parameter microSeconds: The time-out value, in microseconds. A -1 value indicates an infinite time-out.
    */
    open class func Select(checkRead : Optional<dotnet.System.Collections.IList>, checkWrite : Optional<dotnet.System.Collections.IList>, checkError : Optional<dotnet.System.Collections.IList>, microSeconds : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Select_0__4__IList_IList_IList_i32(&__thrown, checkRead?.get_handle() ?? nil, checkWrite?.get_handle() ?? nil, checkError?.get_handle() ?? nil, microSeconds);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 Send(System.Byte[])
// docid: M:System.Net.Sockets.Socket.Send(System.Byte[])
    /**
    Sends data to a connected .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffer : dotnet.System_Arr<Swift.UInt8>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Send_0__1__u8Array(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Send(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
    /**
    Sends the specified number of bytes of data to a connected , starting at the specified offset, and using the specified .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter offset: The position in the data buffer at which to begin sending data.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Send_0__4__u8Array_i32_i32_SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Send(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError)
// docid: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
    /**
    Sends the specified number of bytes of data to a connected , starting at the specified offset, and using the specified .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter offset: The position in the data buffer at which to begin sending data.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_i32__Send_0__5__u8Array_i32_i32_SocketFlags_outSocketError(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), &_tmp_out_errorCode);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Send(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    /**
    Sends the specified number of bytes of data to a connected , using the specified .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffer : dotnet.System_Arr<Swift.UInt8>, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Send_0__3__u8Array_i32_SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), size, socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Send(System.Byte[], System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)
    /**
    Sends data to a connected  using the specified .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffer : dotnet.System_Arr<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Send_0__2__u8Array_SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Send(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>)
// docid: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
    /**
    Sends the set of buffers in the list to a connected .

    - Parameter buffers: A list of s of type  that contains the data to be sent.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Send_0__1__System_Collections_Generic_IList_System_System_ArraySegment_u8__(&__thrown, self.get_handle(), buffers.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Send(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
    /**
    Sends the set of buffers in the list to a connected , using the specified .

    - Parameter buffers: A list of s of type  that contains the data to be sent.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__Send_0__2__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Send(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError)
// docid: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
    /**
    Sends the set of buffers in the list to a connected , using the specified .

    - Parameter buffers: A list of s of type  that contains the data to be sent.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter errorCode: A  object that stores the socket error.
    - Returns: The number of bytes sent to the .

    */
    open func Send(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, errorCode : inout dotnet.System.Net.Sockets.SocketError) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_out_errorCode = errorCode.get_value();
        let __return = System_Net_Sockets_Socket_i32__Send_0__3__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags_outSocketError(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value(), &_tmp_out_errorCode);
        let _tmp2_errorCode = dotnet.System.Net.Sockets.SocketError(val: _tmp_out_errorCode);
            errorCode = _tmp2_errorCode;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Send(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 Send(System.ReadOnlySpan<System.Byte>, System.Net.Sockets.SocketFlags)
// TODO COPE (write_all_methods) (span) System.Int32 Send(System.ReadOnlySpan<System.Byte>, System.Net.Sockets.SocketFlags, ref System.Net.Sockets.SocketError)
    // System.Threading.Tasks.Task<System.Int32> SendAsync(System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.SendAsync(System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)
    /**
    Sends data on a connected socket.

    - Parameter buffer: The buffer for the data to send.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when sending the data.
    - Returns: An asynchronous task that completes with the number of bytes sent.

    */
    open func SendAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_i32___SendAsync_0__2__System_ArraySegment_u8__SocketFlags(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task<System.Int32> SendAsync(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.Socket.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
    /**
    Sends data on a connected socket.

    - Parameter buffers: A list of buffers for the data to send.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when sending the data.
    - Returns: An asynchronous task that completes with the number of bytes sent.

    */
    open func SendAsync(buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_i32___SendAsync_0__2__System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags(&__thrown, self.get_handle(), buffers.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> SendAsync(System.ReadOnlyMemory<System.Byte>, System.Net.Sockets.SocketFlags, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.SendAsync(System.ReadOnlyMemory{System.Byte},System.Net.Sockets.SocketFlags,System.Threading.CancellationToken)
    /**
    Sends data on a connected socket.

    - Parameter buffer: The buffer for the data to send.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when sending the data.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes with the number of bytes sent.

    */
    open func SendAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_ValueTask_i32___SendAsync_0__3__System_ReadOnlyMemory_u8__SocketFlags_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool SendAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Sends data asynchronously to a connected  object.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func SendAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__SendAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void SendFile(System.String)
// docid: M:System.Net.Sockets.Socket.SendFile(System.String)
    /**
    Sends the file  to a connected  object with the  transmit flag.

    - Parameter fileName: A  that contains the path and name of the file to be sent. This parameter can be .
    */
    open func SendFile(fileName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__SendFile_0__1__String(&__thrown, self.get_handle(), fileName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SendFile(System.String, System.Byte[], System.Byte[], System.Net.Sockets.TransmitFileOptions)
// docid: M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)
    /**
    Sends the file  and buffers of data to a connected  object using the specified  value.

    - Parameter fileName: The path and name of the file to be sent. This parameter can be .
    - Parameter preBuffer: The data to be sent before the file is sent. This parameter can be .
    - Parameter postBuffer: The data to be sent after the file is sent. This parameter can be .
    - Parameter flags: A bitwise combination of the enumeration values that specifies how the file is transferred.
    */
    open func SendFile(fileName : Optional<dotnet.System.String>, preBuffer : Optional<dotnet.System_Arr<Swift.UInt8>>, postBuffer : Optional<dotnet.System_Arr<Swift.UInt8>>, flags : dotnet.System.Net.Sockets.TransmitFileOptions) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__SendFile_0__4__String_u8Array_u8Array_TransmitFileOptions(&__thrown, self.get_handle(), fileName?.get_handle() ?? nil, (preBuffer?.get_handle()), (postBuffer?.get_handle()), flags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void SendFile(System.String, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Net.Sockets.TransmitFileOptions)
    // System.Threading.Tasks.ValueTask SendFileAsync(System.String, System.ReadOnlyMemory<System.Byte>, System.ReadOnlyMemory<System.Byte>, System.Net.Sockets.TransmitFileOptions, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.SendFileAsync(System.String,System.ReadOnlyMemory{System.Byte},System.ReadOnlyMemory{System.Byte},System.Net.Sockets.TransmitFileOptions,System.Threading.CancellationToken)
    /**
    Sends the file  and buffers of data to a connected  object using the specified  value.

    - Parameter fileName: A  that contains the path and name of the file to be sent. This parameter can be .
    - Parameter preBuffer: A  array that contains data to be sent before the file is sent. This parameter can be .
    - Parameter postBuffer: A  array that contains data to be sent after the file is sent. This parameter can be .
    - Parameter flags: One or more of  values.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: A value task that represents the asynchronous send file operation.

    */
    open func SendFileAsync(fileName : Optional<dotnet.System.String>, preBuffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, postBuffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, flags : dotnet.System.Net.Sockets.TransmitFileOptions, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ValueTask__SendFileAsync_0__5__String_System_ReadOnlyMemory_u8__System_ReadOnlyMemory_u8__TransmitFileOptions_CancellationToken(&__thrown, self.get_handle(), fileName?.get_handle() ?? nil, preBuffer.get_handle(), postBuffer.get_handle(), flags.get_value(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask SendFileAsync(System.String, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.SendFileAsync(System.String,System.Threading.CancellationToken)
    /**
    Sends the file  to a connected  object.

    - Parameter fileName: A  that contains the path and name of the file to be sent. This parameter can be .
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: A value task that represents the asynchronous send file operation.

    */
    open func SendFileAsync(fileName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ValueTask__SendFileAsync_0__2__String_CancellationToken(&__thrown, self.get_handle(), fileName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // bool SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Sends a collection of files or in memory data buffers asynchronously to a connected  object.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func SendPacketsAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__SendPacketsAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 SendTo(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter offset: The position in the data buffer at which to begin sending data.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: The  that represents the destination location for the data.
    - Returns: The number of bytes sent.

    */
    open func SendTo(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__SendTo_0__5__u8Array_i32_i32_SocketFlags_EndPoint(&__thrown, self.get_handle(), buffer.get_handle(), offset, size, socketFlags.get_value(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 SendTo(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Sends the specified number of bytes of data to the specified endpoint using the specified .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter size: The number of bytes to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: The  that represents the destination location for the data.
    - Returns: The number of bytes sent.

    */
    open func SendTo(buffer : dotnet.System_Arr<Swift.UInt8>, size : Swift.Int32, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__SendTo_0__4__u8Array_i32_SocketFlags_EndPoint(&__thrown, self.get_handle(), buffer.get_handle(), size, socketFlags.get_value(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 SendTo(System.Byte[], System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)
    /**
    Sends data to the specified endpoint.

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter remoteEP: The  that represents the destination for the data.
    - Returns: The number of bytes sent.

    */
    open func SendTo(buffer : dotnet.System_Arr<Swift.UInt8>, remoteEP : dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__SendTo_0__2__u8Array_EndPoint(&__thrown, self.get_handle(), buffer.get_handle(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 SendTo(System.Byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Sends data to a specific endpoint using the specified .

    - Parameter buffer: An array of type  that contains the data to be sent.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: The  that represents the destination location for the data.
    - Returns: The number of bytes sent.

    */
    open func SendTo(buffer : dotnet.System_Arr<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__SendTo_0__3__u8Array_SocketFlags_EndPoint(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 SendTo(System.ReadOnlySpan<System.Byte>, System.Net.EndPoint)
// TODO COPE (write_all_methods) (span) System.Int32 SendTo(System.ReadOnlySpan<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
    // System.Threading.Tasks.Task<System.Int32> SendToAsync(System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.Socket.SendToAsync(System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Sends data to the specified remote host.

    - Parameter buffer: The buffer for the data to send.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when sending the data.
    - Parameter remoteEP: The remote host to which to send the data.
    - Returns: An asynchronous task that completes with the number of bytes sent.

    */
    open func SendToAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_Task_i32___SendToAsync_0__3__System_ArraySegment_u8__SocketFlags_EndPoint(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> SendToAsync(System.ReadOnlyMemory<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.Socket.SendToAsync(System.ReadOnlyMemory{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.Threading.CancellationToken)
    /**
    Sends data to the specified remote host.

    - Parameter buffer: The buffer for the data to send.
    - Parameter socketFlags: A bitwise combination of SocketFlags values that will be used when sending the data.
    - Parameter remoteEP: The remote host to which to send the data.
    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: An asynchronous task that completes with the number of bytes sent.

    */
    open func SendToAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_System_Threading_Tasks_ValueTask_i32___SendToAsync_0__4__System_ReadOnlyMemory_u8__SocketFlags_EndPoint_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEP.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)
// docid: M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)
    /**
    Sends data asynchronously to a specific remote host.

    - Parameter e: The  object to use for this asynchronous socket operation.
    - Returns: 
         if the I/O operation is pending. The  event on the  parameter will be raised upon completion of the operation.

  if the I/O operation completed synchronously. In this case, The  event on the  parameter will not be raised and the  object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

    */
    open func SendToAsync(e : dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__SendToAsync_0__1__SocketAsyncEventArgs(&__thrown, self.get_handle(), e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)
// docid: M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)
    /**
    Sets the IP protection level on a socket.

    - Parameter level: The IP protection level to set on this socket.
    */
    open func SetIPProtectionLevel(level : dotnet.System.Net.Sockets.IPProtectionLevel) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__SetIPProtectionLevel_0__1__IPProtectionLevel(&__thrown, self.get_handle(), level.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void SetRawSocketOption(System.Int32, System.Int32, System.ReadOnlySpan<System.Byte>)
    // void SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, bool)
// docid: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)
    /**
    Sets the specified  option to the specified  value.

    - Parameter optionLevel: One of the  values.
    - Parameter optionName: One of the  values.
    - Parameter optionValue: The value of the option, represented as a .
    */
    open func SetSocketOption(optionLevel : dotnet.System.Net.Sockets.SocketOptionLevel, optionName : dotnet.System.Net.Sockets.SocketOptionName, optionValue : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__SetSocketOption_0__3__SocketOptionLevel_SocketOptionName_bool(&__thrown, self.get_handle(), optionLevel.get_value(), optionName.get_value(), Swift.Int32(optionValue ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Byte[])
// docid: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
    /**
    Sets the specified  option to the specified value, represented as a byte array.

    - Parameter optionLevel: One of the  values.
    - Parameter optionName: One of the  values.
    - Parameter optionValue: An array of type  that represents the value of the option.
    */
    open func SetSocketOption(optionLevel : dotnet.System.Net.Sockets.SocketOptionLevel, optionName : dotnet.System.Net.Sockets.SocketOptionName, optionValue : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__SetSocketOption_0__3__SocketOptionLevel_SocketOptionName_u8Array(&__thrown, self.get_handle(), optionLevel.get_value(), optionName.get_value(), optionValue.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Int32)
// docid: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    /**
    Sets the specified  option to the specified integer value.

    - Parameter optionLevel: One of the  values.
    - Parameter optionName: One of the  values.
    - Parameter optionValue: A value of the option.
    */
    open func SetSocketOption(optionLevel : dotnet.System.Net.Sockets.SocketOptionLevel, optionName : dotnet.System.Net.Sockets.SocketOptionName, optionValue : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__SetSocketOption_0__3__SocketOptionLevel_SocketOptionName_i32(&__thrown, self.get_handle(), optionLevel.get_value(), optionName.get_value(), optionValue);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Object)
// docid: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)
    /**
    Sets the specified  option to the specified value, represented as an object.

    - Parameter optionLevel: One of the  values.
    - Parameter optionName: One of the  values.
    - Parameter optionValue: A  or  that contains the value of the option.
    */
    open func SetSocketOption(optionLevel : dotnet.System.Net.Sockets.SocketOptionLevel, optionName : dotnet.System.Net.Sockets.SocketOptionName, optionValue : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__SetSocketOption_0__3__SocketOptionLevel_SocketOptionName_Object(&__thrown, self.get_handle(), optionLevel.get_value(), optionName.get_value(), optionValue.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Shutdown(System.Net.Sockets.SocketShutdown)
// docid: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    /**
    Disables sends and receives on a .

    - Parameter how: One of the  values that specifies the operation that will no longer be allowed.
    */
    open func Shutdown(how : dotnet.System.Net.Sockets.SocketShutdown) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__Shutdown_0__1__SocketShutdown(&__thrown, self.get_handle(), how.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.AddressFamily get_AddressFamily()
// docid: M:System.Net.Sockets.Socket.get_AddressFamily
    open func get_AddressFamily() throws -> dotnet.System.Net.Sockets.AddressFamily {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_AddressFamily__get_AddressFamily_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.AddressFamily(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Available()
// docid: M:System.Net.Sockets.Socket.get_Available
    open func get_Available() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__get_Available_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_Blocking()
// docid: M:System.Net.Sockets.Socket.get_Blocking
    open func get_Blocking() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_Blocking_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Blocking(bool)
// docid: M:System.Net.Sockets.Socket.set_Blocking(System.Boolean)
    open func set_Blocking(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_Blocking_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_Connected()
// docid: M:System.Net.Sockets.Socket.get_Connected
    open func get_Connected() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_Connected_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_DontFragment()
// docid: M:System.Net.Sockets.Socket.get_DontFragment
    open func get_DontFragment() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_DontFragment_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DontFragment(bool)
// docid: M:System.Net.Sockets.Socket.set_DontFragment(System.Boolean)
    open func set_DontFragment(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_DontFragment_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_DualMode()
// docid: M:System.Net.Sockets.Socket.get_DualMode
    open func get_DualMode() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_DualMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DualMode(bool)
// docid: M:System.Net.Sockets.Socket.set_DualMode(System.Boolean)
    open func set_DualMode(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_DualMode_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_EnableBroadcast()
// docid: M:System.Net.Sockets.Socket.get_EnableBroadcast
    open func get_EnableBroadcast() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_EnableBroadcast_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_EnableBroadcast(bool)
// docid: M:System.Net.Sockets.Socket.set_EnableBroadcast(System.Boolean)
    open func set_EnableBroadcast(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_EnableBroadcast_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ExclusiveAddressUse()
// docid: M:System.Net.Sockets.Socket.get_ExclusiveAddressUse
    open func get_ExclusiveAddressUse() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_ExclusiveAddressUse_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ExclusiveAddressUse(bool)
// docid: M:System.Net.Sockets.Socket.set_ExclusiveAddressUse(System.Boolean)
    open func set_ExclusiveAddressUse(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_ExclusiveAddressUse_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IntPtr get_Handle()
// docid: M:System.Net.Sockets.Socket.get_Handle
    open func get_Handle() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_IntPtr__get_Handle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] bool get_IsBound()
// docid: M:System.Net.Sockets.Socket.get_IsBound
    open func get_IsBound() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_IsBound_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.Sockets.LingerOption get_LingerState()
// docid: M:System.Net.Sockets.Socket.get_LingerState
    open func get_LingerState() throws -> Optional<dotnet.System.Net.Sockets.LingerOption> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_LingerOption__get_LingerState_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Sockets.LingerOption(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LingerState(System.Net.Sockets.LingerOption)
// docid: M:System.Net.Sockets.Socket.set_LingerState(System.Net.Sockets.LingerOption)
    open func set_LingerState(value : Optional<dotnet.System.Net.Sockets.LingerOption>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_LingerState_0__1__LingerOption(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_LocalEndPoint()
// docid: M:System.Net.Sockets.Socket.get_LocalEndPoint
    open func get_LocalEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_EndPoint__get_LocalEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_MulticastLoopback()
// docid: M:System.Net.Sockets.Socket.get_MulticastLoopback
    open func get_MulticastLoopback() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_MulticastLoopback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_MulticastLoopback(bool)
// docid: M:System.Net.Sockets.Socket.set_MulticastLoopback(System.Boolean)
    open func set_MulticastLoopback(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_MulticastLoopback_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_NoDelay()
// docid: M:System.Net.Sockets.Socket.get_NoDelay
    open func get_NoDelay() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_NoDelay_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_NoDelay(bool)
// docid: M:System.Net.Sockets.Socket.set_NoDelay(System.Boolean)
    open func set_NoDelay(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_NoDelay_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_OSSupportsIPv4()
// docid: M:System.Net.Sockets.Socket.get_OSSupportsIPv4
    open class func get_OSSupportsIPv4() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_OSSupportsIPv4_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_OSSupportsIPv6()
// docid: M:System.Net.Sockets.Socket.get_OSSupportsIPv6
    open class func get_OSSupportsIPv6() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_OSSupportsIPv6_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_OSSupportsUnixDomainSockets()
// docid: M:System.Net.Sockets.Socket.get_OSSupportsUnixDomainSockets
    open class func get_OSSupportsUnixDomainSockets() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_OSSupportsUnixDomainSockets_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.Sockets.ProtocolType get_ProtocolType()
// docid: M:System.Net.Sockets.Socket.get_ProtocolType
    open func get_ProtocolType() throws -> dotnet.System.Net.Sockets.ProtocolType {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_ProtocolType__get_ProtocolType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.ProtocolType(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_ReceiveBufferSize()
// docid: M:System.Net.Sockets.Socket.get_ReceiveBufferSize
    open func get_ReceiveBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__get_ReceiveBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ReceiveBufferSize(System.Int32)
// docid: M:System.Net.Sockets.Socket.set_ReceiveBufferSize(System.Int32)
    open func set_ReceiveBufferSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_ReceiveBufferSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ReceiveTimeout()
// docid: M:System.Net.Sockets.Socket.get_ReceiveTimeout
    open func get_ReceiveTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__get_ReceiveTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ReceiveTimeout(System.Int32)
// docid: M:System.Net.Sockets.Socket.set_ReceiveTimeout(System.Int32)
    open func set_ReceiveTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_ReceiveTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_RemoteEndPoint()
// docid: M:System.Net.Sockets.Socket.get_RemoteEndPoint
    open func get_RemoteEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_EndPoint__get_RemoteEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Net.Sockets.SafeSocketHandle get_SafeHandle()
// docid: M:System.Net.Sockets.Socket.get_SafeHandle
    open func get_SafeHandle() throws -> dotnet.System.Net.Sockets.SafeSocketHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_SafeSocketHandle__get_SafeHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SafeSocketHandle(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_SendBufferSize()
// docid: M:System.Net.Sockets.Socket.get_SendBufferSize
    open func get_SendBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__get_SendBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_SendBufferSize(System.Int32)
// docid: M:System.Net.Sockets.Socket.set_SendBufferSize(System.Int32)
    open func set_SendBufferSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_SendBufferSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_SendTimeout()
// docid: M:System.Net.Sockets.Socket.get_SendTimeout
    open func get_SendTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i32__get_SendTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_SendTimeout(System.Int32)
// docid: M:System.Net.Sockets.Socket.set_SendTimeout(System.Int32)
    open func set_SendTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_SendTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.SocketType get_SocketType()
// docid: M:System.Net.Sockets.Socket.get_SocketType
    open func get_SocketType() throws -> dotnet.System.Net.Sockets.SocketType {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_SocketType__get_SocketType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SocketType(val: __return);
        }
    }
    // [IsSpecialName] bool get_SupportsIPv4()
// docid: M:System.Net.Sockets.Socket.get_SupportsIPv4
    open class func get_SupportsIPv4() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_SupportsIPv4_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsIPv6()
// docid: M:System.Net.Sockets.Socket.get_SupportsIPv6
    open class func get_SupportsIPv6() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_SupportsIPv6_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int16 get_Ttl()
// docid: M:System.Net.Sockets.Socket.get_Ttl
    open func get_Ttl() throws -> Swift.Int16 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_i16__get_Ttl_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Ttl(System.Int16)
// docid: M:System.Net.Sockets.Socket.set_Ttl(System.Int16)
    open func set_Ttl(value : Swift.Int16) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_Ttl_0__1__i16(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UseOnlyOverlappedIO()
// docid: M:System.Net.Sockets.Socket.get_UseOnlyOverlappedIO
    open func get_UseOnlyOverlappedIO() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_Socket_bool__get_UseOnlyOverlappedIO_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UseOnlyOverlappedIO(bool)
// docid: M:System.Net.Sockets.Socket.set_UseOnlyOverlappedIO(System.Boolean)
    open func set_UseOnlyOverlappedIO(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_Socket_void__set_UseOnlyOverlappedIO_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the address family of the .

    */
    open var AddressFamily : dotnet.System.Net.Sockets.AddressFamily {
        get {
            return try! get_AddressFamily();
        }
    }
    /**
    Gets the amount of data that has been received from the network and is available to be read.

    */
    open var Available : Swift.Int32 {
        get {
            return try! get_Available();
        }
    }
    /**
    Gets or sets a value that indicates whether the  is in blocking mode.

    */
    open var Blocking : Bool {
        get {
            return try! get_Blocking();
        }
        set(v) {
            return try! set_Blocking(value: v);
        }
    }
    /**
    Gets a value that indicates whether a  is connected to a remote host as of the last  or  operation.

    */
    open var Connected : Bool {
        get {
            return try! get_Connected();
        }
    }
    /**
    Gets or sets a value that specifies whether the  allows Internet Protocol (IP) datagrams to be fragmented.

    */
    open var DontFragment : Bool {
        get {
            return try! get_DontFragment();
        }
        set(v) {
            return try! set_DontFragment(value: v);
        }
    }
    /**
    Gets or sets a value that specifies whether the  is a dual-mode socket used for both IPv4 and IPv6.

    */
    open var DualMode : Bool {
        get {
            return try! get_DualMode();
        }
        set(v) {
            return try! set_DualMode(value: v);
        }
    }
    /**
    Gets or sets a  value that specifies whether the  can send or receive broadcast packets.

    */
    open var EnableBroadcast : Bool {
        get {
            return try! get_EnableBroadcast();
        }
        set(v) {
            return try! set_EnableBroadcast(value: v);
        }
    }
    /**
    Gets or sets a  value that specifies whether the  allows only one process to bind to a port.

    */
    open var ExclusiveAddressUse : Bool {
        get {
            return try! get_ExclusiveAddressUse();
        }
        set(v) {
            return try! set_ExclusiveAddressUse(value: v);
        }
    }
    /**
    Gets the operating system handle for the .

    */
    open var Handle : dotnet.System.IntPtr {
        get {
            return try! get_Handle();
        }
    }
    /**
    Gets a value that indicates whether the  is bound to a specific local port.

    */
    open var IsBound : Bool {
        get {
            return try! get_IsBound();
        }
    }
    /**
    Gets or sets a value that specifies whether the  will delay closing a socket in an attempt to send all pending data.

    */
    open var LingerState : Optional<dotnet.System.Net.Sockets.LingerOption> {
        get {
            return try! get_LingerState();
        }
        set(v) {
            return try! set_LingerState(value: v!);
        }
    }
    /**
    Gets the local endpoint.

    */
    open var LocalEndPoint : Optional<dotnet.System.Net.EndPoint> {
        get {
            return try! get_LocalEndPoint();
        }
    }
    /**
    Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.

    */
    open var MulticastLoopback : Bool {
        get {
            return try! get_MulticastLoopback();
        }
        set(v) {
            return try! set_MulticastLoopback(value: v);
        }
    }
    /**
    Gets or sets a  value that specifies whether the stream  is using the Nagle algorithm.

    */
    open var NoDelay : Bool {
        get {
            return try! get_NoDelay();
        }
        set(v) {
            return try! set_NoDelay(value: v);
        }
    }
    /**
    Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).

    */
    public static var OSSupportsIPv4 : Bool {
        get {
            return try! get_OSSupportsIPv4();
        }
    }
    /**
    Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).

    */
    public static var OSSupportsIPv6 : Bool {
        get {
            return try! get_OSSupportsIPv6();
        }
    }
    /**
    Indicates whether the underlying operating system support the Unix domain sockets.

    */
    public static var OSSupportsUnixDomainSockets : Bool {
        get {
            return try! get_OSSupportsUnixDomainSockets();
        }
    }
    /**
    Gets the protocol type of the .

    */
    open var ProtocolType : dotnet.System.Net.Sockets.ProtocolType {
        get {
            return try! get_ProtocolType();
        }
    }
    /**
    Gets or sets a value that specifies the size of the receive buffer of the .

    */
    open var ReceiveBufferSize : Swift.Int32 {
        get {
            return try! get_ReceiveBufferSize();
        }
        set(v) {
            return try! set_ReceiveBufferSize(value: v);
        }
    }
    /**
    Gets or sets a value that specifies the amount of time after which a synchronous  call will time out.

    */
    open var ReceiveTimeout : Swift.Int32 {
        get {
            return try! get_ReceiveTimeout();
        }
        set(v) {
            return try! set_ReceiveTimeout(value: v);
        }
    }
    /**
    Gets the remote endpoint.

    */
    open var RemoteEndPoint : Optional<dotnet.System.Net.EndPoint> {
        get {
            return try! get_RemoteEndPoint();
        }
    }
    /**
    Gets a  that represents the socket handle that the current  object encapsulates.

    */
    open var SafeHandle : dotnet.System.Net.Sockets.SafeSocketHandle {
        get {
            return try! get_SafeHandle();
        }
    }
    /**
    Gets or sets a value that specifies the size of the send buffer of the .

    */
    open var SendBufferSize : Swift.Int32 {
        get {
            return try! get_SendBufferSize();
        }
        set(v) {
            return try! set_SendBufferSize(value: v);
        }
    }
    /**
    Gets or sets a value that specifies the amount of time after which a synchronous  call will time out.

    */
    open var SendTimeout : Swift.Int32 {
        get {
            return try! get_SendTimeout();
        }
        set(v) {
            return try! set_SendTimeout(value: v);
        }
    }
    /**
    Gets the type of the .

    */
    open var SocketType : dotnet.System.Net.Sockets.SocketType {
        get {
            return try! get_SocketType();
        }
    }
    /**
    Gets a value indicating whether IPv4 support is available and enabled on the current host.

    */
    public static var SupportsIPv4 : Bool {
        get {
            return try! get_SupportsIPv4();
        }
    }
    /**
    Gets a value that indicates whether the Framework supports IPv6 for certain obsolete  members.

    */
    public static var SupportsIPv6 : Bool {
        get {
            return try! get_SupportsIPv6();
        }
    }
    /**
    Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the .

    */
    open var Ttl : Swift.Int16 {
        get {
            return try! get_Ttl();
        }
        set(v) {
            return try! set_Ttl(value: v);
        }
    }
    /**
    Gets or sets a value that specifies whether the socket should only use Overlapped I/O mode. On .NET 5+ (including .NET Core versions), the value is always .

    */
    open var UseOnlyOverlappedIO : Bool {
        get {
            return try! get_UseOnlyOverlappedIO();
        }
        set(v) {
            return try! set_UseOnlyOverlappedIO(value: v);
        }
    }
} // Socket


// type: System.Net.Sockets.SocketAsyncEventArgs
    /**
    Represents an asynchronous socket operation.

    */
open class SocketAsyncEventArgs
    :
    dotnet.System.EventArgs,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketAsyncEventArgs_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_SocketAsyncEventArgs_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.#ctor
    /**
    Creates an empty  instance.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SocketAsyncEventArgs_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.#ctor(System.Boolean)
    /**
    Initializes the .

    - Parameter unsafeSuppressExecutionContextFlow: Whether to disable the capturing and flow of execution context. Execution context flow should only be disabled if it's handled by higher layers.
    */
    public init(unsafeSuppressExecutionContextFlow : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SocketAsyncEventArgs_ctor_0__1__bool(&__thrown, Swift.Int32(unsafeSuppressExecutionContextFlow ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.Dispose
    /**
    Releases the unmanaged resources used by the  instance and optionally disposes of the managed resources.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetBuffer(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Byte[],System.Int32,System.Int32)
    /**
    Sets the data buffer to use with an asynchronous socket method.

    - Parameter buffer: The data buffer to use with an asynchronous socket method.
    - Parameter offset: The offset, in bytes, in the data buffer where the operation starts.
    - Parameter count: The maximum amount of data, in bytes, to send or receive in the buffer.
    */
    open func SetBuffer(buffer : Optional<dotnet.System_Arr<Swift.UInt8>>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__SetBuffer_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), (buffer?.get_handle()), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetBuffer(System.Int32, System.Int32)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Int32,System.Int32)
    /**
    Sets the data buffer to use with an asynchronous socket method.

    - Parameter offset: The offset, in bytes, in the data buffer where the operation starts.
    - Parameter count: The maximum amount of data, in bytes, to send or receive in the buffer.
    */
    open func SetBuffer(offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__SetBuffer_0__2__i32_i32(&__thrown, self.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetBuffer(System.Memory<System.Byte>)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Memory{System.Byte})
    /**
    Sets the region of memory to use as a buffer with an asynchronous socket method.

    - Parameter buffer: The region of memory to use as a buffer with an asynchronous socket method.
    */
    open func SetBuffer(buffer : dotnet.System.Memory_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__SetBuffer_0__1__System_Memory_u8_(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.Socket get_AcceptSocket()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_AcceptSocket
    open func get_AcceptSocket() throws -> Optional<dotnet.System.Net.Sockets.Socket> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_Socket__get_AcceptSocket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Sockets.Socket(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AcceptSocket(System.Net.Sockets.Socket)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_AcceptSocket(System.Net.Sockets.Socket)
    open func set_AcceptSocket(value : Optional<dotnet.System.Net.Sockets.Socket>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_AcceptSocket_0__1__Socket(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Buffer()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_Buffer
    open func get_Buffer() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_u8Array__get_Buffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<System.ArraySegment<System.Byte>> get_BufferList()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_BufferList
    open func get_BufferList() throws -> Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_System_Collections_Generic_IList_System_System_ArraySegment_u8____get_BufferList_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_BufferList(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_BufferList(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
    open func set_BufferList(value : Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_BufferList_0__1__System_Collections_Generic_IList_System_System_ArraySegment_u8__(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_BytesTransferred()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_BytesTransferred
    open func get_BytesTransferred() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_i32__get_BytesTransferred_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Exception get_ConnectByNameError()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_ConnectByNameError
    open func get_ConnectByNameError() throws -> Optional<dotnet.System.Exception> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_Exception__get_ConnectByNameError_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Exception(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Net.Sockets.Socket get_ConnectSocket()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_ConnectSocket
    open func get_ConnectSocket() throws -> Optional<dotnet.System.Net.Sockets.Socket> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_Socket__get_ConnectSocket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Sockets.Socket(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_Count
    open func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_DisconnectReuseSocket()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_DisconnectReuseSocket
    open func get_DisconnectReuseSocket() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_bool__get_DisconnectReuseSocket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DisconnectReuseSocket(bool)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_DisconnectReuseSocket(System.Boolean)
    open func set_DisconnectReuseSocket(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_DisconnectReuseSocket_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.SocketAsyncOperation get_LastOperation()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_LastOperation
    open func get_LastOperation() throws -> dotnet.System.Net.Sockets.SocketAsyncOperation {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_SocketAsyncOperation__get_LastOperation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SocketAsyncOperation(val: __return);
        }
    }
    // [IsSpecialName] System.Memory<System.Byte> get_MemoryBuffer()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_MemoryBuffer
    open func get_MemoryBuffer() throws -> dotnet.System.Memory_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_System_Memory_u8___get_MemoryBuffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Offset()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_Offset
    open func get_Offset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_i32__get_Offset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.IPPacketInformation get_ReceiveMessageFromPacketInfo()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_ReceiveMessageFromPacketInfo
    open func get_ReceiveMessageFromPacketInfo() throws -> dotnet.System.Net.Sockets.IPPacketInformation {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_IPPacketInformation__get_ReceiveMessageFromPacketInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.IPPacketInformation(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_RemoteEndPoint()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_RemoteEndPoint
    open func get_RemoteEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_EndPoint__get_RemoteEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RemoteEndPoint(System.Net.EndPoint)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_RemoteEndPoint(System.Net.EndPoint)
    open func set_RemoteEndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_RemoteEndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.SendPacketsElement[] get_SendPacketsElements()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_SendPacketsElements
    open func get_SendPacketsElements() throws -> Optional<dotnet.System_Arr<dotnet.System.Net.Sockets.SendPacketsElement>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_SendPacketsElementArray__get_SendPacketsElements_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<dotnet.System.Net.Sockets.SendPacketsElement>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SendPacketsElements(System.Net.Sockets.SendPacketsElement[])
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_SendPacketsElements(System.Net.Sockets.SendPacketsElement[])
    open func set_SendPacketsElements(value : Optional<dotnet.System_Arr<dotnet.System.Net.Sockets.SendPacketsElement>>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_SendPacketsElements_0__1__SendPacketsElementArray(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.TransmitFileOptions get_SendPacketsFlags()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_SendPacketsFlags
    open func get_SendPacketsFlags() throws -> dotnet.System.Net.Sockets.TransmitFileOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_TransmitFileOptions__get_SendPacketsFlags_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.TransmitFileOptions(val: __return);
        }
    }
    // [IsSpecialName] void set_SendPacketsFlags(System.Net.Sockets.TransmitFileOptions)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_SendPacketsFlags(System.Net.Sockets.TransmitFileOptions)
    open func set_SendPacketsFlags(value : dotnet.System.Net.Sockets.TransmitFileOptions) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_SendPacketsFlags_0__1__TransmitFileOptions(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_SendPacketsSendSize()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_SendPacketsSendSize
    open func get_SendPacketsSendSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_i32__get_SendPacketsSendSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_SendPacketsSendSize(System.Int32)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_SendPacketsSendSize(System.Int32)
    open func set_SendPacketsSendSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_SendPacketsSendSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.SocketError get_SocketError()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_SocketError
    open func get_SocketError() throws -> dotnet.System.Net.Sockets.SocketError {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_SocketError__get_SocketError_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SocketError(val: __return);
        }
    }
    // [IsSpecialName] void set_SocketError(System.Net.Sockets.SocketError)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_SocketError(System.Net.Sockets.SocketError)
    open func set_SocketError(value : dotnet.System.Net.Sockets.SocketError) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_SocketError_0__1__SocketError(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.SocketFlags get_SocketFlags()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_SocketFlags
    open func get_SocketFlags() throws -> dotnet.System.Net.Sockets.SocketFlags {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_SocketFlags__get_SocketFlags_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SocketFlags(val: __return);
        }
    }
    // [IsSpecialName] void set_SocketFlags(System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_SocketFlags(System.Net.Sockets.SocketFlags)
    open func set_SocketFlags(value : dotnet.System.Net.Sockets.SocketFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_SocketFlags_0__1__SocketFlags(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Object get_UserToken()
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.get_UserToken
    open func get_UserToken() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketAsyncEventArgs_Object__get_UserToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_UserToken(System.Object)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.set_UserToken(System.Object)
    open func set_UserToken(value : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__set_UserToken_0__1__Object(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] void add_Completed(System.EventHandler<System.Net.Sockets.SocketAsyncEventArgs>)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.add_Completed(System.EventHandler{System.Net.Sockets.SocketAsyncEventArgs})
    open func add_Completed(value : Optional<dotnet.System.EventHandler_1<dotnet.System.Net.Sockets.SocketAsyncEventArgs>>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__add_Completed_0__1__System_EventHandler_System_Net_Sockets_SocketAsyncEventArgs_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func add_Completed(value : @escaping (Optional<dotnet.System.Object>, dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Void) throws {
        let del_value = try dotnet.System.EventHandler_1<dotnet.System.Net.Sockets.SocketAsyncEventArgs>(value);
        return try add_Completed(value: del_value);
    }
    // [IsSpecialName] void remove_Completed(System.EventHandler<System.Net.Sockets.SocketAsyncEventArgs>)
// docid: M:System.Net.Sockets.SocketAsyncEventArgs.remove_Completed(System.EventHandler{System.Net.Sockets.SocketAsyncEventArgs})
    open func remove_Completed(value : Optional<dotnet.System.EventHandler_1<dotnet.System.Net.Sockets.SocketAsyncEventArgs>>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketAsyncEventArgs_void__remove_Completed_0__1__System_EventHandler_System_Net_Sockets_SocketAsyncEventArgs_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func remove_Completed(value : @escaping (Optional<dotnet.System.Object>, dotnet.System.Net.Sockets.SocketAsyncEventArgs) throws -> Void) throws {
        let del_value = try dotnet.System.EventHandler_1<dotnet.System.Net.Sockets.SocketAsyncEventArgs>(value);
        return try remove_Completed(value: del_value);
    }
    /**
    Gets or sets the socket to use or the socket created for accepting a connection with an asynchronous socket method.

    */
    open var AcceptSocket : Optional<dotnet.System.Net.Sockets.Socket> {
        get {
            return try! get_AcceptSocket();
        }
        set(v) {
            return try! set_AcceptSocket(value: v!);
        }
    }
    /**
    Gets the data buffer to use with an asynchronous socket method.

    */
    open var Buffer : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_Buffer();
        }
    }
    /**
    Gets or sets an array of data buffers to use with an asynchronous socket method.

    */
    open var BufferList : Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>> {
        get {
            return try! get_BufferList();
        }
        set(v) {
            return try! set_BufferList(value: v!);
        }
    }
    /**
    Gets the number of bytes transferred in the socket operation.

    */
    open var BytesTransferred : Swift.Int32 {
        get {
            return try! get_BytesTransferred();
        }
    }
    /**
    Gets the exception in the case of a connection failure when a  was used.

    */
    open var ConnectByNameError : Optional<dotnet.System.Exception> {
        get {
            return try! get_ConnectByNameError();
        }
    }
    /**
    The created and connected  object after successful completion of the  method.

    */
    open var ConnectSocket : Optional<dotnet.System.Net.Sockets.Socket> {
        get {
            return try! get_ConnectSocket();
        }
    }
    /**
    Gets the maximum amount of data, in bytes, to send or receive in an asynchronous operation.

    */
    open var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets or sets a value that specifies if socket can be reused after a disconnect operation.

    */
    open var DisconnectReuseSocket : Bool {
        get {
            return try! get_DisconnectReuseSocket();
        }
        set(v) {
            return try! set_DisconnectReuseSocket(value: v);
        }
    }
    /**
    Gets the type of socket operation most recently performed with this context object.

    */
    open var LastOperation : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
            return try! get_LastOperation();
        }
    }
    /**
    Gets the region of memory to use as a buffer with an asynchronous socket method.

    */
    open var MemoryBuffer : dotnet.System.Memory_1<Swift.UInt8> {
        get {
            return try! get_MemoryBuffer();
        }
    }
    /**
    Gets the offset, in bytes, into the data buffer referenced by the  property.

    */
    open var Offset : Swift.Int32 {
        get {
            return try! get_Offset();
        }
    }
    /**
    Gets the IP address and interface of a received packet.

    */
    open var ReceiveMessageFromPacketInfo : dotnet.System.Net.Sockets.IPPacketInformation {
        get {
            return try! get_ReceiveMessageFromPacketInfo();
        }
    }
    /**
    Gets or sets the remote IP endpoint for an asynchronous operation.

    */
    open var RemoteEndPoint : Optional<dotnet.System.Net.EndPoint> {
        get {
            return try! get_RemoteEndPoint();
        }
        set(v) {
            return try! set_RemoteEndPoint(value: v!);
        }
    }
    /**
    Gets or sets an array of buffers to be sent for an asynchronous operation used by the  method.

    */
    open var SendPacketsElements : Optional<dotnet.System_Arr<dotnet.System.Net.Sockets.SendPacketsElement>> {
        get {
            return try! get_SendPacketsElements();
        }
        set(v) {
            return try! set_SendPacketsElements(value: v!);
        }
    }
    /**
    Gets or sets a bitwise combination of  values for an asynchronous operation used by the  method.

    */
    open var SendPacketsFlags : dotnet.System.Net.Sockets.TransmitFileOptions {
        get {
            return try! get_SendPacketsFlags();
        }
        set(v) {
            return try! set_SendPacketsFlags(value: v);
        }
    }
    /**
    Gets or sets the size, in bytes, of the data block used in the send operation.

    */
    open var SendPacketsSendSize : Swift.Int32 {
        get {
            return try! get_SendPacketsSendSize();
        }
        set(v) {
            return try! set_SendPacketsSendSize(value: v);
        }
    }
    /**
    Gets or sets the result of the asynchronous socket operation.

    */
    open var SocketError : dotnet.System.Net.Sockets.SocketError {
        get {
            return try! get_SocketError();
        }
        set(v) {
            return try! set_SocketError(value: v);
        }
    }
    /**
    Gets the results of an asynchronous socket operation or sets the behavior of an asynchronous operation.

    */
    open var SocketFlags : dotnet.System.Net.Sockets.SocketFlags {
        get {
            return try! get_SocketFlags();
        }
        set(v) {
            return try! set_SocketFlags(value: v);
        }
    }
    /**
    Gets or sets a user or application object associated with this asynchronous socket operation.

    */
    open var UserToken : Optional<dotnet.System.Object> {
        get {
            return try! get_UserToken();
        }
        set(v) {
            return try! set_UserToken(value: v!);
        }
    }
} // SocketAsyncEventArgs


// type: System.Net.Sockets.SocketAsyncOperation
    /**
    The type of asynchronous socket operation most recently performed with this context object.

    */
public struct SocketAsyncOperation : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketAsyncOperation_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketAsyncOperation None
    /**
    None of the socket operations.

    */
    public static var None : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_None());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation Accept
    /**
    A socket Accept operation.

    */
    public static var Accept : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_Accept());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation Connect
    /**
    A socket Connect operation.

    */
    public static var Connect : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_Connect());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation Disconnect
    /**
    A socket Disconnect operation.

    */
    public static var Disconnect : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_Disconnect());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation Receive
    /**
    A socket Receive operation.

    */
    public static var Receive : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_Receive());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation ReceiveFrom
    /**
    A socket ReceiveFrom operation.

    */
    public static var ReceiveFrom : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_ReceiveFrom());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation ReceiveMessageFrom
    /**
    A socket ReceiveMessageFrom operation.

    */
    public static var ReceiveMessageFrom : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_ReceiveMessageFrom());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation Send
    /**
    A socket Send operation.

    */
    public static var Send : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_Send());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation SendPackets
    /**
    A socket SendPackets operation.

    */
    public static var SendPackets : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_SendPackets());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketAsyncOperation SendTo
    /**
    A socket SendTo operation.

    */
    public static var SendTo : dotnet.System.Net.Sockets.SocketAsyncOperation {
        get {
        let __return = dotnet.System.Net.Sockets.SocketAsyncOperation(val: System_Net_Sockets_SocketAsyncOperation_get_SendTo());
            return __return;
        }
    }
} // SocketAsyncOperation


// type: System.Net.Sockets.SocketFlags
    /**
    Specifies socket send and receive behaviors.

    */
public struct SocketFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketFlags None
    /**
    Use no flags for this call.

    */
    public static var None : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_None());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags OutOfBand
    /**
    Process out-of-band data.

    */
    public static var OutOfBand : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_OutOfBand());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags Peek
    /**
    Peek at the incoming message.

    */
    public static var Peek : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_Peek());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags DontRoute
    /**
    Send without using routing tables.

    */
    public static var DontRoute : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_DontRoute());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags Truncated
    /**
    The message was too large to fit into the specified buffer and was truncated.

    */
    public static var Truncated : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_Truncated());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags ControlDataTruncated
    /**
    Indicates that the control data did not fit into an internal 64-KB buffer and was truncated.

    */
    public static var ControlDataTruncated : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_ControlDataTruncated());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags Broadcast
    /**
    Indicates a broadcast packet.

    */
    public static var Broadcast : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_Broadcast());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags Multicast
    /**
    Indicates a multicast packet.

    */
    public static var Multicast : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_Multicast());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketFlags Partial
    /**
    Partial send or receive for message.

    */
    public static var Partial : dotnet.System.Net.Sockets.SocketFlags {
        get {
        let __return = dotnet.System.Net.Sockets.SocketFlags(val: System_Net_Sockets_SocketFlags_get_Partial());
            return __return;
        }
    }
} // SocketFlags


// type: System.Net.Sockets.SocketInformation
// boxed value type
    /**
    Encapsulates the information that is necessary to duplicate a .

    */
public final class SocketInformation
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketInformation_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets or sets the options for a .

    */
    public var Options : dotnet.System.Net.Sockets.SocketInformationOptions {
        get {
            return try! get_Options();
        }
        set(v) {
            return try! set_Options(value: v);
        }
    }
    /**
    Gets or sets the protocol information for a .

    */
    public var ProtocolInformation : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_ProtocolInformation();
        }
        set(v) {
            return try! set_ProtocolInformation(value: v);
        }
    }
    public override init() {
        let h = System_Net_Sockets_SocketInformation_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.Net.Sockets.SocketInformationOptions get_Options()
// docid: M:System.Net.Sockets.SocketInformation.get_Options
    public func get_Options() throws -> dotnet.System.Net.Sockets.SocketInformationOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketInformation_SocketInformationOptions__get_Options_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SocketInformationOptions(val: __return);
        }
    }
    // [IsSpecialName] void set_Options(System.Net.Sockets.SocketInformationOptions)
// docid: M:System.Net.Sockets.SocketInformation.set_Options(System.Net.Sockets.SocketInformationOptions)
    public func set_Options(value : dotnet.System.Net.Sockets.SocketInformationOptions) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketInformation_void__set_Options_0__1__SocketInformationOptions(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_ProtocolInformation()
// docid: M:System.Net.Sockets.SocketInformation.get_ProtocolInformation
    public func get_ProtocolInformation() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketInformation_u8Array__get_ProtocolInformation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ProtocolInformation(System.Byte[])
// docid: M:System.Net.Sockets.SocketInformation.set_ProtocolInformation(System.Byte[])
    public func set_ProtocolInformation(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_SocketInformation_void__set_ProtocolInformation_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SocketInformation


// type: System.Net.Sockets.SocketInformationOptions
    /**
    Describes states for a .

    */
public struct SocketInformationOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketInformationOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketInformationOptions NonBlocking
    /**
    The  is nonblocking.

    */
    public static var NonBlocking : dotnet.System.Net.Sockets.SocketInformationOptions {
        get {
        let __return = dotnet.System.Net.Sockets.SocketInformationOptions(val: System_Net_Sockets_SocketInformationOptions_get_NonBlocking());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketInformationOptions Connected
    /**
    The  is connected.

    */
    public static var Connected : dotnet.System.Net.Sockets.SocketInformationOptions {
        get {
        let __return = dotnet.System.Net.Sockets.SocketInformationOptions(val: System_Net_Sockets_SocketInformationOptions_get_Connected());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketInformationOptions Listening
    /**
    The  is listening for new connections.

    */
    public static var Listening : dotnet.System.Net.Sockets.SocketInformationOptions {
        get {
        let __return = dotnet.System.Net.Sockets.SocketInformationOptions(val: System_Net_Sockets_SocketInformationOptions_get_Listening());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketInformationOptions UseOnlyOverlappedIO
    /**
    The  uses overlapped I/O.

    */
    public static var UseOnlyOverlappedIO : dotnet.System.Net.Sockets.SocketInformationOptions {
        get {
        let __return = dotnet.System.Net.Sockets.SocketInformationOptions(val: System_Net_Sockets_SocketInformationOptions_get_UseOnlyOverlappedIO());
            return __return;
        }
    }
} // SocketInformationOptions


// type: System.Net.Sockets.SocketOptionLevel
    /**
    Defines socket option levels for the  and  methods.

    */
public struct SocketOptionLevel : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketOptionLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketOptionLevel IP
    /**
    
         options apply only to IP sockets.

    */
    public static var IP : dotnet.System.Net.Sockets.SocketOptionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionLevel(val: System_Net_Sockets_SocketOptionLevel_get_IP());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionLevel Tcp
    /**
    
         options apply only to TCP sockets.

    */
    public static var Tcp : dotnet.System.Net.Sockets.SocketOptionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionLevel(val: System_Net_Sockets_SocketOptionLevel_get_Tcp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionLevel Udp
    /**
    
         options apply only to UDP sockets.

    */
    public static var Udp : dotnet.System.Net.Sockets.SocketOptionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionLevel(val: System_Net_Sockets_SocketOptionLevel_get_Udp());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionLevel IPv6
    /**
    
         options apply only to IPv6 sockets.

    */
    public static var IPv6 : dotnet.System.Net.Sockets.SocketOptionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionLevel(val: System_Net_Sockets_SocketOptionLevel_get_IPv6());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionLevel Socket
    /**
    
         options apply to all sockets.

    */
    public static var Socket : dotnet.System.Net.Sockets.SocketOptionLevel {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionLevel(val: System_Net_Sockets_SocketOptionLevel_get_Socket());
            return __return;
        }
    }
} // SocketOptionLevel


// type: System.Net.Sockets.SocketOptionName
    /**
    Defines configuration option names.

    */
public struct SocketOptionName : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketOptionName_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketOptionName DontLinger
    /**
    Close the socket gracefully without lingering.

    */
    public static var DontLinger : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_DontLinger());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName ExclusiveAddressUse
    /**
    Enables a socket to be bound for exclusive access.

    */
    public static var ExclusiveAddressUse : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_ExclusiveAddressUse());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName Debug
    /**
    Record debugging information.

    */
    public static var Debug : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_Debug());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName IPOptions
    /**
    Specifies the IP options to be inserted into outgoing datagrams.

    */
    public static var IPOptions : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_IPOptions());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName NoChecksum
    /**
    Send UDP datagrams with checksum set to zero.

    */
    public static var NoChecksum : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_NoChecksum());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName NoDelay
    /**
    Disables the Nagle algorithm for send coalescing.

    */
    public static var NoDelay : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_NoDelay());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName AcceptConnection
    /**
    The socket is listening.

    */
    public static var AcceptConnection : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_AcceptConnection());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName BsdUrgent
    /**
    Use urgent data as defined in RFC-1222. This option can be set only once; after it is set, it cannot be turned off.

    */
    public static var BsdUrgent : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_BsdUrgent());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName Expedited
    /**
    Use expedited data as defined in RFC-1222. This option can be set only once; after it is set, it cannot be turned off.

    */
    public static var Expedited : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_Expedited());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName HeaderIncluded
    /**
    Indicates that the application provides the IP header for outgoing datagrams.

    */
    public static var HeaderIncluded : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_HeaderIncluded());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName TcpKeepAliveTime
    /**
    The number of seconds a TCP connection will remain alive/idle before keepalive probes are sent to the remote.

    */
    public static var TcpKeepAliveTime : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_TcpKeepAliveTime());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName TypeOfService
    /**
    Change the IP header type of the service field.

    */
    public static var TypeOfService : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_TypeOfService());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName IpTimeToLive
    /**
    Set the IP header Time-to-Live field.

    */
    public static var IpTimeToLive : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_IpTimeToLive());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName ReuseAddress
    /**
    Allows the socket to be bound to an address that is already in use.

    */
    public static var ReuseAddress : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_ReuseAddress());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName KeepAlive
    /**
    Use keep-alives.

    */
    public static var KeepAlive : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_KeepAlive());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName MulticastInterface
    /**
    Set the interface for outgoing multicast packets.

    */
    public static var MulticastInterface : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_MulticastInterface());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName MulticastTimeToLive
    /**
    An IP multicast Time to Live.

    */
    public static var MulticastTimeToLive : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_MulticastTimeToLive());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName MulticastLoopback
    /**
    An IP multicast loopback.

    */
    public static var MulticastLoopback : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_MulticastLoopback());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName AddMembership
    /**
    Add an IP group membership.

    */
    public static var AddMembership : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_AddMembership());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName DropMembership
    /**
    Drop an IP group membership.

    */
    public static var DropMembership : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_DropMembership());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName DontFragment
    /**
    Do not fragment IP datagrams.

    */
    public static var DontFragment : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_DontFragment());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName AddSourceMembership
    /**
    Join a source group.

    */
    public static var AddSourceMembership : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_AddSourceMembership());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName DontRoute
    /**
    Do not route; send the packet directly to the interface addresses.

    */
    public static var DontRoute : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_DontRoute());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName DropSourceMembership
    /**
    Drop a source group.

    */
    public static var DropSourceMembership : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_DropSourceMembership());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName TcpKeepAliveRetryCount
    /**
    The number of TCP keep alive probes that will be sent before the connection is terminated.

    */
    public static var TcpKeepAliveRetryCount : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_TcpKeepAliveRetryCount());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName BlockSource
    /**
    Block data from a source.

    */
    public static var BlockSource : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_BlockSource());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName TcpKeepAliveInterval
    /**
    The number of seconds a TCP connection will wait for a keepalive response before sending another keepalive probe.

    */
    public static var TcpKeepAliveInterval : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_TcpKeepAliveInterval());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName UnblockSource
    /**
    Unblock a previously blocked source.

    */
    public static var UnblockSource : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_UnblockSource());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName PacketInformation
    /**
    Return information about received packets.

    */
    public static var PacketInformation : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_PacketInformation());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName ChecksumCoverage
    /**
    Set or get the UDP checksum coverage.

    */
    public static var ChecksumCoverage : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_ChecksumCoverage());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName HopLimit
    /**
    Specifies the maximum number of router hops for an Internet Protocol version 6 (IPv6) packet. This is similar to Time to Live (TTL) for Internet Protocol version 4.

    */
    public static var HopLimit : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_HopLimit());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName IPProtectionLevel
    /**
    Enables restriction of a IPv6 socket to a specified scope, such as addresses with the same link local or site local prefix. This socket option enables applications to place access restrictions on IPv6 sockets. Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks. This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required. This socket option has defined protection levels specified in the  enumeration.

    */
    public static var IPProtectionLevel : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_IPProtectionLevel());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName IPv6Only
    /**
    Indicates if a socket created for the AF_INET6 address family is restricted to IPv6 communications only. Sockets created for the AF_INET6 address family may be used for both IPv6 and IPv4 communications. Some applications may want to restrict their use of a socket created for the AF_INET6 address family to IPv6 communications only. When this value is non-zero (the default on Windows), a socket created for the AF_INET6 address family can be used to send and receive IPv6 packets only. When this value is zero, a socket created for the AF_INET6 address family can be used to send and receive packets to and from an IPv6 address or an IPv4 address. Note that the ability to interact with an IPv4 address requires the use of IPv4 mapped addresses. This socket option is supported on Windows Vista or later.

    */
    public static var IPv6Only : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_IPv6Only());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName Broadcast
    /**
    Permit sending broadcast messages on the socket.

    */
    public static var Broadcast : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_Broadcast());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName UseLoopback
    /**
    Bypass hardware when possible.

    */
    public static var UseLoopback : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_UseLoopback());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName Linger
    /**
    Linger on close if unsent data is present.

    */
    public static var Linger : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_Linger());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName OutOfBandInline
    /**
    Receives out-of-band data in the normal data stream.

    */
    public static var OutOfBandInline : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_OutOfBandInline());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName SendBuffer
    /**
    Specifies the total per-socket buffer space reserved for sends. This is unrelated to the maximum message size or the size of a TCP window.

    */
    public static var SendBuffer : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_SendBuffer());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName ReceiveBuffer
    /**
    Specifies the total per-socket buffer space reserved for receives. This is unrelated to the maximum message size or the size of a TCP window.

    */
    public static var ReceiveBuffer : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_ReceiveBuffer());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName SendLowWater
    /**
    Specifies the low water mark for  operations.

    */
    public static var SendLowWater : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_SendLowWater());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName ReceiveLowWater
    /**
    Specifies the low water mark for  operations.

    */
    public static var ReceiveLowWater : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_ReceiveLowWater());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName SendTimeout
    /**
    Send a time-out. This option applies only to synchronous methods; it has no effect on asynchronous methods such as the  method.

    */
    public static var SendTimeout : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_SendTimeout());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName ReceiveTimeout
    /**
    Receive a time-out. This option applies only to synchronous methods; it has no effect on asynchronous methods such as the  method.

    */
    public static var ReceiveTimeout : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_ReceiveTimeout());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName Error
    /**
    Gets the error status and clear.

    */
    public static var Error : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_Error());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName Type
    /**
    Gets the socket type.

    */
    public static var Type_ : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_Type());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName ReuseUnicastPort
    /**
    Indicates that the system should defer ephemeral port allocation for outbound connections. This is equivalent to using the Winsock2 SO_REUSE_UNICASTPORT socket option.

    */
    public static var ReuseUnicastPort : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_ReuseUnicastPort());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName UpdateAcceptContext
    /**
    Updates an accepted socket's properties by using those of an existing socket. This is equivalent to using the Winsock2 SO_UPDATE_ACCEPT_CONTEXT socket option and is supported only on connection-oriented sockets.

    */
    public static var UpdateAcceptContext : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_UpdateAcceptContext());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName UpdateConnectContext
    /**
    Updates a connected socket's properties by using those of an existing socket. This is equivalent to using the Winsock2 SO_UPDATE_CONNECT_CONTEXT socket option and is supported only on connection-oriented sockets.

    */
    public static var UpdateConnectContext : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_UpdateConnectContext());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketOptionName MaxConnections
    /**
    Not supported; will throw a  if used.

    */
    public static var MaxConnections : dotnet.System.Net.Sockets.SocketOptionName {
        get {
        let __return = dotnet.System.Net.Sockets.SocketOptionName(val: System_Net_Sockets_SocketOptionName_get_MaxConnections());
            return __return;
        }
    }
} // SocketOptionName


// type: System.Net.Sockets.SocketReceiveFromResult
// boxed value type
    /**
    The result of a  operation.

    */
public final class SocketReceiveFromResult
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketReceiveFromResult_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Net_Sockets_SocketReceiveFromResult_implicit_ctor();
            super.init(hndl: h);
    }
} // SocketReceiveFromResult


// type: System.Net.Sockets.SocketReceiveMessageFromResult
// boxed value type
    /**
    The result of a  operation.

    */
public final class SocketReceiveMessageFromResult
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketReceiveMessageFromResult_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Net_Sockets_SocketReceiveMessageFromResult_implicit_ctor();
            super.init(hndl: h);
    }
} // SocketReceiveMessageFromResult


// type: System.Net.Sockets.SocketShutdown
    /**
    Defines constants that are used by the  method.

    */
public struct SocketShutdown : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketShutdown_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketShutdown Receive
    /**
    Disables a  for receiving. This field is constant.

    */
    public static var Receive : dotnet.System.Net.Sockets.SocketShutdown {
        get {
        let __return = dotnet.System.Net.Sockets.SocketShutdown(val: System_Net_Sockets_SocketShutdown_get_Receive());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketShutdown Send
    /**
    Disables a  for sending. This field is constant.

    */
    public static var Send : dotnet.System.Net.Sockets.SocketShutdown {
        get {
        let __return = dotnet.System.Net.Sockets.SocketShutdown(val: System_Net_Sockets_SocketShutdown_get_Send());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketShutdown Both
    /**
    Disables a  for both sending and receiving. This field is constant.

    */
    public static var Both : dotnet.System.Net.Sockets.SocketShutdown {
        get {
        let __return = dotnet.System.Net.Sockets.SocketShutdown(val: System_Net_Sockets_SocketShutdown_get_Both());
            return __return;
        }
    }
} // SocketShutdown


// type: System.Net.Sockets.SocketTaskExtensions
public struct SocketTaskExtensions {
    // System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptAsync(System.Net.Sockets.Socket)
// docid: M:System.Net.Sockets.SocketTaskExtensions.AcceptAsync(System.Net.Sockets.Socket)
    /**
    Performs an asynchronous operation on to accept an incoming connection attempt on the socket.

    - Parameter socket: The socket that is listening for connections.
    - Returns: An asynchronous task that completes with a  to handle communication with the remote host.

    */
    public static func AcceptAsync(socket : dotnet.System.Net.Sockets.Socket) async throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_System_Net_Sockets_Socket___AcceptAsync_0__1__Socket(&__thrown, socket.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptAsync(System.Net.Sockets.Socket, System.Net.Sockets.Socket)
// docid: M:System.Net.Sockets.SocketTaskExtensions.AcceptAsync(System.Net.Sockets.Socket,System.Net.Sockets.Socket)
    /**
    Performs an asynchronous operation on to accept an incoming connection attempt on the socket.

    - Parameter socket: The socket that is listening for incoming connections.
    - Parameter acceptSocket: The accepted  object. This value may be .
    - Returns: An asynchronous task that completes with a  to handle communication with the remote host.

    */
    public static func AcceptAsync(socket : dotnet.System.Net.Sockets.Socket, acceptSocket : Optional<dotnet.System.Net.Sockets.Socket>) async throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_System_Net_Sockets_Socket___AcceptAsync_0__2__Socket_Socket(&__thrown, socket.get_handle(), acceptSocket?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.Sockets.Socket, System.Net.EndPoint)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.EndPoint)
    /**
    Establishes a connection to a remote host.

    - Parameter socket: The socket that is used for establishing a connection.
    - Parameter remoteEP: An EndPoint that represents the remote device.
    - Returns: An asynchronous Task.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, remoteEP : dotnet.System.Net.EndPoint) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_Task__ConnectAsync_0__2__Socket_EndPoint(&__thrown, socket.get_handle(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.Sockets.Socket, System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.EndPoint,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host.

    - Parameter socket: The socket that is used for establishing a connection.
    - Parameter remoteEP: An EndPoint that represents the remote device.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that represents the asynchronous connection operation.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, remoteEP : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_ValueTask__ConnectAsync_0__3__Socket_EndPoint_CancellationToken(&__thrown, socket.get_handle(), remoteEP.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.Sockets.Socket, System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress,System.Int32)
    /**
    Establishes a connection to a remote host. The host is specified by an IP address and a port number.

    - Parameter socket: The socket to perform the connect operation on.
    - Parameter address: The IP address of the remote host.
    - Parameter port: The port number of the remote host.
    - Returns: A task that represents an asynchronous connection operation.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, address : dotnet.System.Net.IPAddress, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_Task__ConnectAsync_0__3__Socket_IPAddress_i32(&__thrown, socket.get_handle(), address.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.Sockets.Socket, System.Net.IPAddress, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress,System.Int32,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host, which is specified by an IP address and a port number.

    - Parameter socket: The socket to perform the connect operation on.
    - Parameter address: The IP address of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that represents the asynchronous connection operation.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, address : dotnet.System.Net.IPAddress, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_ValueTask__ConnectAsync_0__4__Socket_IPAddress_i32_CancellationToken(&__thrown, socket.get_handle(), address.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.Sockets.Socket, System.Net.IPAddress[], System.Int32)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress[],System.Int32)
    /**
    Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.

    - Parameter socket: The socket that the connect operation is performed on.
    - Parameter addresses: The IP addresses of the remote host.
    - Parameter port: The port number of the remote host.
    - Returns: A task that represents the asynchronous connect operation.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_Task__ConnectAsync_0__3__Socket_IPAddressArray_i32(&__thrown, socket.get_handle(), addresses.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.Sockets.Socket, System.Net.IPAddress[], System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress[],System.Int32,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host, which is specified by an array of IP addresses and a port number.

    - Parameter socket: The socket that the connect operation is performed on.
    - Parameter addresses: The IP addresses of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that represents the asynchronous connection operation.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_ValueTask__ConnectAsync_0__4__Socket_IPAddressArray_i32_CancellationToken(&__thrown, socket.get_handle(), addresses.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.Sockets.Socket, System.String, System.Int32)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.String,System.Int32)
    /**
    Establishes a connection to a remote host. The host is specified by a host name and a port number.

    - Parameter socket: The socket to perform the connect operation on.
    - Parameter host: The name of the remote host.
    - Parameter port: The port number of the remote host.
    - Returns: An asynchronous task.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, host : dotnet.System.String, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_Task__ConnectAsync_0__3__Socket_String_i32(&__thrown, socket.get_handle(), host.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.Sockets.Socket, System.String, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.String,System.Int32,System.Threading.CancellationToken)
    /**
    Establishes a connection to a remote host, which is specified by a host name and a port number.

    - Parameter socket: The socket to perform the connect operation on.
    - Parameter host: The name of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that represents an asynchronous connection operation.

    */
    public static func ConnectAsync(socket : dotnet.System.Net.Sockets.Socket, host : dotnet.System.String, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_ValueTask__ConnectAsync_0__4__Socket_String_i32_CancellationToken(&__thrown, socket.get_handle(), host.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Int32> ReceiveAsync(System.Net.Sockets.Socket, System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ReceiveAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)
    /**
    Receives data from a connected socket.

    - Parameter socket: The socket to perform the receive operation on.
    - Parameter buffer: An array that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: A task that represents the asynchronous receive operation. The value of the  parameter contains the number of bytes received.

    */
    public static func ReceiveAsync(socket : dotnet.System.Net.Sockets.Socket, buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_i32___ReceiveAsync_0__3__Socket_System_ArraySegment_u8__SocketFlags(&__thrown, socket.get_handle(), buffer.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task<System.Int32> ReceiveAsync(System.Net.Sockets.Socket, System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ReceiveAsync(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
    /**
    Receives data from a connected socket.

    - Parameter socket: The socket to perform the receive operation on.
    - Parameter buffers: An array that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: A task that represents the asynchronous receive operation. The value of the  parameter contains the number of bytes received.

    */
    public static func ReceiveAsync(socket : dotnet.System.Net.Sockets.Socket, buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_i32___ReceiveAsync_0__3__Socket_System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags(&__thrown, socket.get_handle(), buffers.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReceiveAsync(System.Net.Sockets.Socket, System.Memory<System.Byte>, System.Net.Sockets.SocketFlags, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ReceiveAsync(System.Net.Sockets.Socket,System.Memory{System.Byte},System.Net.Sockets.SocketFlags,System.Threading.CancellationToken)
    /**
    Receives data from a connected socket.

    - Parameter socket: The socket to perform the receive operation on.
    - Parameter buffer: A region of memory that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that completes with the number of bytes received, or 0 if the end of the stream has been reached.

    */
    public static func ReceiveAsync(socket : dotnet.System.Net.Sockets.Socket, buffer : dotnet.System.Memory_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_ValueTask_i32___ReceiveAsync_0__4__Socket_System_Memory_u8__SocketFlags_CancellationToken(&__thrown, socket.get_handle(), buffer.get_handle(), socketFlags.get_value(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.SocketReceiveFromResult> ReceiveFromAsync(System.Net.Sockets.Socket, System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ReceiveFromAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Receives data from a specified network device.

    - Parameter socket: The socket to perform the ReceiveFrom operation on.
    - Parameter buffer: An array of type Byte that is the storage location for the received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEndPoint: An EndPoint that represents the source of the data.
    - Returns: An asynchronous Task that completes with a SocketReceiveFromResult struct.

    */
    public static func ReceiveFromAsync(socket : dotnet.System.Net.Sockets.Socket, buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEndPoint : dotnet.System.Net.EndPoint) async throws -> dotnet.System.Net.Sockets.SocketReceiveFromResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_System_Net_Sockets_SocketReceiveFromResult___ReceiveFromAsync_0__4__Socket_System_ArraySegment_u8__SocketFlags_EndPoint(&__thrown, socket.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEndPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.SocketReceiveMessageFromResult> ReceiveMessageFromAsync(System.Net.Sockets.Socket, System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.SocketTaskExtensions.ReceiveMessageFromAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Receives the specified number of bytes of data into the specified location of the data buffer, using the specified , and stores the endpoint and packet information.

    - Parameter socket: The socket to perform the operation on.
    - Parameter buffer: An array that is the storage location for received data.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEndPoint: An , that represents the remote server.
    - Returns: An asynchronous Task that completes with a  struct.

    */
    public static func ReceiveMessageFromAsync(socket : dotnet.System.Net.Sockets.Socket, buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEndPoint : dotnet.System.Net.EndPoint) async throws -> dotnet.System.Net.Sockets.SocketReceiveMessageFromResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_System_Net_Sockets_SocketReceiveMessageFromResult___ReceiveMessageFromAsync_0__4__Socket_System_ArraySegment_u8__SocketFlags_EndPoint(&__thrown, socket.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEndPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task<System.Int32> SendAsync(System.Net.Sockets.Socket, System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.SocketTaskExtensions.SendAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)
    /**
    Sends data to a connected socket.

    - Parameter socket: The socket to perform the operation on.
    - Parameter buffer: An array of type Byte that contains the data to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: An asynchronous task that completes with number of bytes sent to the socket if the operation was successful. Otherwise, the task will complete with an invalid socket error.

    */
    public static func SendAsync(socket : dotnet.System.Net.Sockets.Socket, buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_i32___SendAsync_0__3__Socket_System_ArraySegment_u8__SocketFlags(&__thrown, socket.get_handle(), buffer.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.Task<System.Int32> SendAsync(System.Net.Sockets.Socket, System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
// docid: M:System.Net.Sockets.SocketTaskExtensions.SendAsync(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
    /**
    Sends data to a connected socket.

    - Parameter socket: The socket to perform the operation on.
    - Parameter buffers: An array that contains the data to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Returns: An asynchronous task that completes with number of bytes sent to the socket if the operation was successful. Otherwise, the task will complete with an invalid socket error.

    */
    public static func SendAsync(socket : dotnet.System.Net.Sockets.Socket, buffers : dotnet.System.Collections.Generic.IList_1<dotnet.System.ArraySegment_1<Swift.UInt8>>, socketFlags : dotnet.System.Net.Sockets.SocketFlags) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_i32___SendAsync_0__3__Socket_System_Collections_Generic_IList_System_System_ArraySegment_u8___SocketFlags(&__thrown, socket.get_handle(), buffers.get_handle(), socketFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> SendAsync(System.Net.Sockets.Socket, System.ReadOnlyMemory<System.Byte>, System.Net.Sockets.SocketFlags, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.SocketTaskExtensions.SendAsync(System.Net.Sockets.Socket,System.ReadOnlyMemory{System.Byte},System.Net.Sockets.SocketFlags,System.Threading.CancellationToken)
    /**
    Sends data to a connected socket.

    - Parameter socket: The socket to perform the operation on.
    - Parameter buffer: A region of memory that contains the data to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that completes with number of bytes sent to the socket if the operation was successful. Otherwise, the task will complete with an invalid socket error.

    */
    public static func SendAsync(socket : dotnet.System.Net.Sockets.Socket, buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_ValueTask_i32___SendAsync_0__4__Socket_System_ReadOnlyMemory_u8__SocketFlags_CancellationToken(&__thrown, socket.get_handle(), buffer.get_handle(), socketFlags.get_value(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Int32> SendToAsync(System.Net.Sockets.Socket, System.ArraySegment<System.Byte>, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
// docid: M:System.Net.Sockets.SocketTaskExtensions.SendToAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    /**
    Sends data asynchronously to a specific remote host.

    - Parameter socket: The socket to perform the operation on.
    - Parameter buffer: An array that contains the data to send.
    - Parameter socketFlags: A bitwise combination of the  values.
    - Parameter remoteEP: An  that represents the remote device.
    - Returns: An asynchronous task that completes with number of bytes sent if the operation was successful. Otherwise, the task will complete with an invalid socket error.

    */
    public static func SendToAsync(socket : dotnet.System.Net.Sockets.Socket, buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, socketFlags : dotnet.System.Net.Sockets.SocketFlags, remoteEP : dotnet.System.Net.EndPoint) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketTaskExtensions_System_Threading_Tasks_Task_i32___SendToAsync_0__4__Socket_System_ArraySegment_u8__SocketFlags_EndPoint(&__thrown, socket.get_handle(), buffer.get_handle(), socketFlags.get_value(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
} // SocketTaskExtensions


// type: System.Net.Sockets.SocketType
    /**
    Specifies the type of socket that an instance of the  class represents.

    */
public struct SocketType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketType Unknown
    /**
    Specifies an unknown  type.

    */
    public static var Unknown : dotnet.System.Net.Sockets.SocketType {
        get {
        let __return = dotnet.System.Net.Sockets.SocketType(val: System_Net_Sockets_SocketType_get_Unknown());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketType Stream
    /**
    Supports reliable, two-way, connection-based byte streams without the duplication of data and without preservation of boundaries. A  of this type communicates with a single peer and requires a remote host connection before communication can begin.  uses the Transmission Control Protocol (.) and the . address family.

    */
    public static var Stream : dotnet.System.Net.Sockets.SocketType {
        get {
        let __return = dotnet.System.Net.Sockets.SocketType(val: System_Net_Sockets_SocketType_get_Stream());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketType Dgram
    /**
    Supports datagrams, which are connectionless, unreliable messages of a fixed (typically small) maximum length. Messages might be lost or duplicated and might arrive out of order. A  of type  requires no connection prior to sending and receiving data, and can communicate with multiple peers.  uses the Datagram Protocol (.) and the . address family.

    */
    public static var Dgram : dotnet.System.Net.Sockets.SocketType {
        get {
        let __return = dotnet.System.Net.Sockets.SocketType(val: System_Net_Sockets_SocketType_get_Dgram());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketType Raw
    /**
    Supports access to the underlying transport protocol. Using , you can communicate using protocols like Internet Control Message Protocol (.) and Internet Group Management Protocol (.). Your application must provide a complete IP header when sending. Received datagrams return with the IP header and options intact.

    */
    public static var Raw : dotnet.System.Net.Sockets.SocketType {
        get {
        let __return = dotnet.System.Net.Sockets.SocketType(val: System_Net_Sockets_SocketType_get_Raw());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketType Rdm
    /**
    Supports connectionless, message-oriented, reliably delivered messages, and preserves message boundaries in data. Rdm (Reliably Delivered Messages) messages arrive unduplicated and in order. Furthermore, the sender is notified if messages are lost. If you initialize a  using , you do not require a remote host connection before sending and receiving data. With , you can communicate with multiple peers.

    */
    public static var Rdm : dotnet.System.Net.Sockets.SocketType {
        get {
        let __return = dotnet.System.Net.Sockets.SocketType(val: System_Net_Sockets_SocketType_get_Rdm());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketType Seqpacket
    /**
    Provides connection-oriented and reliable two-way transfer of ordered byte streams across a network.  does not duplicate data, and it preserves boundaries within the data stream. A  of type  communicates with a single peer and requires a remote host connection before communication can begin.

    */
    public static var Seqpacket : dotnet.System.Net.Sockets.SocketType {
        get {
        let __return = dotnet.System.Net.Sockets.SocketType(val: System_Net_Sockets_SocketType_get_Seqpacket());
            return __return;
        }
    }
} // SocketType


// type: System.Net.Sockets.TcpClient
    /**
    Provides client connections for TCP network services.

    */
open class TcpClient
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_TcpClient_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_TcpClient_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Net.Sockets.TcpClient.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_TcpClient_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)
    /**
    Initializes a new instance of the  class and binds it to the specified local endpoint.

    - Parameter localEP: The  to which you bind the TCP .
    */
    public init(localEP : dotnet.System.Net.IPEndPoint) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_TcpClient_ctor_0__1__IPEndPoint(&__thrown, localEP.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.AddressFamily)
// docid: M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)
    /**
    Initializes a new instance of the  class with the specified family.

    - Parameter family: The  of the IP protocol.
    */
    public init(family : dotnet.System.Net.Sockets.AddressFamily) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_TcpClient_ctor_0__1__AddressFamily(&__thrown, family.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32)
// docid: M:System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)
    /**
    Initializes a new instance of the  class and connects to the specified port on the specified host.

    - Parameter hostname: The DNS name of the remote host to which you intend to connect.
    - Parameter port: The port number of the remote host to which you intend to connect.
    */
    public init(hostname : dotnet.System.String, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_TcpClient_ctor_0__2__String_i32(&__thrown, hostname.get_handle(), port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginConnect(System.Net.IPAddress, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request for a remote host connection. The remote host is specified by an  and a port number ().

    - Parameter address: The  of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter requestCallback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the connect operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  object that references the asynchronous connection.

    */
    open func BeginConnect(address : dotnet.System.Net.IPAddress, port : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_IAsyncResult__BeginConnect_0__4__IPAddress_i32_AsyncCallback_Object(&__thrown, self.get_handle(), address.get_handle(), port, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginConnect(address : dotnet.System.Net.IPAddress, port : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginConnect(address: address, port: port, requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginConnect(System.Net.IPAddress[], System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request for a remote host connection. The remote host is specified by an  array and a port number ().

    - Parameter addresses: At least one  that designates the remote hosts.
    - Parameter port: The port number of the remote hosts.
    - Parameter requestCallback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the connect operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  object that references the asynchronous connection.

    */
    open func BeginConnect(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_IAsyncResult__BeginConnect_0__4__IPAddressArray_i32_AsyncCallback_Object(&__thrown, self.get_handle(), addresses.get_handle(), port, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginConnect(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginConnect(addresses: addresses, port: port, requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginConnect(System.String, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.TcpClient.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous request for a remote host connection. The remote host is specified by a host name () and a port number ().

    - Parameter host: The name of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter requestCallback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the connect operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  object that references the asynchronous connection.

    */
    open func BeginConnect(host : dotnet.System.String, port : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_IAsyncResult__BeginConnect_0__4__String_i32_AsyncCallback_Object(&__thrown, self.get_handle(), host.get_handle(), port, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginConnect(host : dotnet.System.String, port : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginConnect(host: host, port: port, requestCallback: del_requestCallback, state: state);
    }
    // void Close()
// docid: M:System.Net.Sockets.TcpClient.Close
    /**
    Disposes this  instance and requests that the underlying TCP connection be closed.

    */
    open func Close() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__Close_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress,System.Int32)
    /**
    Connects the client to a remote TCP host using the specified IP address and port number.

    - Parameter address: The  of the host to which you intend to connect.
    - Parameter port: The port number to which you intend to connect.
    */
    open func Connect(address : dotnet.System.Net.IPAddress, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__Connect_0__2__IPAddress_i32(&__thrown, self.get_handle(), address.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.IPAddress[], System.Int32)
// docid: M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress[],System.Int32)
    /**
    Connects the client to a remote TCP host using the specified IP addresses and port number.

    - Parameter ipAddresses: The  array of the host to which you intend to connect.
    - Parameter port: The port number to which you intend to connect.
    */
    open func Connect(ipAddresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__Connect_0__2__IPAddressArray_i32(&__thrown, self.get_handle(), ipAddresses.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.TcpClient.Connect(System.Net.IPEndPoint)
    /**
    Connects the client to a remote TCP host using the specified remote network endpoint.

    - Parameter remoteEP: The  to which you intend to connect.
    */
    open func Connect(remoteEP : dotnet.System.Net.IPEndPoint) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__Connect_0__1__IPEndPoint(&__thrown, self.get_handle(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.String, System.Int32)
// docid: M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
    /**
    Connects the client to the specified port on the specified host.

    - Parameter hostname: The DNS name of the remote host to which you intend to connect.
    - Parameter port: The port number of the remote host to which you intend to connect.
    */
    open func Connect(hostname : dotnet.System.String, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__Connect_0__2__String_i32(&__thrown, self.get_handle(), hostname.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)
    /**
    Connects the client to a remote TCP host using the specified IP address and port number as an asynchronous operation.

    - Parameter address: The  of the host to which you intend to connect.
    - Parameter port: The port number to which you intend to connect.
    - Returns: The task object representing the asynchronous operation.

    */
    open func ConnectAsync(address : dotnet.System.Net.IPAddress, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_Task__ConnectAsync_0__2__IPAddress_i32(&__thrown, self.get_handle(), address.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.IPAddress[], System.Int32)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)
    /**
    Connects the client to a remote TCP host using the specified IP addresses and port number as an asynchronous operation.

    - Parameter addresses: The  array of the host to which you intend to connect.
    - Parameter port: The port number to which you intend to connect.
    - Returns: The task object representing the asynchronous operation.

    */
    open func ConnectAsync(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_Task__ConnectAsync_0__2__IPAddressArray_i32(&__thrown, self.get_handle(), addresses.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.String, System.Int32)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)
    /**
    Connects the client to the specified TCP port on the specified host as an asynchronous operation.

    - Parameter host: The DNS name of the remote host to which you intend to connect.
    - Parameter port: The port number of the remote host to which you intend to connect.
    - Returns: The task object representing the asynchronous operation.

    */
    open func ConnectAsync(host : dotnet.System.String, port : Swift.Int32) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_Task__ConnectAsync_0__2__String_i32(&__thrown, self.get_handle(), host.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPEndPoint)
    /**
    Connects the client to a remote TCP host using the specified endpoint as an asynchronous operation.

    - Parameter remoteEP: The  to which you intend to connect.
    - Returns: A task representing the asynchronous operation.

    */
    open func ConnectAsync(remoteEP : dotnet.System.Net.IPEndPoint) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_Task__ConnectAsync_0__1__IPEndPoint(&__thrown, self.get_handle(), remoteEP.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).to_async_void();
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.IPAddress, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32,System.Threading.CancellationToken)
    /**
    Connects the client to a remote TCP host using the specified IP address and port number as an asynchronous operation.

    - Parameter address: The IP address of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that represents the asynchronous connection operation.

    */
    open func ConnectAsync(address : dotnet.System.Net.IPAddress, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_ValueTask__ConnectAsync_0__3__IPAddress_i32_CancellationToken(&__thrown, self.get_handle(), address.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.IPAddress[], System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32,System.Threading.CancellationToken)
    /**
    Connects the client to a remote TCP host using the specified IP addresses and port number as an asynchronous operation.

    - Parameter addresses: The array of IP address of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that represents the asynchronous connection operation.

    */
    open func ConnectAsync(addresses : dotnet.System_Arr<dotnet.System.Net.IPAddress>, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_ValueTask__ConnectAsync_0__3__IPAddressArray_i32_CancellationToken(&__thrown, self.get_handle(), addresses.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.String, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32,System.Threading.CancellationToken)
    /**
    Connects the client to the specified TCP port on the specified host as an asynchronous operation.

    - Parameter host: The DNS name of the remote host.
    - Parameter port: The port number of the remote host.
    - Parameter cancellationToken: A cancellation token that can be used to signal the asynchronous operation should be canceled.
    - Returns: A task that represents the asynchronous connection operation.

    */
    open func ConnectAsync(host : dotnet.System.String, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_ValueTask__ConnectAsync_0__3__String_i32_CancellationToken(&__thrown, self.get_handle(), host.get_handle(), port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask ConnectAsync(System.Net.IPEndPoint, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPEndPoint,System.Threading.CancellationToken)
    /**
    Connects the client to a remote TCP host using the specified endpoint as an asynchronous operation.

    - Parameter remoteEP: The  to which you intend to connect.
    - Parameter cancellationToken: A cancellation token used to propagate notification that this operation should be canceled.
    - Returns: A task representing the asynchronous operation.

    */
    open func ConnectAsync(remoteEP : dotnet.System.Net.IPEndPoint, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_ValueTask__ConnectAsync_0__2__IPEndPoint_CancellationToken(&__thrown, self.get_handle(), remoteEP.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Net.Sockets.TcpClient.Dispose
    /**
    Releases the managed and unmanaged resources used by the .

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EndConnect(System.IAsyncResult)
// docid: M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)
    /**
    Ends a pending asynchronous connection attempt.

    - Parameter asyncResult: An  object returned by a call to .
    */
    open func EndConnect(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__EndConnect_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Net.Sockets.NetworkStream GetStream()
// docid: M:System.Net.Sockets.TcpClient.GetStream
    /**
    Returns the  used to send and receive data.

    - Returns: The underlying .

    */
    open func GetStream() throws -> dotnet.System.Net.Sockets.NetworkStream {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_NetworkStream__GetStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.NetworkStream(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Available()
// docid: M:System.Net.Sockets.TcpClient.get_Available
    open func get_Available() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_i32__get_Available_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.Socket get_Client()
// docid: M:System.Net.Sockets.TcpClient.get_Client
    open func get_Client() throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_Socket__get_Client_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Client(System.Net.Sockets.Socket)
// docid: M:System.Net.Sockets.TcpClient.set_Client(System.Net.Sockets.Socket)
    open func set_Client(value : dotnet.System.Net.Sockets.Socket) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_Client_0__1__Socket(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_Connected()
// docid: M:System.Net.Sockets.TcpClient.get_Connected
    open func get_Connected() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_bool__get_Connected_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_ExclusiveAddressUse()
// docid: M:System.Net.Sockets.TcpClient.get_ExclusiveAddressUse
    open func get_ExclusiveAddressUse() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_bool__get_ExclusiveAddressUse_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ExclusiveAddressUse(bool)
// docid: M:System.Net.Sockets.TcpClient.set_ExclusiveAddressUse(System.Boolean)
    open func set_ExclusiveAddressUse(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_ExclusiveAddressUse_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.LingerOption get_LingerState()
// docid: M:System.Net.Sockets.TcpClient.get_LingerState
    open func get_LingerState() throws -> Optional<dotnet.System.Net.Sockets.LingerOption> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_LingerOption__get_LingerState_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Sockets.LingerOption(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LingerState(System.Net.Sockets.LingerOption)
// docid: M:System.Net.Sockets.TcpClient.set_LingerState(System.Net.Sockets.LingerOption)
    open func set_LingerState(value : Optional<dotnet.System.Net.Sockets.LingerOption>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_LingerState_0__1__LingerOption(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_NoDelay()
// docid: M:System.Net.Sockets.TcpClient.get_NoDelay
    open func get_NoDelay() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_bool__get_NoDelay_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_NoDelay(bool)
// docid: M:System.Net.Sockets.TcpClient.set_NoDelay(System.Boolean)
    open func set_NoDelay(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_NoDelay_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ReceiveBufferSize()
// docid: M:System.Net.Sockets.TcpClient.get_ReceiveBufferSize
    open func get_ReceiveBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_i32__get_ReceiveBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ReceiveBufferSize(System.Int32)
// docid: M:System.Net.Sockets.TcpClient.set_ReceiveBufferSize(System.Int32)
    open func set_ReceiveBufferSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_ReceiveBufferSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ReceiveTimeout()
// docid: M:System.Net.Sockets.TcpClient.get_ReceiveTimeout
    open func get_ReceiveTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_i32__get_ReceiveTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ReceiveTimeout(System.Int32)
// docid: M:System.Net.Sockets.TcpClient.set_ReceiveTimeout(System.Int32)
    open func set_ReceiveTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_ReceiveTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_SendBufferSize()
// docid: M:System.Net.Sockets.TcpClient.get_SendBufferSize
    open func get_SendBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_i32__get_SendBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_SendBufferSize(System.Int32)
// docid: M:System.Net.Sockets.TcpClient.set_SendBufferSize(System.Int32)
    open func set_SendBufferSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_SendBufferSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_SendTimeout()
// docid: M:System.Net.Sockets.TcpClient.get_SendTimeout
    open func get_SendTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpClient_i32__get_SendTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_SendTimeout(System.Int32)
// docid: M:System.Net.Sockets.TcpClient.set_SendTimeout(System.Int32)
    open func set_SendTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpClient_void__set_SendTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the amount of data that has been received from the network and is available to be read.

    */
    open var Available : Swift.Int32 {
        get {
            return try! get_Available();
        }
    }
    /**
    Gets or sets the underlying .

    */
    open var Client : dotnet.System.Net.Sockets.Socket {
        get {
            return try! get_Client();
        }
        set(v) {
            return try! set_Client(value: v);
        }
    }
    /**
    Gets a value indicating whether the underlying  for a  is connected to a remote host.

    */
    open var Connected : Bool {
        get {
            return try! get_Connected();
        }
    }
    /**
    Gets or sets a  value that specifies whether the  allows only one client to use a port.

    */
    open var ExclusiveAddressUse : Bool {
        get {
            return try! get_ExclusiveAddressUse();
        }
        set(v) {
            return try! set_ExclusiveAddressUse(value: v);
        }
    }
    /**
    Gets or sets information about the linger state of the associated socket.

    */
    open var LingerState : Optional<dotnet.System.Net.Sockets.LingerOption> {
        get {
            return try! get_LingerState();
        }
        set(v) {
            return try! set_LingerState(value: v!);
        }
    }
    /**
    Gets or sets a value that disables a delay when send or receive buffers are not full.

    */
    open var NoDelay : Bool {
        get {
            return try! get_NoDelay();
        }
        set(v) {
            return try! set_NoDelay(value: v);
        }
    }
    /**
    Gets or sets the size of the receive buffer.

    */
    open var ReceiveBufferSize : Swift.Int32 {
        get {
            return try! get_ReceiveBufferSize();
        }
        set(v) {
            return try! set_ReceiveBufferSize(value: v);
        }
    }
    /**
    Gets or sets the amount of time a  will wait to receive data once a read operation is initiated.

    */
    open var ReceiveTimeout : Swift.Int32 {
        get {
            return try! get_ReceiveTimeout();
        }
        set(v) {
            return try! set_ReceiveTimeout(value: v);
        }
    }
    /**
    Gets or sets the size of the send buffer.

    */
    open var SendBufferSize : Swift.Int32 {
        get {
            return try! get_SendBufferSize();
        }
        set(v) {
            return try! set_SendBufferSize(value: v);
        }
    }
    /**
    Gets or sets the amount of time a  will wait for a send operation to complete successfully.

    */
    open var SendTimeout : Swift.Int32 {
        get {
            return try! get_SendTimeout();
        }
        set(v) {
            return try! set_SendTimeout(value: v);
        }
    }
} // TcpClient


// type: System.Net.Sockets.TcpListener
    /**
    Listens for connections from TCP network clients.

    */
open class TcpListener
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_TcpListener_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_TcpListener_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Net.Sockets.TcpListener.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class that listens on the specified port.

    - Parameter port: The port on which to listen for incoming connection attempts.
    */
    public init(port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_TcpListener_ctor_0__1__i32(&__thrown, port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
    /**
    Initializes a new instance of the  class that listens for incoming connection attempts on the specified local IP address and port number.

    - Parameter localaddr: An  that represents the local IP address.
    - Parameter port: The port on which to listen for incoming connection attempts.
    */
    public init(localaddr : dotnet.System.Net.IPAddress, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_TcpListener_ctor_0__2__IPAddress_i32(&__thrown, localaddr.get_handle(), port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
    /**
    Initializes a new instance of the  class with the specified local endpoint.

    - Parameter localEP: An  that represents the local endpoint to which to bind the listener .
    */
    public init(localEP : dotnet.System.Net.IPEndPoint) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_TcpListener_ctor_0__1__IPEndPoint(&__thrown, localEP.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Net.Sockets.Socket AcceptSocket()
// docid: M:System.Net.Sockets.TcpListener.AcceptSocket
    /**
    Accepts a pending connection request.

    - Returns: A  used to send and receive data.

    */
    open func AcceptSocket() throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_Socket__AcceptSocket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptSocketAsync()
// docid: M:System.Net.Sockets.TcpListener.AcceptSocketAsync
    /**
    Accepts a pending connection request as an asynchronous operation.

    - Returns: The task object representing the asynchronous operation. The  property on the task object returns a  used to send and receive data.

    */
    open func AcceptSocketAsync() async throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_System_Threading_Tasks_Task_System_Net_Sockets_Socket___AcceptSocketAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Sockets.Socket> AcceptSocketAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.TcpListener.AcceptSocketAsync(System.Threading.CancellationToken)
    /**
    Accepts a pending connection request as a cancellable asynchronous operation.

    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation.
    - Returns: The task object representing the asynchronous operation. The  property on the task object returns a  used to send and receive data.

    */
    open func AcceptSocketAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Sockets.Socket> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_System_Threading_Tasks_ValueTask_System_Net_Sockets_Socket___AcceptSocketAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Net.Sockets.TcpClient AcceptTcpClient()
// docid: M:System.Net.Sockets.TcpListener.AcceptTcpClient
    /**
    Accepts a pending connection request.

    - Returns: A  used to send and receive data.

    */
    open func AcceptTcpClient() throws -> dotnet.System.Net.Sockets.TcpClient {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_TcpClient__AcceptTcpClient_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.TcpClient(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.TcpClient> AcceptTcpClientAsync()
// docid: M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync
    /**
    Accepts a pending connection request as an asynchronous operation.

    - Returns: The task object representing the asynchronous operation. The  property on the task object returns a  used to send and receive data.

    */
    open func AcceptTcpClientAsync() async throws -> dotnet.System.Net.Sockets.TcpClient {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_System_Threading_Tasks_Task_System_Net_Sockets_TcpClient___AcceptTcpClientAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Sockets.TcpClient> AcceptTcpClientAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync(System.Threading.CancellationToken)
    /**
    Accepts a pending connection request as a cancellable asynchronous operation.

    - Parameter cancellationToken: A cancellation token that can be used to cancel the asynchronous operation
    - Returns: The task object representing the asynchronous operation. The  property on the task object returns a  used to send and receive data.

    */
    open func AcceptTcpClientAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Sockets.TcpClient> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_System_Threading_Tasks_ValueTask_System_Net_Sockets_TcpClient___AcceptTcpClientAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // void AllowNatTraversal(bool)
// docid: M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
    /**
    Enables or disables Network Address Translation (NAT) traversal on a  instance.

    - Parameter allowed: A Boolean value that specifies whether to enable or disable NAT traversal.
    */
    open func AllowNatTraversal(allowed : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpListener_void__AllowNatTraversal_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(allowed ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginAcceptSocket(System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous operation to accept an incoming connection attempt.

    - Parameter callback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object containing information about the accept operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous creation of the .

    */
    open func BeginAcceptSocket(callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_IAsyncResult__BeginAcceptSocket_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAcceptSocket(callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginAcceptSocket(callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginAcceptTcpClient(System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous operation to accept an incoming connection attempt.

    - Parameter callback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object containing information about the accept operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  that references the asynchronous creation of the .

    */
    open func BeginAcceptTcpClient(callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_IAsyncResult__BeginAcceptTcpClient_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAcceptTcpClient(callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginAcceptTcpClient(callback: del_callback, state: state);
    }
    // System.Net.Sockets.TcpListener Create(System.Int32)
// docid: M:System.Net.Sockets.TcpListener.Create(System.Int32)
    /**
    Creates a new  instance to listen on the specified port.

    - Parameter port: The port on which to listen for incoming connection attempts.
    - Returns: A new  instance to listen on the specified port.

    */
    open class func Create(port : Swift.Int32) throws -> dotnet.System.Net.Sockets.TcpListener {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_TcpListener__Create_0__1__i32(&__thrown, port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.TcpListener(hndl : __return);
        }
    }
    // System.Net.Sockets.Socket EndAcceptSocket(System.IAsyncResult)
// docid: M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
    /**
    Asynchronously accepts an incoming connection attempt and creates a new  to handle remote host communication.

    - Parameter asyncResult: An  returned by a call to the  method.
    - Returns: A .  
  
 The  used to send and receive data.

    */
    open func EndAcceptSocket(asyncResult : dotnet.System.IAsyncResult) throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_Socket__EndAcceptSocket_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // System.Net.Sockets.TcpClient EndAcceptTcpClient(System.IAsyncResult)
// docid: M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
    /**
    Asynchronously accepts an incoming connection attempt and creates a new  to handle remote host communication.

    - Parameter asyncResult: An  returned by a call to the  method.
    - Returns: A .  
  
 The  used to send and receive data.

    */
    open func EndAcceptTcpClient(asyncResult : dotnet.System.IAsyncResult) throws -> dotnet.System.Net.Sockets.TcpClient {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_TcpClient__EndAcceptTcpClient_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.TcpClient(hndl : __return);
        }
    }
    // bool Pending()
// docid: M:System.Net.Sockets.TcpListener.Pending
    /**
    Determines if there are pending connection requests.

    - Returns: 
         if connections are pending; otherwise, .

    */
    open func Pending() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_bool__Pending_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Start()
// docid: M:System.Net.Sockets.TcpListener.Start
    /**
    Starts listening for incoming connection requests.

    */
    open func Start() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpListener_void__Start_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Start(System.Int32)
// docid: M:System.Net.Sockets.TcpListener.Start(System.Int32)
    /**
    Starts listening for incoming connection requests with a maximum number of pending connection.

    - Parameter backlog: The maximum length of the pending connections queue.
    */
    open func Start(backlog : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpListener_void__Start_0__1__i32(&__thrown, self.get_handle(), backlog);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Stop()
// docid: M:System.Net.Sockets.TcpListener.Stop
    /**
    Closes the listener.

    */
    open func Stop() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpListener_void__Stop_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ExclusiveAddressUse()
// docid: M:System.Net.Sockets.TcpListener.get_ExclusiveAddressUse
    open func get_ExclusiveAddressUse() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_bool__get_ExclusiveAddressUse_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ExclusiveAddressUse(bool)
// docid: M:System.Net.Sockets.TcpListener.set_ExclusiveAddressUse(System.Boolean)
    open func set_ExclusiveAddressUse(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_TcpListener_void__set_ExclusiveAddressUse_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_LocalEndpoint()
// docid: M:System.Net.Sockets.TcpListener.get_LocalEndpoint
    open func get_LocalEndpoint() throws -> dotnet.System.Net.EndPoint {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_EndPoint__get_LocalEndpoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.EndPoint(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Sockets.Socket get_Server()
// docid: M:System.Net.Sockets.TcpListener.get_Server
    open func get_Server() throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_TcpListener_Socket__get_Server_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    /**
    Gets or sets a  value that specifies whether the  allows only one underlying socket to listen to a specific port.

    */
    open var ExclusiveAddressUse : Bool {
        get {
            return try! get_ExclusiveAddressUse();
        }
        set(v) {
            return try! set_ExclusiveAddressUse(value: v);
        }
    }
    /**
    Gets the underlying  of the current .

    */
    open var LocalEndpoint : dotnet.System.Net.EndPoint {
        get {
            return try! get_LocalEndpoint();
        }
    }
    /**
    Gets the underlying network .

    */
    open var Server : dotnet.System.Net.Sockets.Socket {
        get {
            return try! get_Server();
        }
    }
} // TcpListener


// type: System.Net.Sockets.TransmitFileOptions
    /**
    The  enumeration defines values used in file transfer requests.

    */
public struct TransmitFileOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_TransmitFileOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.TransmitFileOptions UseDefaultWorkerThread
    /**
    Use the default thread to process long file transfer requests.

    */
    public static var UseDefaultWorkerThread : dotnet.System.Net.Sockets.TransmitFileOptions {
        get {
        let __return = dotnet.System.Net.Sockets.TransmitFileOptions(val: System_Net_Sockets_TransmitFileOptions_get_UseDefaultWorkerThread());
            return __return;
        }
    }
    // static field: System.Net.Sockets.TransmitFileOptions Disconnect
    /**
    Start a transport-level disconnect after all the file data has been queued for transmission. When used with , these flags return the socket to a disconnected, reusable state after the file has been transmitted.

    */
    public static var Disconnect : dotnet.System.Net.Sockets.TransmitFileOptions {
        get {
        let __return = dotnet.System.Net.Sockets.TransmitFileOptions(val: System_Net_Sockets_TransmitFileOptions_get_Disconnect());
            return __return;
        }
    }
    // static field: System.Net.Sockets.TransmitFileOptions ReuseSocket
    /**
    The socket handle may be reused when the request completes. This flag is valid only if  is also specified. When used with , these flags return the socket to a disconnected, reusable state after the file has been transmitted.

    */
    public static var ReuseSocket : dotnet.System.Net.Sockets.TransmitFileOptions {
        get {
        let __return = dotnet.System.Net.Sockets.TransmitFileOptions(val: System_Net_Sockets_TransmitFileOptions_get_ReuseSocket());
            return __return;
        }
    }
    // static field: System.Net.Sockets.TransmitFileOptions WriteBehind
    /**
    Complete the file transfer request immediately, without pending. If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this flag with the  and  flags.

    */
    public static var WriteBehind : dotnet.System.Net.Sockets.TransmitFileOptions {
        get {
        let __return = dotnet.System.Net.Sockets.TransmitFileOptions(val: System_Net_Sockets_TransmitFileOptions_get_WriteBehind());
            return __return;
        }
    }
    // static field: System.Net.Sockets.TransmitFileOptions UseSystemThread
    /**
    Use system threads to process long file transfer requests.

    */
    public static var UseSystemThread : dotnet.System.Net.Sockets.TransmitFileOptions {
        get {
        let __return = dotnet.System.Net.Sockets.TransmitFileOptions(val: System_Net_Sockets_TransmitFileOptions_get_UseSystemThread());
            return __return;
        }
    }
    // static field: System.Net.Sockets.TransmitFileOptions UseKernelApc
    /**
    Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests. Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.

    */
    public static var UseKernelApc : dotnet.System.Net.Sockets.TransmitFileOptions {
        get {
        let __return = dotnet.System.Net.Sockets.TransmitFileOptions(val: System_Net_Sockets_TransmitFileOptions_get_UseKernelApc());
            return __return;
        }
    }
} // TransmitFileOptions


// type: System.Net.Sockets.UdpClient
    /**
    Provides User Datagram Protocol (UDP) network services.

    */
open class UdpClient
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_UdpClient_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_UdpClient_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Net.Sockets.UdpClient.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UdpClient_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Net.Sockets.UdpClient.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class and binds it to the local port number provided.

    - Parameter port: The local port number from which you intend to communicate.
    */
    public init(port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UdpClient_ctor_0__1__i32(&__thrown, port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Net.Sockets.AddressFamily)
// docid: M:System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)
    /**
    Initializes a new instance of the  class and binds it to the local port number provided.

    - Parameter port: The port on which to listen for incoming connection attempts.
    - Parameter family: One of the  values that specifies the addressing scheme of the socket.
    */
    public init(port : Swift.Int32, family : dotnet.System.Net.Sockets.AddressFamily) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UdpClient_ctor_0__2__i32_AddressFamily(&__thrown, port, family.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)
    /**
    Initializes a new instance of the  class and binds it to the specified local endpoint.

    - Parameter localEP: An  that represents the local endpoint to which you bind the UDP connection.
    */
    public init(localEP : dotnet.System.Net.IPEndPoint) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UdpClient_ctor_0__1__IPEndPoint(&__thrown, localEP.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.AddressFamily)
// docid: M:System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)
    /**
    Initializes a new instance of the  class.

    - Parameter family: One of the  values that specifies the addressing scheme of the socket.
    */
    public init(family : dotnet.System.Net.Sockets.AddressFamily) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UdpClient_ctor_0__1__AddressFamily(&__thrown, family.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32)
// docid: M:System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)
    /**
    Initializes a new instance of the  class and establishes a default remote host.

    - Parameter hostname: The name of the remote DNS host to which you intend to connect.
    - Parameter port: The remote port number to which you intend to connect.
    */
    public init(hostname : dotnet.System.String, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UdpClient_ctor_0__2__String_i32(&__thrown, hostname.get_handle(), port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AllowNatTraversal(bool)
// docid: M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)
    /**
    Enables or disables Network Address Translation (NAT) traversal on a  instance.

    - Parameter allowed: A Boolean value that specifies whether to enable or disable NAT traversal.
    */
    open func AllowNatTraversal(allowed : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__AllowNatTraversal_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(allowed ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginReceive(System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)
    /**
    Receives a datagram from a remote host asynchronously.

    - Parameter requestCallback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the receive operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  object that references the asynchronous receive.

    */
    open func BeginReceive(requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_IAsyncResult__BeginReceive_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginReceive(requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginReceive(requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginSend(System.Byte[], System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)
    /**
    Sends a datagram to a remote host asynchronously. The destination was specified previously by a call to .

    - Parameter datagram: A  array that contains the data to be sent.
    - Parameter bytes: The number of bytes to send.
    - Parameter requestCallback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the send operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  object that references the asynchronous send.

    */
    open func BeginSend(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_IAsyncResult__BeginSend_0__4__u8Array_i32_AsyncCallback_Object(&__thrown, self.get_handle(), datagram.get_handle(), bytes, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSend(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginSend(datagram: datagram, bytes: bytes, requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginSend(System.Byte[], System.Int32, System.Net.IPEndPoint, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)
    /**
    Sends a datagram to a destination asynchronously. The destination is specified by a .

    - Parameter datagram: A  array that contains the data to be sent.
    - Parameter bytes: The number of bytes to send.
    - Parameter endPoint: The  that represents the destination for the data.
    - Parameter requestCallback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the send operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  object that references the asynchronous send.

    */
    open func BeginSend(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, endPoint : Optional<dotnet.System.Net.IPEndPoint>, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_IAsyncResult__BeginSend_0__5__u8Array_i32_IPEndPoint_AsyncCallback_Object(&__thrown, self.get_handle(), datagram.get_handle(), bytes, endPoint?.get_handle() ?? nil, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSend(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, endPoint : Optional<dotnet.System.Net.IPEndPoint>, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginSend(datagram: datagram, bytes: bytes, endPoint: endPoint, requestCallback: del_requestCallback, state: state);
    }
    // System.IAsyncResult BeginSend(System.Byte[], System.Int32, System.String, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)
    /**
    Sends a datagram to a destination asynchronously. The destination is specified by the host name and port number.

    - Parameter datagram: A  array that contains the data to be sent.
    - Parameter bytes: The number of bytes to send.
    - Parameter hostname: The destination host.
    - Parameter port: The destination port number.
    - Parameter requestCallback: An  delegate that references the method to invoke when the operation is complete.
    - Parameter state: A user-defined object that contains information about the send operation. This object is passed to the  delegate when the operation is complete.
    - Returns: An  object that references the asynchronous send.

    */
    open func BeginSend(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, hostname : Optional<dotnet.System.String>, port : Swift.Int32, requestCallback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_IAsyncResult__BeginSend_0__6__u8Array_i32_String_i32_AsyncCallback_Object(&__thrown, self.get_handle(), datagram.get_handle(), bytes, hostname?.get_handle() ?? nil, port, requestCallback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginSend(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, hostname : Optional<dotnet.System.String>, port : Swift.Int32, requestCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_requestCallback = try dotnet.System.AsyncCallback(requestCallback);
        return try BeginSend(datagram: datagram, bytes: bytes, hostname: hostname, port: port, requestCallback: del_requestCallback, state: state);
    }
    // void Close()
// docid: M:System.Net.Sockets.UdpClient.Close
    /**
    Closes the UDP connection.

    */
    open func Close() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__Close_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)
    /**
    Establishes a default remote host using the specified IP address and port number.

    - Parameter addr: The  of the remote host to which you intend to send data.
    - Parameter port: The port number to which you intend send data.
    */
    open func Connect(addr : dotnet.System.Net.IPAddress, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__Connect_0__2__IPAddress_i32(&__thrown, self.get_handle(), addr.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)
    /**
    Establishes a default remote host using the specified network endpoint.

    - Parameter endPoint: An  that specifies the network endpoint to which you intend to send data.
    */
    open func Connect(endPoint : dotnet.System.Net.IPEndPoint) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__Connect_0__1__IPEndPoint(&__thrown, self.get_handle(), endPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.String, System.Int32)
// docid: M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)
    /**
    Establishes a default remote host using the specified host name and port number.

    - Parameter hostname: The DNS name of the remote host to which you intend send data.
    - Parameter port: The port number on the remote host to which you intend to send data.
    */
    open func Connect(hostname : dotnet.System.String, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__Connect_0__2__String_i32(&__thrown, self.get_handle(), hostname.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Dispose()
// docid: M:System.Net.Sockets.UdpClient.Dispose
    /**
    Releases the managed and unmanaged resources used by the .

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void DropMulticastGroup(System.Net.IPAddress)
// docid: M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)
    /**
    Leaves a multicast group.

    - Parameter multicastAddr: The  of the multicast group to leave.
    */
    open func DropMulticastGroup(multicastAddr : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__DropMulticastGroup_0__1__IPAddress(&__thrown, self.get_handle(), multicastAddr.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void DropMulticastGroup(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)
    /**
    Leaves a multicast group.

    - Parameter multicastAddr: The  of the multicast group to leave.
    - Parameter ifindex: The local address of the multicast group to leave.
    */
    open func DropMulticastGroup(multicastAddr : dotnet.System.Net.IPAddress, ifindex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__DropMulticastGroup_0__2__IPAddress_i32(&__thrown, self.get_handle(), multicastAddr.get_handle(), ifindex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] EndReceive(System.IAsyncResult, ref System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)
    /**
    Ends a pending asynchronous receive.

    - Parameter asyncResult: An  object returned by a call to .
    - Parameter remoteEP: The specified remote endpoint.
    - Returns: If successful, an array of bytes that contains datagram data.

    */
    open func EndReceive(asyncResult : dotnet.System.IAsyncResult, remoteEP : inout Optional<dotnet.System.Net.IPEndPoint>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = (remoteEP != nil) ? (remoteEP!.get_handle()) : nil;
        let __return = System_Net_Sockets_UdpClient_u8Array__EndReceive_0__2__IAsyncResult_refIPEndPoint(&__thrown, self.get_handle(), asyncResult.get_handle(), &_tmp_ref_remoteEP);
        let __h__tmp2_remoteEP = _tmp_ref_remoteEP;
        let _tmp2_remoteEP = (__h__tmp2_remoteEP != nil) ? dotnet.System.Net.IPEndPoint(hndl: __h__tmp2_remoteEP!) : nil;
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Int32 EndSend(System.IAsyncResult)
// docid: M:System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)
    /**
    Ends a pending asynchronous send.

    - Parameter asyncResult: An  object returned by a call to .
    - Returns: If successful, the number of bytes sent to the .

    */
    open func EndSend(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_i32__EndSend_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void JoinMulticastGroup(System.Int32, System.Net.IPAddress)
// docid: M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)
    /**
    Adds a  to a multicast group.

    - Parameter ifindex: The interface index associated with the local IP address on which to join the multicast group.
    - Parameter multicastAddr: The multicast  of the group you want to join.
    */
    open func JoinMulticastGroup(ifindex : Swift.Int32, multicastAddr : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__JoinMulticastGroup_0__2__i32_IPAddress(&__thrown, self.get_handle(), ifindex, multicastAddr.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void JoinMulticastGroup(System.Net.IPAddress)
// docid: M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)
    /**
    Adds a  to a multicast group.

    - Parameter multicastAddr: The multicast  of the group you want to join.
    */
    open func JoinMulticastGroup(multicastAddr : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__JoinMulticastGroup_0__1__IPAddress(&__thrown, self.get_handle(), multicastAddr.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void JoinMulticastGroup(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)
    /**
    Adds a  to a multicast group with the specified Time to Live (TTL).

    - Parameter multicastAddr: The  of the multicast group to join.
    - Parameter timeToLive: The Time to Live (TTL), measured in router hops.
    */
    open func JoinMulticastGroup(multicastAddr : dotnet.System.Net.IPAddress, timeToLive : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__JoinMulticastGroup_0__2__IPAddress_i32(&__thrown, self.get_handle(), multicastAddr.get_handle(), timeToLive);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void JoinMulticastGroup(System.Net.IPAddress, System.Net.IPAddress)
// docid: M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)
    /**
    Adds a  to a multicast group.

    - Parameter multicastAddr: The multicast  of the group you want to join.
    - Parameter localAddress: The local .
    */
    open func JoinMulticastGroup(multicastAddr : dotnet.System.Net.IPAddress, localAddress : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__JoinMulticastGroup_0__2__IPAddress_IPAddress(&__thrown, self.get_handle(), multicastAddr.get_handle(), localAddress.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] Receive(ref System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)
    /**
    Returns a UDP datagram that was sent by a remote host.

    - Parameter remoteEP: An  that represents the remote host from which the data was sent.
    - Returns: An array of type  that contains datagram data.

    */
    open func Receive(remoteEP : inout dotnet.System.Net.IPEndPoint) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_remoteEP = remoteEP.get_handle();
        let __return = System_Net_Sockets_UdpClient_u8Array__Receive_0__1__refIPEndPoint(&__thrown, self.get_handle(), &_tmp_ref_remoteEP);
        let _tmp2_remoteEP = dotnet.System.Net.IPEndPoint(hndl: _tmp_ref_remoteEP);
            remoteEP = _tmp2_remoteEP;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Net.Sockets.UdpReceiveResult> ReceiveAsync()
// docid: M:System.Net.Sockets.UdpClient.ReceiveAsync
    /**
    Returns a UDP datagram asynchronously that was sent by a remote host.

    - Returns: The task object representing the asynchronous operation.

    */
    open func ReceiveAsync() async throws -> dotnet.System.Net.Sockets.UdpReceiveResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_Task_System_Net_Sockets_UdpReceiveResult___ReceiveAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Sockets.UdpReceiveResult> ReceiveAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.UdpClient.ReceiveAsync(System.Threading.CancellationToken)
    /**
    Returns a UDP datagram asynchronously that was sent by a remote host.

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  representing the asynchronous operation.

    */
    open func ReceiveAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Sockets.UdpReceiveResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_ValueTask_System_Net_Sockets_UdpReceiveResult___ReceiveAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 Send(System.Byte[], System.Int32)
// docid: M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)
    /**
    Sends a UDP datagram to a remote host.

    - Parameter dgram: An array of type  that specifies the UDP datagram that you intend to send represented as an array of bytes.
    - Parameter bytes: The number of bytes in the datagram.
    - Returns: The number of bytes sent.

    */
    open func Send(dgram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_i32__Send_0__2__u8Array_i32(&__thrown, self.get_handle(), dgram.get_handle(), bytes);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Send(System.ReadOnlySpan<System.Byte>)
    // System.Int32 Send(System.Byte[], System.Int32, System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)
    /**
    Sends a UDP datagram to the host at the specified remote endpoint.

    - Parameter dgram: An array of type  that specifies the UDP datagram that you intend to send, represented as an array of bytes.
    - Parameter bytes: The number of bytes in the datagram.
    - Parameter endPoint: An  that represents the host and port to which to send the datagram.
    - Returns: The number of bytes sent.

    */
    open func Send(dgram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, endPoint : Optional<dotnet.System.Net.IPEndPoint>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_i32__Send_0__3__u8Array_i32_IPEndPoint(&__thrown, self.get_handle(), dgram.get_handle(), bytes, endPoint?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Send(System.ReadOnlySpan<System.Byte>, System.Net.IPEndPoint)
    // System.Int32 Send(System.Byte[], System.Int32, System.String, System.Int32)
// docid: M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)
    /**
    Sends a UDP datagram to a specified port on a specified remote host.

    - Parameter dgram: An array of type  that specifies the UDP datagram that you intend to send represented as an array of bytes.
    - Parameter bytes: The number of bytes in the datagram.
    - Parameter hostname: The name of the remote host to which you intend to send the datagram.
    - Parameter port: The remote port number with which you intend to communicate.
    - Returns: The number of bytes sent.

    */
    open func Send(dgram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, hostname : Optional<dotnet.System.String>, port : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_i32__Send_0__4__u8Array_i32_String_i32(&__thrown, self.get_handle(), dgram.get_handle(), bytes, hostname?.get_handle() ?? nil, port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Send(System.ReadOnlySpan<System.Byte>, System.String, System.Int32)
    // System.Threading.Tasks.Task<System.Int32> SendAsync(System.Byte[], System.Int32)
// docid: M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)
    /**
    Sends a UDP datagram asynchronously to a remote host.

    - Parameter datagram: An array of type  that specifies the UDP datagram that you intend to send represented as an array of bytes.
    - Parameter bytes: The number of bytes in the datagram.
    - Returns: Returns .

    */
    open func SendAsync(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_Task_i32___SendAsync_0__2__u8Array_i32(&__thrown, self.get_handle(), datagram.get_handle(), bytes);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> SendAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.UdpClient.SendAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Sends a UDP datagram asynchronously to a remote host.

    - Parameter datagram: An  of Type  that specifies the UDP datagram that you intend to send.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is None.
    - Returns: A  that represents the asynchronous send operation. The value of its Result property contains the number of bytes sent.

    */
    open func SendAsync(datagram : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_ValueTask_i32___SendAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), datagram.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Int32> SendAsync(System.Byte[], System.Int32, System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)
    /**
    Sends a UDP datagram asynchronously to a remote host.

    - Parameter datagram: An array of type  that specifies the UDP datagram that you intend to send represented as an array of bytes.
    - Parameter bytes: The number of bytes in the datagram.
    - Parameter endPoint: An  that represents the host and port to which to send the datagram.
    - Returns: Returns .

    */
    open func SendAsync(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, endPoint : Optional<dotnet.System.Net.IPEndPoint>) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_Task_i32___SendAsync_0__3__u8Array_i32_IPEndPoint(&__thrown, self.get_handle(), datagram.get_handle(), bytes, endPoint?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> SendAsync(System.ReadOnlyMemory<System.Byte>, System.Net.IPEndPoint, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.UdpClient.SendAsync(System.ReadOnlyMemory{System.Byte},System.Net.IPEndPoint,System.Threading.CancellationToken)
    /**
    Sends a UDP datagram asynchronously to a remote host.

    - Parameter datagram: An  of Type  that specifies the UDP datagram that you intend to send.
    - Parameter endPoint: An  that represents the host and port to which to send the datagram.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is None.
    - Returns: A  that represents the asynchronous send operation. The value of its Result property contains the number of bytes sent.

    */
    open func SendAsync(datagram : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, endPoint : Optional<dotnet.System.Net.IPEndPoint>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_ValueTask_i32___SendAsync_0__3__System_ReadOnlyMemory_u8__IPEndPoint_CancellationToken(&__thrown, self.get_handle(), datagram.get_handle(), endPoint?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Int32> SendAsync(System.Byte[], System.Int32, System.String, System.Int32)
// docid: M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)
    /**
    Sends a UDP datagram asynchronously to a remote host.

    - Parameter datagram: An array of type  that specifies the UDP datagram that you intend to send represented as an array of bytes.
    - Parameter bytes: The number of bytes in the datagram.
    - Parameter hostname: The name of the remote host to which you intend to send the datagram.
    - Parameter port: The remote port number with which you intend to communicate.
    - Returns: Returns .

    */
    open func SendAsync(datagram : dotnet.System_Arr<Swift.UInt8>, bytes : Swift.Int32, hostname : Optional<dotnet.System.String>, port : Swift.Int32) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_Task_i32___SendAsync_0__4__u8Array_i32_String_i32(&__thrown, self.get_handle(), datagram.get_handle(), bytes, hostname?.get_handle() ?? nil, port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).to_async_result();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> SendAsync(System.ReadOnlyMemory<System.Byte>, System.String, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Sockets.UdpClient.SendAsync(System.ReadOnlyMemory{System.Byte},System.String,System.Int32,System.Threading.CancellationToken)
    /**
    Sends a UDP datagram asynchronously to a remote host.

    - Parameter datagram: An  of Type  that specifies the UDP datagram that you intend to send.
    - Parameter hostname: The name of the remote host to which you intend to send the datagram.
    - Parameter port: The remote port number with which you intend to communicate.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is None.
    - Returns: A  that represents the asynchronous send operation. The value of its Result property contains the number of bytes sent.

    */
    open func SendAsync(datagram : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, hostname : Optional<dotnet.System.String>, port : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_System_Threading_Tasks_ValueTask_i32___SendAsync_0__4__System_ReadOnlyMemory_u8__String_i32_CancellationToken(&__thrown, self.get_handle(), datagram.get_handle(), hostname?.get_handle() ?? nil, port, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Available()
// docid: M:System.Net.Sockets.UdpClient.get_Available
    open func get_Available() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_i32__get_Available_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.Socket get_Client()
// docid: M:System.Net.Sockets.UdpClient.get_Client
    open func get_Client() throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_Socket__get_Client_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Client(System.Net.Sockets.Socket)
// docid: M:System.Net.Sockets.UdpClient.set_Client(System.Net.Sockets.Socket)
    open func set_Client(value : dotnet.System.Net.Sockets.Socket) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__set_Client_0__1__Socket(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_DontFragment()
// docid: M:System.Net.Sockets.UdpClient.get_DontFragment
    open func get_DontFragment() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_bool__get_DontFragment_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DontFragment(bool)
// docid: M:System.Net.Sockets.UdpClient.set_DontFragment(System.Boolean)
    open func set_DontFragment(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__set_DontFragment_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_EnableBroadcast()
// docid: M:System.Net.Sockets.UdpClient.get_EnableBroadcast
    open func get_EnableBroadcast() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_bool__get_EnableBroadcast_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_EnableBroadcast(bool)
// docid: M:System.Net.Sockets.UdpClient.set_EnableBroadcast(System.Boolean)
    open func set_EnableBroadcast(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__set_EnableBroadcast_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ExclusiveAddressUse()
// docid: M:System.Net.Sockets.UdpClient.get_ExclusiveAddressUse
    open func get_ExclusiveAddressUse() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_bool__get_ExclusiveAddressUse_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ExclusiveAddressUse(bool)
// docid: M:System.Net.Sockets.UdpClient.set_ExclusiveAddressUse(System.Boolean)
    open func set_ExclusiveAddressUse(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__set_ExclusiveAddressUse_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_MulticastLoopback()
// docid: M:System.Net.Sockets.UdpClient.get_MulticastLoopback
    open func get_MulticastLoopback() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_bool__get_MulticastLoopback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_MulticastLoopback(bool)
// docid: M:System.Net.Sockets.UdpClient.set_MulticastLoopback(System.Boolean)
    open func set_MulticastLoopback(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__set_MulticastLoopback_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int16 get_Ttl()
// docid: M:System.Net.Sockets.UdpClient.get_Ttl
    open func get_Ttl() throws -> Swift.Int16 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpClient_i16__get_Ttl_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Ttl(System.Int16)
// docid: M:System.Net.Sockets.UdpClient.set_Ttl(System.Int16)
    open func set_Ttl(value : Swift.Int16) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Sockets_UdpClient_void__set_Ttl_0__1__i16(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the amount of data received from the network that is available to read.

    */
    open var Available : Swift.Int32 {
        get {
            return try! get_Available();
        }
    }
    /**
    Gets or sets the underlying network .

    */
    open var Client : dotnet.System.Net.Sockets.Socket {
        get {
            return try! get_Client();
        }
        set(v) {
            return try! set_Client(value: v);
        }
    }
    /**
    Gets or sets a  value that specifies whether the  allows Internet Protocol (IP) datagrams to be fragmented.

    */
    open var DontFragment : Bool {
        get {
            return try! get_DontFragment();
        }
        set(v) {
            return try! set_DontFragment(value: v);
        }
    }
    /**
    Gets or sets a  value that specifies whether the  may send or receive broadcast packets.

    */
    open var EnableBroadcast : Bool {
        get {
            return try! get_EnableBroadcast();
        }
        set(v) {
            return try! set_EnableBroadcast(value: v);
        }
    }
    /**
    Gets or sets a  value that specifies whether the  allows only one client to use a port.

    */
    open var ExclusiveAddressUse : Bool {
        get {
            return try! get_ExclusiveAddressUse();
        }
        set(v) {
            return try! set_ExclusiveAddressUse(value: v);
        }
    }
    /**
    Gets or sets a  value that specifies whether outgoing multicast packets are delivered to the sending application.

    */
    open var MulticastLoopback : Bool {
        get {
            return try! get_MulticastLoopback();
        }
        set(v) {
            return try! set_MulticastLoopback(value: v);
        }
    }
    /**
    Gets or sets a value that specifies the Time to Live (TTL) value of Internet Protocol (IP) packets sent by the .

    */
    open var Ttl : Swift.Int16 {
        get {
            return try! get_Ttl();
        }
        set(v) {
            return try! set_Ttl(value: v);
        }
    }
} // UdpClient


// type: System.Net.Sockets.UdpReceiveResult
// boxed value type
    /**
    Presents UDP receive result information from a call to the  method.

    */
public final class UdpReceiveResult
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_UdpReceiveResult_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets a buffer with the data received in the UDP packet.

    */
    public var Buffer : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Buffer();
        }
    }
    /**
    Gets the remote endpoint from which the UDP packet was received.

    */
    public var RemoteEndPoint : dotnet.System.Net.IPEndPoint {
        get {
            return try! get_RemoteEndPoint();
        }
    }
    // .ctor(System.Byte[], System.Net.IPEndPoint)
// docid: M:System.Net.Sockets.UdpReceiveResult.#ctor(System.Byte[],System.Net.IPEndPoint)
    /**
    Initializes a new instance of the  class.

    - Parameter buffer: A buffer for data to receive in the UDP packet.
    - Parameter remoteEndPoint: The remote endpoint of the UDP packet.
    */
    public init(buffer : dotnet.System_Arr<Swift.UInt8>, remoteEndPoint : dotnet.System.Net.IPEndPoint) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UdpReceiveResult_ctor_0__2__u8Array_IPEndPoint(&__thrown, buffer.get_handle(), remoteEndPoint.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Net_Sockets_UdpReceiveResult_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Net.Sockets.UdpReceiveResult)
// docid: M:System.Net.Sockets.UdpReceiveResult.Equals(System.Net.Sockets.UdpReceiveResult)
    /**
    Returns a value that indicates whether this instance is equal to a specified object.

    - Parameter other: The object to compare with this instance.
    - Returns: 
         if  is an instance of  and equals the value of the instance; otherwise, .

    */
    public func Equals(other : dotnet.System.Net.Sockets.UdpReceiveResult) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpReceiveResult_bool__Equals_0__1__UdpReceiveResult(&__thrown, self.get_handle(), other.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Net.Sockets.UdpReceiveResult.Equals(System.Object)
    /**
    Returns a value that indicates whether this instance is equal to a specified object.

    - Parameter obj: The object to compare with this instance.
    - Returns: 
         if  is an instance of  and equals the value of the instance; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpReceiveResult_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.Sockets.UdpReceiveResult.GetHashCode
    /**
    Returns the hash code for this instance.

    - Returns: The hash code.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpReceiveResult_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Net.Sockets.UdpReceiveResult, System.Net.Sockets.UdpReceiveResult)
// docid: M:System.Net.Sockets.UdpReceiveResult.op_Equality(System.Net.Sockets.UdpReceiveResult,System.Net.Sockets.UdpReceiveResult)
    /**
    Tests whether two specified  instances are equivalent.

    - Parameter left: The  instance that is to the left of the equality operator.
    - Parameter right: The  instance that is to the right of the equality operator.
    - Returns: 
         if  and  are equal; otherwise, .

    */
    public class func op_Equality(left : dotnet.System.Net.Sockets.UdpReceiveResult, right : dotnet.System.Net.Sockets.UdpReceiveResult) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpReceiveResult_bool__op_Equality_0__2__UdpReceiveResult_UdpReceiveResult(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Net.Sockets.UdpReceiveResult, System.Net.Sockets.UdpReceiveResult)
// docid: M:System.Net.Sockets.UdpReceiveResult.op_Inequality(System.Net.Sockets.UdpReceiveResult,System.Net.Sockets.UdpReceiveResult)
    /**
    Tests whether two specified  instances are not equal.

    - Parameter left: The  instance that is to the left of the not equal operator.
    - Parameter right: The  instance that is to the right of the not equal operator.
    - Returns: 
         if  and  are unequal; otherwise, .

    */
    public class func op_Inequality(left : dotnet.System.Net.Sockets.UdpReceiveResult, right : dotnet.System.Net.Sockets.UdpReceiveResult) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpReceiveResult_bool__op_Inequality_0__2__UdpReceiveResult_UdpReceiveResult(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Byte[] get_Buffer()
// docid: M:System.Net.Sockets.UdpReceiveResult.get_Buffer
    public func get_Buffer() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpReceiveResult_u8Array__get_Buffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.IPEndPoint get_RemoteEndPoint()
// docid: M:System.Net.Sockets.UdpReceiveResult.get_RemoteEndPoint
    public func get_RemoteEndPoint() throws -> dotnet.System.Net.IPEndPoint {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_UdpReceiveResult_IPEndPoint__get_RemoteEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPEndPoint(hndl : __return);
        }
    }
} // UdpReceiveResult


// type: System.Net.Sockets.UnixDomainSocketEndPoint
    /**
    Represents a Unix Domain Socket endpoint as a path.

    */
public final class UnixDomainSocketEndPoint
    :
    dotnet.System.Net.EndPoint
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_UnixDomainSocketEndPoint_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Net_Sockets_UnixDomainSocketEndPoint_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:System.Net.Sockets.UnixDomainSocketEndPoint.#ctor(System.String)
    /**
    Initializes a new instance of the  with the file path to connect a unix domain socket over.

    - Parameter path: The path to connect a unix domain socket over.
    */
    public init(path : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_UnixDomainSocketEndPoint_ctor_0__1__String(&__thrown, path.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // UnixDomainSocketEndPoint


}



