// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// Microsoft
// Microsoft.Win32
// Microsoft.Win32.SafeHandles
extension Microsoft.Win32.SafeHandles {
// type: Microsoft.Win32.SafeHandles.SafeX509ChainHandle
    /**
    Provides a wrapper class that represents the handle of an X.509 chain object. For more information, see .

    */
public final class SafeX509ChainHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafeX509ChainHandle_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Win32_SafeHandles_SafeX509ChainHandle_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Win32.SafeHandles.SafeX509ChainHandle.#ctor
    /**
    Creates a .

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafeX509ChainHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SafeX509ChainHandle


}



// System
// System.Security
// System.Security.Cryptography
// System.Security.Cryptography.X509Certificates
extension System.Security.Cryptography.X509Certificates {
// type: System.Security.Cryptography.X509Certificates.CertificateRequest
    /**
    Represents an abstraction over the PKCS#10 CertificationRequestInfo and the X.509 TbsCertificate.

    */
public final class CertificateRequest
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_CertificateRequest_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_CertificateRequest_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName, System.Security.Cryptography.ECDsa, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.#ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.Security.Cryptography.ECDsa,System.Security.Cryptography.HashAlgorithmName)
    /**
    Initializes a new instance of the  class using the specified subject name, ECDSA key, and hash algorithm.

    - Parameter subjectName: The parsed representation of the subject name for the certificate or certificate request.
    - Parameter key: An ECDSA key whose public key material will be included in the certificate or certificate request. If the  method is called, this key is used as a private key.
    - Parameter hashAlgorithm: The hash algorithm to use when signing the certificate or certificate request.
    */
    public init(subjectName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName, key : dotnet.System.Security.Cryptography.ECDsa, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_CertificateRequest_ctor_0__3__X500DistinguishedName_ECDsa_HashAlgorithmName(&__thrown, subjectName.get_handle(), key.get_handle(), hashAlgorithm.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName, System.Security.Cryptography.RSA, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.#ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.Security.Cryptography.RSA,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Initializes a new instance of the  class using the specified subject name, RSA key, and hash algorithm.

    - Parameter subjectName: The parsed representation of the subject name for the certificate or certificate request.
    - Parameter key: A RSA key whose public key material will be included in the certificate or certificate request. If the  method is called, this key is used as a private key.
    - Parameter hashAlgorithm: The hash algorithm to use when signing the certificate or certificate request.
    - Parameter padding: The RSA signature padding to apply if self-signing or being signed with an .
    */
    public init(subjectName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName, key : dotnet.System.Security.Cryptography.RSA, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_CertificateRequest_ctor_0__4__X500DistinguishedName_RSA_HashAlgorithmName_RSASignaturePadding(&__thrown, subjectName.get_handle(), key.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName, System.Security.Cryptography.X509Certificates.PublicKey, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.#ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.Security.Cryptography.X509Certificates.PublicKey,System.Security.Cryptography.HashAlgorithmName)
    /**
    Initializes a new instance of the  class using the specified subject name, encoded public key, and hash algorithm.

    - Parameter subjectName: The parsed representation of the subject name for the certificate or certificate request.
    - Parameter publicKey: The encoded representation of the public key to include in the certificate or certificate request.
    - Parameter hashAlgorithm: The hash algorithm to use when signing the certificate or certificate request.
    */
    public init(subjectName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName, publicKey : dotnet.System.Security.Cryptography.X509Certificates.PublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_CertificateRequest_ctor_0__3__X500DistinguishedName_PublicKey_HashAlgorithmName(&__thrown, subjectName.get_handle(), publicKey.get_handle(), hashAlgorithm.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.ECDsa, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.#ctor(System.String,System.Security.Cryptography.ECDsa,System.Security.Cryptography.HashAlgorithmName)
    /**
    Initializes a new instance of the  class using the specified subject name, ECDSA key, and hash algorithm.

    - Parameter subjectName: The string representation of the subject name for the certificate or certificate request.
    - Parameter key: An ECDSA key whose public key material will be included in the certificate or certificate request. If the  method is called, this key is used as a private key.
    - Parameter hashAlgorithm: The hash algorithm to use when signing the certificate or certificate request.
    */
    public init(subjectName : dotnet.System.String, key : dotnet.System.Security.Cryptography.ECDsa, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_CertificateRequest_ctor_0__3__String_ECDsa_HashAlgorithmName(&__thrown, subjectName.get_handle(), key.get_handle(), hashAlgorithm.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.RSA, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.#ctor(System.String,System.Security.Cryptography.RSA,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Initializes a new instance of the  class using the specified subject name, RSA key, and hash algorithm.

    - Parameter subjectName: The string representation of the subject name for the certificate or certificate request.
    - Parameter key: A RSA key whose public key material will be included in the certificate or certificate request. If the  method is called, this key is used as a private key.
    - Parameter hashAlgorithm: The hash algorithm to use when signing the certificate or certificate request.
    - Parameter padding: The RSA signature padding to apply if self-signing or being signed with an .
    */
    public init(subjectName : dotnet.System.String, key : dotnet.System.Security.Cryptography.RSA, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_CertificateRequest_ctor_0__4__String_RSA_HashAlgorithmName_RSASignaturePadding(&__thrown, subjectName.get_handle(), key.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate2 Create(System.Security.Cryptography.X509Certificates.X500DistinguishedName, System.Security.Cryptography.X509Certificates.X509SignatureGenerator, System.DateTimeOffset, System.DateTimeOffset, System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.Create(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.Security.Cryptography.X509Certificates.X509SignatureGenerator,System.DateTimeOffset,System.DateTimeOffset,System.Byte[])
    /**
    Signs the current certificate request to create a chain-signed or self-signed certificate.

    - Parameter issuerName: The  for the issuer.
    - Parameter generator: An  object representing the issuing certificate authority.
    - Parameter notBefore: The oldest date and time when this certificate is considered valid. Typically , plus or minus a few seconds.
    - Parameter notAfter: The date and time when this certificate is no longer considered valid.
    - Parameter serialNumber: The serial number to use for the new certificate. This value should be unique per issuer. The value is interpreted as an unsigned integer of arbitrary size in big-endian byte ordering. RFC 3280 recommends confining it to 20 bytes or less.
    - Returns: An  object with the specified values. The returned object won't assert .

    */
    public func Create(issuerName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName, generator : dotnet.System.Security.Cryptography.X509Certificates.X509SignatureGenerator, notBefore : dotnet.System.DateTimeOffset, notAfter : dotnet.System.DateTimeOffset, serialNumber : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_X509Certificate2__Create_0__5__X500DistinguishedName_X509SignatureGenerator_DateTimeOffset_DateTimeOffset_u8Array(&__thrown, self.get_handle(), issuerName.get_handle(), generator.get_handle(), notBefore.get_handle(), notAfter.get_handle(), serialNumber.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.X509Certificate2 Create(System.Security.Cryptography.X509Certificates.X500DistinguishedName, System.Security.Cryptography.X509Certificates.X509SignatureGenerator, System.DateTimeOffset, System.DateTimeOffset, System.ReadOnlySpan<System.Byte>)
    // System.Security.Cryptography.X509Certificates.X509Certificate2 Create(System.Security.Cryptography.X509Certificates.X509Certificate2, System.DateTimeOffset, System.DateTimeOffset, System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.Create(System.Security.Cryptography.X509Certificates.X509Certificate2,System.DateTimeOffset,System.DateTimeOffset,System.Byte[])
    /**
    Creates a certificate using the established subject, key, and optional extensions using the specified certificate as the issuer.

    - Parameter issuerCertificate: An  instance representing the issuing Certificate Authority (CA).
    - Parameter notBefore: The oldest date and time when this certificate is considered valid. Typically , plus or minus a few seconds.
    - Parameter notAfter: The date and time when this certificate is no longer considered valid.
    - Parameter serialNumber: The serial number to use for the new certificate. This value should be unique per issuer. The value is interpreted as an unsigned integer of arbitrary size in big-endian byte ordering. RFC 3280 recommends confining it to 20 bytes or less.
    - Returns: An  object with the specified values. The returned object won't assert .

    */
    public func Create(issuerCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, notBefore : dotnet.System.DateTimeOffset, notAfter : dotnet.System.DateTimeOffset, serialNumber : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_X509Certificate2__Create_0__4__X509Certificate2_DateTimeOffset_DateTimeOffset_u8Array(&__thrown, self.get_handle(), issuerCertificate.get_handle(), notBefore.get_handle(), notAfter.get_handle(), serialNumber.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.X509Certificate2 Create(System.Security.Cryptography.X509Certificates.X509Certificate2, System.DateTimeOffset, System.DateTimeOffset, System.ReadOnlySpan<System.Byte>)
    // System.Security.Cryptography.X509Certificates.X509Certificate2 CreateSelfSigned(System.DateTimeOffset, System.DateTimeOffset)
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.CreateSelfSigned(System.DateTimeOffset,System.DateTimeOffset)
    /**
    Creates a self-signed certificate using the established subject, key, and optional extensions.

    - Parameter notBefore: The oldest date and time when this certificate is considered valid. Typically , plus or minus a few seconds.
    - Parameter notAfter: The date and time when this certificate is no longer considered valid.
    - Returns: An  object with the specified values. The returned object will assert .

    */
    public func CreateSelfSigned(notBefore : dotnet.System.DateTimeOffset, notAfter : dotnet.System.DateTimeOffset) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_X509Certificate2__CreateSelfSigned_0__2__DateTimeOffset_DateTimeOffset(&__thrown, self.get_handle(), notBefore.get_handle(), notAfter.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    // System.Byte[] CreateSigningRequest()
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.CreateSigningRequest
    /**
    Creates an ASN.1 DER-encoded PKCS#10 CertificationRequest value representing the state of the current object.

    - Returns: A DER-encoded certificate signing request.

    */
    public func CreateSigningRequest() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_u8Array__CreateSigningRequest_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] CreateSigningRequest(System.Security.Cryptography.X509Certificates.X509SignatureGenerator)
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.CreateSigningRequest(System.Security.Cryptography.X509Certificates.X509SignatureGenerator)
    /**
    Creates an ASN.1 DER-encoded PKCS#10 CertificationRequest representing the current state of the current object using the provided signature generator.

    - Parameter signatureGenerator: The signature generator with which to sign the request.
    - Returns: A DER-encoded certificate signing request.

    */
    public func CreateSigningRequest(signatureGenerator : dotnet.System.Security.Cryptography.X509Certificates.X509SignatureGenerator) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_u8Array__CreateSigningRequest_0__1__X509SignatureGenerator(&__thrown, self.get_handle(), signatureGenerator.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Collections.ObjectModel.Collection<System.Security.Cryptography.X509Certificates.X509Extension> get_CertificateExtensions()
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.get_CertificateExtensions
    public func get_CertificateExtensions() throws -> dotnet.System.Collections.ObjectModel.Collection_1<dotnet.System.Security.Cryptography.X509Certificates.X509Extension> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_System_Collections_ObjectModel_Collection_System_Security_Cryptography_X509Certificates_X509Extension___get_CertificateExtensions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.ObjectModel.Collection_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_HashAlgorithm()
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.get_HashAlgorithm
    public func get_HashAlgorithm() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_HashAlgorithmName__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.PublicKey get_PublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.get_PublicKey
    public func get_PublicKey() throws -> dotnet.System.Security.Cryptography.X509Certificates.PublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_PublicKey__get_PublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.PublicKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X500DistinguishedName get_SubjectName()
// docid: M:System.Security.Cryptography.X509Certificates.CertificateRequest.get_SubjectName
    public func get_SubjectName() throws -> dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_CertificateRequest_X500DistinguishedName__get_SubjectName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName(hndl : __return);
        }
    }
    /**
    Gets the X.509 Certificate Extensions collection, which is a mutable collection, to include in the certificate or certificate request.

    */
    public var CertificateExtensions : dotnet.System.Collections.ObjectModel.Collection_1<dotnet.System.Security.Cryptography.X509Certificates.X509Extension> {
        get {
            return try! get_CertificateExtensions();
        }
    }
    /**
    Gets the hash algorithm to use when signing the certificate or certificate request.

    */
    public var HashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_HashAlgorithm();
        }
    }
    /**
    Gets a representation of the public key for the certificate or certificate request.

    */
    public var PublicKey : dotnet.System.Security.Cryptography.X509Certificates.PublicKey {
        get {
            return try! get_PublicKey();
        }
    }
    /**
    Gets the X.500 Distinguished Name to use as the Subject in a created certificate or certificate request.

    */
    public var SubjectName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName {
        get {
            return try! get_SubjectName();
        }
    }
} // CertificateRequest


// type: System.Security.Cryptography.X509Certificates.DSACertificateExtensions
public struct DSACertificateExtensions {
    // System.Security.Cryptography.X509Certificates.X509Certificate2 CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.DSA)
// docid: M:System.Security.Cryptography.X509Certificates.DSACertificateExtensions.CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.DSA)
    /**
    Combines a private key with the public key of a  certificate to generate a new DSA certificate.

    - Parameter certificate: The DSA certificate.
    - Parameter privateKey: The private DSA key.
    - Returns: A new DSA certificate with the  property set to . The input DSA certificate object isn't modified.

    */
    public static func CopyWithPrivateKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, privateKey : dotnet.System.Security.Cryptography.DSA) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_DSACertificateExtensions_X509Certificate2__CopyWithPrivateKey_0__2__X509Certificate2_DSA(&__thrown, certificate.get_handle(), privateKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSA GetDSAPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.DSACertificateExtensions.GetDSAPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Gets the  private key from the .

    - Parameter certificate: The certificate.
    - Returns: The private key, or  if the certificate does not have a DSA private key.

    */
    public static func GetDSAPrivateKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Optional<dotnet.System.Security.Cryptography.DSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_DSACertificateExtensions_DSA__GetDSAPrivateKey_0__1__X509Certificate2(&__thrown, certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.DSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.DSA GetDSAPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.DSACertificateExtensions.GetDSAPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Gets the  public key from the .

    - Parameter certificate: The certificate.
    - Returns: The public key, or  if the certificate does not have a DSA public key.

    */
    public static func GetDSAPublicKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Optional<dotnet.System.Security.Cryptography.DSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_DSACertificateExtensions_DSA__GetDSAPublicKey_0__1__X509Certificate2(&__thrown, certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.DSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DSACertificateExtensions


// type: System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions
public struct ECDsaCertificateExtensions {
    // System.Security.Cryptography.X509Certificates.X509Certificate2 CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.ECDsa)
// docid: M:System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions.CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.ECDsa)
    /**
    Combines a private key with the public key of an  certificate to generate a new ECDSA certificate.

    - Parameter certificate: The ECDSA certificate.
    - Parameter privateKey: The private ECDSA key.
    - Returns: A new ECDSA certificate with the  property set to . The input ECDSA certificate object isn't modified.

    */
    public static func CopyWithPrivateKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, privateKey : dotnet.System.Security.Cryptography.ECDsa) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_ECDsaCertificateExtensions_X509Certificate2__CopyWithPrivateKey_0__2__X509Certificate2_ECDsa(&__thrown, certificate.get_handle(), privateKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDsa GetECDsaPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions.GetECDsaPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Gets the  private key from the  certificate.

    - Parameter certificate: The certificate.
    - Returns: The private key, or  if the certificate does not have an ECDsa private key.

    */
    public static func GetECDsaPrivateKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Optional<dotnet.System.Security.Cryptography.ECDsa> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_ECDsaCertificateExtensions_ECDsa__GetECDsaPrivateKey_0__1__X509Certificate2(&__thrown, certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDsa(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.ECDsa GetECDsaPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions.GetECDsaPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Gets the  public key from the  certificate.

    - Parameter certificate: The certificate.
    - Returns: The public key, or  if the certificate does not have an ECDsa public key.

    */
    public static func GetECDsaPublicKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Optional<dotnet.System.Security.Cryptography.ECDsa> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_ECDsaCertificateExtensions_ECDsa__GetECDsaPublicKey_0__1__X509Certificate2(&__thrown, certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDsa(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ECDsaCertificateExtensions


// type: System.Security.Cryptography.X509Certificates.OpenFlags
    /**
    Specifies the way to open the X.509 certificate store.

    */
public struct OpenFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_OpenFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.OpenFlags ReadOnly
    /**
    Open the X.509 certificate store for reading only.

    */
    public static var ReadOnly : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.OpenFlags(val: System_Security_Cryptography_X509Certificates_OpenFlags_get_ReadOnly());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.OpenFlags ReadWrite
    /**
    Open the X.509 certificate store for both reading and writing.

    */
    public static var ReadWrite : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.OpenFlags(val: System_Security_Cryptography_X509Certificates_OpenFlags_get_ReadWrite());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.OpenFlags MaxAllowed
    /**
    Open the X.509 certificate store for the highest access allowed.

    */
    public static var MaxAllowed : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.OpenFlags(val: System_Security_Cryptography_X509Certificates_OpenFlags_get_MaxAllowed());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.OpenFlags OpenExistingOnly
    /**
    Opens only existing stores; if no store exists, the  method will not create a new store.

    */
    public static var OpenExistingOnly : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.OpenFlags(val: System_Security_Cryptography_X509Certificates_OpenFlags_get_OpenExistingOnly());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.OpenFlags IncludeArchived
    /**
    Open the X.509 certificate store and include archived certificates.

    */
    public static var IncludeArchived : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.OpenFlags(val: System_Security_Cryptography_X509Certificates_OpenFlags_get_IncludeArchived());
            return __return;
        }
    }
} // OpenFlags


// type: System.Security.Cryptography.X509Certificates.PublicKey
    /**
    Represents a certificate's public key information. This class cannot be inherited.

    */
public final class PublicKey
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_PublicKey_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_PublicKey_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class using SubjectPublicKeyInfo from an .

    - Parameter key: An asymmetric algorithm to obtain the SubjectPublicKeyInfo from.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_PublicKey_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.Oid, System.Security.Cryptography.AsnEncodedData, System.Security.Cryptography.AsnEncodedData)
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.#ctor(System.Security.Cryptography.Oid,System.Security.Cryptography.AsnEncodedData,System.Security.Cryptography.AsnEncodedData)
    /**
    Initializes a new instance of the  class using an object identifier (OID) object of the public key, an ASN.1-encoded representation of the public key parameters, and an ASN.1-encoded representation of the public key value.

    - Parameter oid: An object identifier (OID) object that represents the public key.
    - Parameter parameters: An ASN.1-encoded representation of the public key parameters.
    - Parameter keyValue: An ASN.1-encoded representation of the public key value.
    */
    public init(oid : dotnet.System.Security.Cryptography.Oid, parameters : dotnet.System.Security.Cryptography.AsnEncodedData, keyValue : dotnet.System.Security.Cryptography.AsnEncodedData) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_PublicKey_ctor_0__3__Oid_AsnEncodedData_AsnEncodedData(&__thrown, oid.get_handle(), parameters.get_handle(), keyValue.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.PublicKey CreateFromSubjectPublicKeyInfo(System.ReadOnlySpan<System.Byte>, ref System.Int32)
    // System.Byte[] ExportSubjectPublicKeyInfo()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.ExportSubjectPublicKeyInfo
    /**
    Exports the current key in the X.509 SubjectPublicKeyInfo format.

    - Returns: A byte array containing the X.509 SubjectPublicKeyInfo representation of this key.

    */
    public func ExportSubjectPublicKeyInfo() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_u8Array__ExportSubjectPublicKeyInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSA GetDSAPublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.GetDSAPublicKey
    /**
    Gets the  public key, or  if the key is not an DSA key.

    - Returns: The public key, or  if the key is not an DSA key.

    */
    public func GetDSAPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.DSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_DSA__GetDSAPublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.DSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.ECDiffieHellman GetECDiffieHellmanPublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.GetECDiffieHellmanPublicKey
    /**
    Gets the  public key, or  if the key is not an ECDiffieHellman key.

    - Returns: The public key, or  if the key is not an ECDiffieHellman key.

    */
    public func GetECDiffieHellmanPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.ECDiffieHellman> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_ECDiffieHellman__GetECDiffieHellmanPublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDiffieHellman(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.ECDsa GetECDsaPublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.GetECDsaPublicKey
    /**
    Gets the  public key, or  if the key is not an ECDsa key.

    - Returns: The public key, or  if the key is not an ECDsa key.

    */
    public func GetECDsaPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.ECDsa> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_ECDsa__GetECDsaPublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDsa(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.RSA GetRSAPublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.GetRSAPublicKey
    /**
    Gets the  public key, or  if the key is not an RSA key.

    - Returns: The public key, or  if the key is not an RSA key.

    */
    public func GetRSAPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.RSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_RSA__GetRSAPublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
// TODO COPE (write_all_methods) (span) bool TryExportSubjectPublicKeyInfo(System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Security.Cryptography.AsnEncodedData get_EncodedKeyValue()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.get_EncodedKeyValue
    public func get_EncodedKeyValue() throws -> dotnet.System.Security.Cryptography.AsnEncodedData {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_AsnEncodedData__get_EncodedKeyValue_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.AsnEncodedData(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.AsnEncodedData get_EncodedParameters()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.get_EncodedParameters
    public func get_EncodedParameters() throws -> dotnet.System.Security.Cryptography.AsnEncodedData {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_AsnEncodedData__get_EncodedParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.AsnEncodedData(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.AsymmetricAlgorithm get_Key()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.get_Key
    public func get_Key() throws -> dotnet.System.Security.Cryptography.AsymmetricAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_AsymmetricAlgorithm__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.AsymmetricAlgorithm(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.Oid get_Oid()
// docid: M:System.Security.Cryptography.X509Certificates.PublicKey.get_Oid
    public func get_Oid() throws -> dotnet.System.Security.Cryptography.Oid {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_PublicKey_Oid__get_Oid_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.Oid(hndl : __return);
        }
    }
    /**
    Gets the ASN.1-encoded representation of the public key value.

    */
    public var EncodedKeyValue : dotnet.System.Security.Cryptography.AsnEncodedData {
        get {
            return try! get_EncodedKeyValue();
        }
    }
    /**
    Gets the ASN.1-encoded representation of the public key parameters.

    */
    public var EncodedParameters : dotnet.System.Security.Cryptography.AsnEncodedData {
        get {
            return try! get_EncodedParameters();
        }
    }
    /**
    Gets an  derived object or a  derived object representing the public key.

    */
    public var Key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm {
        get {
            return try! get_Key();
        }
    }
    /**
    Gets an object identifier (OID) object of the public key.

    */
    public var Oid : dotnet.System.Security.Cryptography.Oid {
        get {
            return try! get_Oid();
        }
    }
} // PublicKey


// type: System.Security.Cryptography.X509Certificates.RSACertificateExtensions
public struct RSACertificateExtensions {
    // System.Security.Cryptography.X509Certificates.X509Certificate2 CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.RSA)
// docid: M:System.Security.Cryptography.X509Certificates.RSACertificateExtensions.CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.RSA)
    /**
    Combines a private key with the public key of an  certificate to generate a new RSA certificate.

    - Parameter certificate: The RSA certificate.
    - Parameter privateKey: The private RSA key.
    - Returns: A new RSA certificate with the  property set to . The input RSA certificate object isn't modified.

    */
    public static func CopyWithPrivateKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, privateKey : dotnet.System.Security.Cryptography.RSA) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_RSACertificateExtensions_X509Certificate2__CopyWithPrivateKey_0__2__X509Certificate2_RSA(&__thrown, certificate.get_handle(), privateKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSA GetRSAPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.RSACertificateExtensions.GetRSAPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Gets the  private key from the .

    - Parameter certificate: The certificate.
    - Returns: The private key, or  if the certificate does not have an RSA private key.

    */
    public static func GetRSAPrivateKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Optional<dotnet.System.Security.Cryptography.RSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_RSACertificateExtensions_RSA__GetRSAPrivateKey_0__1__X509Certificate2(&__thrown, certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.RSA GetRSAPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.RSACertificateExtensions.GetRSAPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Gets the  public key from the .

    - Parameter certificate: The certificate.
    - Returns: The public key, or  if the certificate does not have an RSA public key.

    */
    public static func GetRSAPublicKey(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Optional<dotnet.System.Security.Cryptography.RSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_RSACertificateExtensions_RSA__GetRSAPublicKey_0__1__X509Certificate2(&__thrown, certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // RSACertificateExtensions


// type: System.Security.Cryptography.X509Certificates.StoreLocation
    /**
    Specifies the location of the X.509 certificate store.

    */
public struct StoreLocation : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_StoreLocation_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.StoreLocation CurrentUser
    /**
    The X.509 certificate store used by the current user.

    */
    public static var CurrentUser : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreLocation(val: System_Security_Cryptography_X509Certificates_StoreLocation_get_CurrentUser());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreLocation LocalMachine
    /**
    The X.509 certificate store assigned to the local machine.

    */
    public static var LocalMachine : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreLocation(val: System_Security_Cryptography_X509Certificates_StoreLocation_get_LocalMachine());
            return __return;
        }
    }
} // StoreLocation


// type: System.Security.Cryptography.X509Certificates.StoreName
    /**
    Specifies the name of the X.509 certificate store to open.

    */
public struct StoreName : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_StoreName_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.StoreName AddressBook
    /**
    The X.509 certificate store for other users.

    */
    public static var AddressBook : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_AddressBook());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreName AuthRoot
    /**
    The X.509 certificate store for third-party certificate authorities (CAs).

    */
    public static var AuthRoot : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_AuthRoot());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreName CertificateAuthority
    /**
    The X.509 certificate store for intermediate certificate authorities (CAs).

    */
    public static var CertificateAuthority : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_CertificateAuthority());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreName Disallowed
    /**
    The X.509 certificate store for revoked certificates.

    */
    public static var Disallowed : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_Disallowed());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreName My
    /**
    The X.509 certificate store for personal certificates.

    */
    public static var My : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_My());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreName Root
    /**
    The X.509 certificate store for trusted root certificate authorities (CAs).

    */
    public static var Root : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_Root());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreName TrustedPeople
    /**
    The X.509 certificate store for directly trusted people and resources.

    */
    public static var TrustedPeople : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_TrustedPeople());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.StoreName TrustedPublisher
    /**
    The X.509 certificate store for directly trusted publishers.

    */
    public static var TrustedPublisher : dotnet.System.Security.Cryptography.X509Certificates.StoreName {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.StoreName(val: System_Security_Cryptography_X509Certificates_StoreName_get_TrustedPublisher());
            return __return;
        }
    }
} // StoreName


// type: System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder
    /**
    This class facilitates building a subject alternative name extension for an X.509 certificate.

    */
public final class SubjectAlternativeNameBuilder
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AddDnsName(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.AddDnsName(System.String)
    /**
    Adds a DNS Name to the subject alternative name extension.

    - Parameter dnsName: The DNS name to be added.
    */
    public func AddDnsName(dnsName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_void__AddDnsName_0__1__String(&__thrown, self.get_handle(), dnsName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddEmailAddress(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.AddEmailAddress(System.String)
    /**
    Adds an email address to the subject alternative name extension.

    - Parameter emailAddress: The email address to be added.
    */
    public func AddEmailAddress(emailAddress : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_void__AddEmailAddress_0__1__String(&__thrown, self.get_handle(), emailAddress.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddIpAddress(System.Net.IPAddress)
// docid: M:System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.AddIpAddress(System.Net.IPAddress)
    /**
    Adds an IP address to the subject alternative name extension.

    - Parameter ipAddress: The IP address to be added.
    */
    public func AddIpAddress(ipAddress : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_void__AddIpAddress_0__1__IPAddress(&__thrown, self.get_handle(), ipAddress.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddUri(System.Uri)
// docid: M:System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.AddUri(System.Uri)
    /**
    Adds a Uniform Resource Identifier (URI) to the subject alternative name extension.

    - Parameter uri: The URI to be added.
    */
    public func AddUri(uri : dotnet.System.Uri) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_void__AddUri_0__1__Uri(&__thrown, self.get_handle(), uri.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddUserPrincipalName(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.AddUserPrincipalName(System.String)
    /**
    Adds a User Principal Name (UPN) to the subject alternative name extension.

    - Parameter upn: The UPN to be added.
    */
    public func AddUserPrincipalName(upn : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_void__AddUserPrincipalName_0__1__String(&__thrown, self.get_handle(), upn.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Extension Build(bool)
// docid: M:System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.Build(System.Boolean)
    /**
    Returns an  object that represents the encoded subject alternative name extension.

    - Parameter critical: 
         to mark the extension as ; otherwise, . The default value is .
    - Returns: An  object that represents the encoded subject alternative name extension.

    */
    public func Build(critical : Bool = false) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Extension {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_SubjectAlternativeNameBuilder_X509Extension__Build_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Extension(hndl : __return);
        }
    }
} // SubjectAlternativeNameBuilder


// type: System.Security.Cryptography.X509Certificates.X500DistinguishedName
    /**
    Represents the distinguished name of an X509 certificate. This class cannot be inherited.

    */
public final class X500DistinguishedName
    :
    dotnet.System.Security.Cryptography.AsnEncodedData
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X500DistinguishedName_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X500DistinguishedName_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class using information from the specified byte array.

    - Parameter encodedDistinguishedName: A byte array that contains distinguished name information.
    */
    public init(encodedDistinguishedName : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X500DistinguishedName_ctor_0__1__u8Array(&__thrown, encodedDistinguishedName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>)
    // .ctor(System.Security.Cryptography.AsnEncodedData)
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.#ctor(System.Security.Cryptography.AsnEncodedData)
    /**
    Initializes a new instance of the  class using the specified  object.

    - Parameter encodedDistinguishedName: An  object that represents the distinguished name.
    */
    public init(encodedDistinguishedName : dotnet.System.Security.Cryptography.AsnEncodedData) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X500DistinguishedName_ctor_0__1__AsnEncodedData(&__thrown, encodedDistinguishedName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName)
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.#ctor(System.Security.Cryptography.X509Certificates.X500DistinguishedName)
    /**
    Initializes a new instance of the  class using the specified  object.

    - Parameter distinguishedName: An  object.
    */
    public init(distinguishedName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X500DistinguishedName_ctor_0__1__X500DistinguishedName(&__thrown, distinguishedName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.#ctor(System.String)
    /**
    Initializes a new instance of the  class using information from the specified string.

    - Parameter distinguishedName: A string that represents the distinguished name.
    */
    public init(distinguishedName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X500DistinguishedName_ctor_0__1__String(&__thrown, distinguishedName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.#ctor(System.String,System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags)
    /**
    Initializes a new instance of the  class using the specified string and  flag.

    - Parameter distinguishedName: A string that represents the distinguished name.
    - Parameter flag: A bitwise combination of the enumeration values that specify the characteristics of the distinguished name.
    */
    public init(distinguishedName : dotnet.System.String, flag : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X500DistinguishedName_ctor_0__2__String_X500DistinguishedNameFlags(&__thrown, distinguishedName.get_handle(), flag.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String Decode(System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.Decode(System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags)
    /**
    Decodes a distinguished name using the characteristics specified by the  parameter.

    - Parameter flag: A bitwise combination of the enumeration values that specify the characteristics of the distinguished name.
    - Returns: The decoded distinguished name.

    */
    public func Decode(flag : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X500DistinguishedName_String__Decode_0__1__X500DistinguishedNameFlags(&__thrown, self.get_handle(), flag.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String Format(bool)
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.Format(System.Boolean)
    /**
    Returns a formatted version of an X500 distinguished name for printing or for output to a text window or to a console.

    - Parameter multiLine: 
         if the return string should contain carriage returns; otherwise, .
    - Returns: A formatted string that represents the X500 distinguished name.

    */
    public override func Format(multiLine : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X500DistinguishedName_String__Format_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(multiLine ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Security.Cryptography.X509Certificates.X500DistinguishedName.get_Name
    public func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X500DistinguishedName_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the comma-delimited distinguished name from an X500 certificate.

    */
    public var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
    }
} // X500DistinguishedName


// type: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags
    /**
    Specifies characteristics of the X.500 distinguished name.

    */
public struct X500DistinguishedNameFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags None
    /**
    The distinguished name has no special characteristics.

    */
    public static var None : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags Reversed
    /**
    The distinguished name is reversed.

    */
    public static var Reversed : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_Reversed());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags UseSemicolons
    /**
    The distinguished name uses semicolons.

    */
    public static var UseSemicolons : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_UseSemicolons());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags DoNotUsePlusSign
    /**
    The distinguished name does not use the plus sign.

    */
    public static var DoNotUsePlusSign : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_DoNotUsePlusSign());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags DoNotUseQuotes
    /**
    The distinguished name does not use quotation marks.

    */
    public static var DoNotUseQuotes : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_DoNotUseQuotes());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags UseCommas
    /**
    The distinguished name uses commas.

    */
    public static var UseCommas : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_UseCommas());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags UseNewLines
    /**
    The distinguished name uses the new line character.

    */
    public static var UseNewLines : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_UseNewLines());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags UseUTF8Encoding
    /**
    The distinguished name uses UTF8 encoding instead of Unicode character encoding.

    */
    public static var UseUTF8Encoding : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_UseUTF8Encoding());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags UseT61Encoding
    /**
    The distinguished name uses T61 encoding.

    */
    public static var UseT61Encoding : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_UseT61Encoding());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags ForceUTF8Encoding
    /**
    Forces the distinguished name to encode specific X.500 keys as UTF-8 strings rather than printable Unicode strings. For more information and the list of X.500 keys affected, see the X500NameFlags enumeration.

    */
    public static var ForceUTF8Encoding : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags(val: System_Security_Cryptography_X509Certificates_X500DistinguishedNameFlags_get_ForceUTF8Encoding());
            return __return;
        }
    }
} // X500DistinguishedNameFlags


// type: System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension
    /**
    Defines the constraints set on a certificate. This class cannot be inherited.

    */
public final class X509BasicConstraintsExtension
    :
    dotnet.System.Security.Cryptography.X509Certificates.X509Extension
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool, bool, System.Int32, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension.#ctor(System.Boolean,System.Boolean,System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class. Parameters specify a value that indicates whether a certificate is a certificate authority (CA) certificate, a value that indicates whether the certificate has a restriction on the number of path levels it allows, the number of levels allowed in a certificate's path, and a value that indicates whether the extension is critical.

    - Parameter certificateAuthority: 
         if the certificate is a certificate authority (CA) certificate; otherwise, .
    - Parameter hasPathLengthConstraint: 
         if the certificate has a restriction on the number of path levels it allows; otherwise, .
    - Parameter pathLengthConstraint: The number of levels allowed in a certificate's path.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(certificateAuthority : Bool, hasPathLengthConstraint : Bool, pathLengthConstraint : Swift.Int32, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_ctor_0__4__bool_bool_i32_bool(&__thrown, Swift.Int32(certificateAuthority ? 1 : 0), Swift.Int32(hasPathLengthConstraint ? 1 : 0), pathLengthConstraint, Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsnEncodedData, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension.#ctor(System.Security.Cryptography.AsnEncodedData,System.Boolean)
    /**
    Initializes a new instance of the  class using an  object and a value that identifies whether the extension is critical.

    - Parameter encodedBasicConstraints: The encoded data to use to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(encodedBasicConstraints : dotnet.System.Security.Cryptography.AsnEncodedData, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_ctor_0__2__AsnEncodedData_bool(&__thrown, encodedBasicConstraints.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void CopyFrom(System.Security.Cryptography.AsnEncodedData)
// docid: M:System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension.CopyFrom(System.Security.Cryptography.AsnEncodedData)
    /**
    Initializes a new instance of the  class using an  object.

    - Parameter asnEncodedData: The encoded data to use to create the extension.
    */
    public override func CopyFrom(asnEncodedData : dotnet.System.Security.Cryptography.AsnEncodedData) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_void__CopyFrom_0__1__AsnEncodedData(&__thrown, self.get_handle(), asnEncodedData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CertificateAuthority()
// docid: M:System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension.get_CertificateAuthority
    public func get_CertificateAuthority() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_bool__get_CertificateAuthority_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_HasPathLengthConstraint()
// docid: M:System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension.get_HasPathLengthConstraint
    public func get_HasPathLengthConstraint() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_bool__get_HasPathLengthConstraint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_PathLengthConstraint()
// docid: M:System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension.get_PathLengthConstraint
    public func get_PathLengthConstraint() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509BasicConstraintsExtension_i32__get_PathLengthConstraint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets a value indicating whether a certificate is a certificate authority (CA) certificate.

    */
    public var CertificateAuthority : Bool {
        get {
            return try! get_CertificateAuthority();
        }
    }
    /**
    Gets a value indicating whether a certificate has a restriction on the number of path levels it allows.

    */
    public var HasPathLengthConstraint : Bool {
        get {
            return try! get_HasPathLengthConstraint();
        }
    }
    /**
    Gets the number of levels allowed in a certificate's path.

    */
    public var PathLengthConstraint : Swift.Int32 {
        get {
            return try! get_PathLengthConstraint();
        }
    }
} // X509BasicConstraintsExtension


// type: System.Security.Cryptography.X509Certificates.X509Certificate
    /**
    Provides methods that help you use X.509 v.3 certificates.

    */
open class X509Certificate
    :
    dotnet.System.Object,
    System_IDisposable,
    System_Runtime_Serialization_IDeserializationCallback,
    System_Runtime_Serialization_ISerializable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509Certificate_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509Certificate_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class defined from a sequence of bytes representing an X.509v3 certificate.

    - Parameter data: A byte array containing data from an X.509 certificate.
    */
    public init(data : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__1__u8Array(&__thrown, data.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Security.SecureString)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.Byte[],System.Security.SecureString)
    /**
    Initializes a new instance of the  class using a byte array and a password.

    - Parameter rawData: A byte array that contains data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.Security.SecureString>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__2__u8Array_SecureString(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using a byte array, a password, and a key storage flag.

    - Parameter rawData: A byte array that contains data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__3__u8Array_SecureString_X509KeyStorageFlags(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.Byte[],System.String)
    /**
    Initializes a new instance of the  class using a byte array and a password.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__2__u8Array_String(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using a byte array, a password, and a key storage flag.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__3__u8Array_String_X509KeyStorageFlags(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class using a handle to an unmanaged  structure.

    - Parameter handle: A handle to an unmanaged  structure.
    */
    public init(handle : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__1__IntPtr(&__thrown, handle.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    /**
    Initializes a new instance of the  class using a  object and a  structure.

    - Parameter info: A  object that describes serialization information.
    - Parameter context: A  structure that describes how serialization should be performed.
    */
    public init(info : dotnet.System.Runtime.Serialization.SerializationInfo, context : dotnet.System.Runtime.Serialization.StreamingContext) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__2__SerializationInfo_StreamingContext(&__thrown, info.get_handle(), context.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Initializes a new instance of the  class using another  class.

    - Parameter cert: A  class from which to initialize this class.
    */
    public init(cert : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__1__X509Certificate(&__thrown, cert.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.String)
    /**
    Initializes a new instance of the  class using the name of a PKCS7 signed file.

    - Parameter fileName: The name of a PKCS7 signed file.
    */
    public init(fileName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__1__String(&__thrown, fileName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.SecureString)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.String,System.Security.SecureString)
    /**
    Initializes a new instance of the  class using a certificate file name and a password.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public init(fileName : dotnet.System.String, password : Optional<dotnet.System.Security.SecureString>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__2__String_SecureString(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using a certificate file name, a password, and a key storage flag.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public init(fileName : dotnet.System.String, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__3__String_SecureString_X509KeyStorageFlags(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.String,System.String)
    /**
    Initializes a new instance of the  class using the name of a PKCS7 signed file and a password to access the certificate.

    - Parameter fileName: The name of a PKCS7 signed file.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public init(fileName : dotnet.System.String, password : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__2__String_String(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.#ctor(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using the name of a PKCS7 signed file, a password to access the certificate, and a key storage flag.

    - Parameter fileName: The name of a PKCS7 signed file.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public init(fileName : dotnet.System.String, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate_ctor_0__3__String_String_X509KeyStorageFlags(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate CreateFromCertFile(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.CreateFromCertFile(System.String)
    /**
    Creates an X.509v3 certificate from the specified PKCS7 signed file.

    - Parameter filename: The path of the PKCS7 signed file from which to create the X.509 certificate.
    - Returns: The newly created X.509 certificate.

    */
    open class func CreateFromCertFile(filename : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_X509Certificate__CreateFromCertFile_0__1__String(&__thrown, filename.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate CreateFromSignedFile(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.CreateFromSignedFile(System.String)
    /**
    Creates an X.509v3 certificate from the specified signed file.

    - Parameter filename: The path of the signed file from which to create the X.509 certificate.
    - Returns: The newly created X.509 certificate.

    */
    open class func CreateFromSignedFile(filename : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_X509Certificate__CreateFromSignedFile_0__1__String(&__thrown, filename.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Dispose
    /**
    Releases all resources used by the current  object.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Equals(System.Object)
    /**
    Compares two  objects for equality.

    - Parameter obj: An  object to compare to the current object.
    - Returns: 
         if the current  object is equal to the object specified by the  parameter; otherwise, .

    */
    open override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Equals(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Compares two  objects for equality.

    - Parameter other: An  object to compare to the current object.
    - Returns: 
         if the current  object is equal to the object specified by the  parameter; otherwise, .

    */
    open func Equals(other : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_bool__Equals_0__1__X509Certificate(&__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Export(System.Security.Cryptography.X509Certificates.X509ContentType)
    /**
    Exports the current  object to a byte array in a format described by one of the  values.

    - Parameter contentType: One of the  values that describes how to format the output data.
    - Returns: An array of bytes that represents the current  object.

    */
    open func Export(contentType : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__Export_0__1__X509ContentType(&__thrown, self.get_handle(), contentType.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType, System.Security.SecureString)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.Security.SecureString)
    /**
    Exports the current  object to a byte array using the specified format and a password.

    - Parameter contentType: One of the  values that describes how to format the output data.
    - Parameter password: The password required to access the X.509 certificate data.
    - Returns: A byte array that represents the current  object.

    */
    open func Export(contentType : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType, password : Optional<dotnet.System.Security.SecureString>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__Export_0__2__X509ContentType_SecureString(&__thrown, self.get_handle(), contentType.get_value(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType, System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.String)
    /**
    Exports the current  object to a byte array in a format described by one of the  values, and using the specified password.

    - Parameter contentType: One of the  values that describes how to format the output data.
    - Parameter password: The password required to access the X.509 certificate data.
    - Returns: An array of bytes that represents the current  object.

    */
    open func Export(contentType : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType, password : Optional<dotnet.System.String>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__Export_0__2__X509ContentType_String(&__thrown, self.get_handle(), contentType.get_value(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] GetCertHash()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHash
    /**
    Returns the hash value for the X.509v3 certificate as an array of bytes.

    - Returns: The hash value for the X.509 certificate.

    */
    open func GetCertHash() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__GetCertHash_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] GetCertHash(System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHash(System.Security.Cryptography.HashAlgorithmName)
    /**
    Returns the hash value for the X.509v3 certificate that is computed by using the specified cryptographic hash algorithm.

    - Parameter hashAlgorithm: The name of the cryptographic hash algorithm to use.
    - Returns: A byte array that contains the hash value for the X.509 certificate.

    */
    open func GetCertHash(hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__GetCertHash_0__1__HashAlgorithmName(&__thrown, self.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String GetCertHashString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHashString
    /**
    Returns the SHA1 hash value for the X.509v3 certificate as a hexadecimal string.

    - Returns: The hexadecimal string representation of the X.509 certificate hash value.

    */
    open func GetCertHashString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetCertHashString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String GetCertHashString(System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHashString(System.Security.Cryptography.HashAlgorithmName)
    /**
    Returns a hexadecimal string containing the hash value for the X.509v3 certificate computed using the specified cryptographic hash algorithm.

    - Parameter hashAlgorithm: The name of the cryptographic hash algorithm to use.
    - Returns: The hexadecimal string representation of the X.509 certificate hash value.

    */
    open func GetCertHashString(hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetCertHashString_0__1__HashAlgorithmName(&__thrown, self.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String GetEffectiveDateString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetEffectiveDateString
    /**
    Returns the effective date of this X.509v3 certificate.

    - Returns: The effective date for this X.509 certificate.

    */
    open func GetEffectiveDateString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetEffectiveDateString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String GetExpirationDateString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetExpirationDateString
    /**
    Returns the expiration date of this X.509v3 certificate.

    - Returns: The expiration date for this X.509 certificate.

    */
    open func GetExpirationDateString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetExpirationDateString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String GetFormat()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetFormat
    /**
    Returns the name of the format of this X.509v3 certificate.

    - Returns: The format of this X.509 certificate.

    */
    open func GetFormat() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetFormat_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetHashCode
    /**
    Returns the hash code for the X.509v3 certificate as an integer.

    - Returns: The hash code for the X.509 certificate as an integer.

    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.String GetIssuerName()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetIssuerName
    /**
    Returns the name of the certification authority that issued the X.509v3 certificate.

    - Returns: The name of the certification authority that issued the X.509 certificate.

    */
    open func GetIssuerName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetIssuerName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String GetKeyAlgorithm()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetKeyAlgorithm
    /**
    Returns the key algorithm information for this X.509v3 certificate as a string.

    - Returns: The key algorithm information for this X.509 certificate as a string.

    */
    open func GetKeyAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetKeyAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Byte[] GetKeyAlgorithmParameters()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetKeyAlgorithmParameters
    /**
    Returns the key algorithm parameters for the X.509v3 certificate as an array of bytes.

    - Returns: The key algorithm parameters for the X.509 certificate as an array of bytes.

    */
    open func GetKeyAlgorithmParameters() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__GetKeyAlgorithmParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String GetKeyAlgorithmParametersString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetKeyAlgorithmParametersString
    /**
    Returns the key algorithm parameters for the X.509v3 certificate as a hexadecimal string.

    - Returns: The key algorithm parameters for the X.509 certificate as a hexadecimal string.

    */
    open func GetKeyAlgorithmParametersString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetKeyAlgorithmParametersString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String GetName()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetName
    /**
    Returns the name of the principal to which the certificate was issued.

    - Returns: The name of the principal to which the certificate was issued.

    */
    open func GetName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Byte[] GetPublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetPublicKey
    /**
    Returns the public key for the X.509v3 certificate as an array of bytes.

    - Returns: The public key for the X.509 certificate as an array of bytes.

    */
    open func GetPublicKey() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__GetPublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String GetPublicKeyString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetPublicKeyString
    /**
    Returns the public key for the X.509v3 certificate as a hexadecimal string.

    - Returns: The public key for the X.509 certificate as a hexadecimal string.

    */
    open func GetPublicKeyString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetPublicKeyString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Byte[] GetRawCertData()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetRawCertData
    /**
    Returns the raw data for the entire X.509v3 certificate as an array of bytes.

    - Returns: A byte array containing the X.509 certificate data.

    */
    open func GetRawCertData() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__GetRawCertData_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String GetRawCertDataString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetRawCertDataString
    /**
    Returns the raw data for the entire X.509v3 certificate as a hexadecimal string.

    - Returns: The X.509 certificate data as a hexadecimal string.

    */
    open func GetRawCertDataString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetRawCertDataString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Byte[] GetSerialNumber()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetSerialNumber
    /**
    Returns the serial number of the X.509v3 certificate as an array of bytes in little-endian order.

    - Returns: The serial number of the X.509 certificate as an array of bytes in little-endian order.

    */
    open func GetSerialNumber() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_u8Array__GetSerialNumber_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String GetSerialNumberString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.GetSerialNumberString
    /**
    Returns the serial number of the X.509v3 certificate as a little-endian hexadecimal string .

    - Returns: The serial number of the X.509 certificate as a little-endian hexadecimal string.

    */
    open func GetSerialNumberString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__GetSerialNumberString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // void Import(System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Import(System.Byte[])
    /**
    Populates the  object with data from a byte array.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    */
    open func Import(rawData : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Import_0__1__u8Array(&__thrown, self.get_handle(), rawData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.Byte[], System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Import(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates an  object using data from a byte array, a password, and a key storage flag.

    - Parameter rawData: A byte array that contains data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open func Import(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Import_0__3__u8Array_SecureString_X509KeyStorageFlags(&__thrown, self.get_handle(), rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.Byte[], System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates the  object using data from a byte array, a password, and flags for determining how the private key is imported.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open func Import(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Import_0__3__u8Array_String_X509KeyStorageFlags(&__thrown, self.get_handle(), rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Import(System.String)
    /**
    Populates the  object with information from a certificate file.

    - Parameter fileName: The name of a certificate file represented as a string.
    */
    open func Import(fileName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Import_0__1__String(&__thrown, self.get_handle(), fileName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.String, System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Import(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates an  object with information from a certificate file, a password, and a key storage flag.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open func Import(fileName : dotnet.System.String, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Import_0__3__String_SecureString_X509KeyStorageFlags(&__thrown, self.get_handle(), fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.String, System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates the  object with information from a certificate file, a password, and a  value.

    - Parameter fileName: The name of a certificate file represented as a string.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open func Import(fileName : dotnet.System.String, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Import_0__3__String_String_X509KeyStorageFlags(&__thrown, self.get_handle(), fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.Reset
    /**
    Resets the state of the  object.

    */
    open func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.ToString
    /**
    Returns a string representation of the current  object.

    - Returns: A string representation of the current  object.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String ToString(bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.ToString(System.Boolean)
    /**
    Returns a string representation of the current  object, with extra information, if specified.

    - Parameter fVerbose: 
         to produce the verbose form of the string representation; otherwise, .
    - Returns: A string representation of the current  object.

    */
    open func ToString(fVerbose : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__ToString_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(fVerbose ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryGetCertHash(System.Security.Cryptography.HashAlgorithmName, System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.IntPtr get_Handle()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.get_Handle
    open func get_Handle() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_IntPtr__get_Handle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] System.String get_Issuer()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.get_Issuer
    open func get_Issuer() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__get_Issuer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Subject()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate.get_Subject
    open func get_Subject() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate_String__get_Subject_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets a handle to a Microsoft Cryptographic API certificate context described by an unmanaged  structure.

    */
    open var Handle : dotnet.System.IntPtr {
        get {
            return try! get_Handle();
        }
    }
    /**
    Gets the name of the certificate authority that issued the X.509v3 certificate.

    */
    open var Issuer : dotnet.System.String {
        get {
            return try! get_Issuer();
        }
    }
    /**
    Gets the subject distinguished name from the certificate.

    */
    open var Subject : dotnet.System.String {
        get {
            return try! get_Subject();
        }
    }
} // X509Certificate


// type: System.Security.Cryptography.X509Certificates.X509Certificate2
    /**
    Represents an X.509 certificate.

    */
open class X509Certificate2
    :
    dotnet.System.Security.Cryptography.X509Certificates.X509Certificate
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509Certificate2_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509Certificate2_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class using information from a byte array.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    */
    public init(rawData : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__1__u8Array(&__thrown, rawData.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Security.SecureString)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString)
    /**
    Initializes a new instance of the  class using a byte array and a password.

    - Parameter rawData: A byte array that contains data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public override init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.Security.SecureString>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__2__u8Array_SecureString(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using a byte array, a password, and a key storage flag.

    - Parameter rawData: A byte array that contains data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public override init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__3__u8Array_SecureString_X509KeyStorageFlags(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)
    /**
    Initializes a new instance of the  class using a byte array and a password.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public override init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__2__u8Array_String(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using a byte array, a password, and a key storage flag.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public override init(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__3__u8Array_String_X509KeyStorageFlags(&__thrown, rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class using an unmanaged handle.

    - Parameter handle: A pointer to a certificate context in unmanaged code. The C structure is called .
    */
    public override init(handle : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__1__IntPtr(&__thrown, handle.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>)
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Char>, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    // .ctor(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Initializes a new instance of the  class using an  object.

    - Parameter certificate: An  object.
    */
    public init(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__1__X509Certificate(&__thrown, certificate.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String)
    /**
    Initializes a new instance of the  class using a certificate file name.

    - Parameter fileName: The name of a certificate file.
    */
    public override init(fileName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__1__String(&__thrown, fileName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.String, System.ReadOnlySpan<System.Char>, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    // .ctor(System.String, System.Security.SecureString)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString)
    /**
    Initializes a new instance of the  class using a certificate file name and a password.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public override init(fileName : dotnet.System.String, password : Optional<dotnet.System.Security.SecureString>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__2__String_SecureString(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using a certificate file name, a password, and a key storage flag.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public override init(fileName : dotnet.System.String, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__3__String_SecureString_X509KeyStorageFlags(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String)
    /**
    Initializes a new instance of the  class using a certificate file name and a password used to access the certificate.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    */
    public override init(fileName : dotnet.System.String, password : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__2__String_String(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Initializes a new instance of the  class using a certificate file name, a password used to access the certificate, and a key storage flag.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    public override init(fileName : dotnet.System.String, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2_ctor_0__3__String_String_X509KeyStorageFlags(&__thrown, fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate2 CopyWithPrivateKey(System.Security.Cryptography.ECDiffieHellman)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.CopyWithPrivateKey(System.Security.Cryptography.ECDiffieHellman)
    /**
    Combines a private key with the public key of an  certificate to generate a new ECDiffieHellman certificate.

    - Parameter privateKey: The private ECDiffieHellman key.
    - Returns: A new ECDiffieHellman certificate with the  property set to .
            The current certificate isn't modified.

    */
    open func CopyWithPrivateKey(privateKey : dotnet.System.Security.Cryptography.ECDiffieHellman) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_X509Certificate2__CopyWithPrivateKey_0__1__ECDiffieHellman(&__thrown, self.get_handle(), privateKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.X509Certificate2 CreateFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.X509Certificate2 CreateFromEncryptedPemFile(System.String, System.ReadOnlySpan<System.Char>, System.String)
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.X509Certificate2 CreateFromPem(System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.X509Certificate2 CreateFromPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
    // System.Security.Cryptography.X509Certificates.X509Certificate2 CreateFromPemFile(System.String, System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.CreateFromPemFile(System.String,System.String)
    /**
    Creates a new X509 certificate from the file contents of an RFC 7468 PEM-encoded certificate and private key.

    - Parameter certPemFilePath: The path for the PEM-encoded X509 certificate.
    - Parameter keyPemFilePath: If specified, the path for the PEM-encoded private key.
            If unspecified, the  file will be used to load the private key.
    - Returns: A new certificate with the private key.

    */
    open class func CreateFromPemFile(certPemFilePath : dotnet.System.String, keyPemFilePath : Optional<dotnet.System.String> = nil) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_X509Certificate2__CreateFromPemFile_0__2__String_String(&__thrown, certPemFilePath.get_handle(), keyPemFilePath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.Byte[])
    /**
    Indicates the type of certificate contained in a byte array.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    - Returns: An  object.

    */
    open class func GetCertContentType(rawData : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_X509ContentType__GetCertContentType_0__1__u8Array(&__thrown, rawData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(System.ReadOnlySpan<System.Byte>)
    // System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.String)
    /**
    Indicates the type of certificate contained in a file.

    - Parameter fileName: The name of a certificate file.
    - Returns: An  object.

    */
    open class func GetCertContentType(fileName : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_X509ContentType__GetCertContentType_0__1__String(&__thrown, fileName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: __return);
        }
    }
    // System.Security.Cryptography.ECDiffieHellman GetECDiffieHellmanPrivateKey()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetECDiffieHellmanPrivateKey
    /**
    Gets the  private key from this certificate.

    - Returns: The private key, or  if this certificate does not have an ECDiffieHellman private key.

    */
    open func GetECDiffieHellmanPrivateKey() throws -> Optional<dotnet.System.Security.Cryptography.ECDiffieHellman> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_ECDiffieHellman__GetECDiffieHellmanPrivateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDiffieHellman(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.ECDiffieHellman GetECDiffieHellmanPublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetECDiffieHellmanPublicKey
    /**
    Gets the  public key from this certificate.

    - Returns: The public key, or  if this certificate does not have an ECDiffieHellman public key.

    */
    open func GetECDiffieHellmanPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.ECDiffieHellman> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_ECDiffieHellman__GetECDiffieHellmanPublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDiffieHellman(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType,System.Boolean)
    /**
    Gets the subject and issuer names from a certificate.

    - Parameter nameType: The  value for the subject.
    - Parameter forIssuer: 
         to include the issuer name; otherwise, .
    - Returns: The name of the certificate.

    */
    open func GetNameInfo(nameType : dotnet.System.Security.Cryptography.X509Certificates.X509NameType, forIssuer : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_String__GetNameInfo_0__2__X509NameType_bool(&__thrown, self.get_handle(), nameType.get_value(), Swift.Int32(forIssuer ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // void Import(System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[])
    /**
    Populates an  object with data from a byte array.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    */
    open override func Import(rawData : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__Import_0__1__u8Array(&__thrown, self.get_handle(), rawData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.Byte[], System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates an  object using data from a byte array, a password, and a key storage flag.

    - Parameter rawData: A byte array that contains data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open override func Import(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__Import_0__3__u8Array_SecureString_X509KeyStorageFlags(&__thrown, self.get_handle(), rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.Byte[], System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates an  object using data from a byte array, a password, and flags for determining how to import the private key.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open override func Import(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__Import_0__3__u8Array_String_X509KeyStorageFlags(&__thrown, self.get_handle(), rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String)
    /**
    Populates an  object with information from a certificate file.

    - Parameter fileName: The name of a certificate.
    */
    open override func Import(fileName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__Import_0__1__String(&__thrown, self.get_handle(), fileName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.String, System.Security.SecureString, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates an  object with information from a certificate file, a password, and a key storage flag.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open override func Import(fileName : dotnet.System.String, password : Optional<dotnet.System.Security.SecureString>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__Import_0__3__String_SecureString_X509KeyStorageFlags(&__thrown, self.get_handle(), fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.String, System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Populates an  object with information from a certificate file, a password, and a  value.

    - Parameter fileName: The name of a certificate file.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control where and how to import the certificate.
    */
    open override func Import(fileName : dotnet.System.String, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__Import_0__3__String_String_X509KeyStorageFlags(&__thrown, self.get_handle(), fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Reset
    /**
    Resets the state of an  object.

    */
    open override func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString
    /**
    Displays an X.509 certificate in text format.

    - Returns: The certificate information.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String ToString(bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString(System.Boolean)
    /**
    Displays an X.509 certificate in text format.

    - Parameter verbose: 
         to display the public key, private key, extensions, and so forth;  to display information that is similar to the  class, including thumbprint, serial number, subject and issuer names, and so on.
    - Returns: The certificate information.

    */
    open func ToString(verbose : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_String__ToString_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(verbose ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // bool Verify()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.Verify
    /**
    Performs a X.509 chain validation using basic validation policy.

    - Returns: 
         if the validation succeeds;  if the validation fails.

    */
    open func Verify() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_bool__Verify_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_Archived()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_Archived
    open func get_Archived() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_bool__get_Archived_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Archived(bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.set_Archived(System.Boolean)
    open func set_Archived(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__set_Archived_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ExtensionCollection get_Extensions()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_Extensions
    open func get_Extensions() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ExtensionCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_X509ExtensionCollection__get_Extensions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ExtensionCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_FriendlyName()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_FriendlyName
    open func get_FriendlyName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_String__get_FriendlyName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_FriendlyName(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.set_FriendlyName(System.String)
    open func set_FriendlyName(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__set_FriendlyName_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_HasPrivateKey()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_HasPrivateKey
    open func get_HasPrivateKey() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_bool__get_HasPrivateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X500DistinguishedName get_IssuerName()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_IssuerName
    open func get_IssuerName() throws -> dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_X500DistinguishedName__get_IssuerName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName(hndl : __return);
        }
    }
    // [IsSpecialName] System.DateTime get_NotAfter()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_NotAfter
    open func get_NotAfter() throws -> dotnet.System.DateTime {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_DateTime__get_NotAfter_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTime(hndl : __return);
        }
    }
    // [IsSpecialName] System.DateTime get_NotBefore()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_NotBefore
    open func get_NotBefore() throws -> dotnet.System.DateTime {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_DateTime__get_NotBefore_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTime(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.AsymmetricAlgorithm get_PrivateKey()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_PrivateKey
    open func get_PrivateKey() throws -> Optional<dotnet.System.Security.Cryptography.AsymmetricAlgorithm> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_AsymmetricAlgorithm__get_PrivateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.AsymmetricAlgorithm(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_PrivateKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.set_PrivateKey(System.Security.Cryptography.AsymmetricAlgorithm)
    open func set_PrivateKey(value : Optional<dotnet.System.Security.Cryptography.AsymmetricAlgorithm>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2_void__set_PrivateKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.PublicKey get_PublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_PublicKey
    open func get_PublicKey() throws -> dotnet.System.Security.Cryptography.X509Certificates.PublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_PublicKey__get_PublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.PublicKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.Byte[] get_RawData()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_RawData
    open func get_RawData() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_u8Array__get_RawData_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_SerialNumber()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_SerialNumber
    open func get_SerialNumber() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_String__get_SerialNumber_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.Oid get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_SignatureAlgorithm
    open func get_SignatureAlgorithm() throws -> dotnet.System.Security.Cryptography.Oid {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_Oid__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.Oid(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X500DistinguishedName get_SubjectName()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_SubjectName
    open func get_SubjectName() throws -> dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_X500DistinguishedName__get_SubjectName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Thumbprint()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_Thumbprint
    open func get_Thumbprint() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_String__get_Thumbprint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Version()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2.get_Version
    open func get_Version() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2_i32__get_Version_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets or sets a value indicating that an X.509 certificate is archived.

    */
    open var Archived : Bool {
        get {
            return try! get_Archived();
        }
        set(v) {
            return try! set_Archived(value: v);
        }
    }
    /**
    Gets a collection of  objects.

    */
    open var Extensions : dotnet.System.Security.Cryptography.X509Certificates.X509ExtensionCollection {
        get {
            return try! get_Extensions();
        }
    }
    /**
    Gets or sets the associated alias for a certificate.

    */
    open var FriendlyName : dotnet.System.String {
        get {
            return try! get_FriendlyName();
        }
        set(v) {
            return try! set_FriendlyName(value: v);
        }
    }
    /**
    Gets a value that indicates whether an  object contains a private key.

    */
    open var HasPrivateKey : Bool {
        get {
            return try! get_HasPrivateKey();
        }
    }
    /**
    Gets the distinguished name of the certificate issuer.

    */
    open var IssuerName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName {
        get {
            return try! get_IssuerName();
        }
    }
    /**
    Gets the date in local time after which a certificate is no longer valid.

    */
    open var NotAfter : dotnet.System.DateTime {
        get {
            return try! get_NotAfter();
        }
    }
    /**
    Gets the date in local time on which a certificate becomes valid.

    */
    open var NotBefore : dotnet.System.DateTime {
        get {
            return try! get_NotBefore();
        }
    }
    /**
    Gets or sets the  object that represents the private key associated with a certificate.

    */
    open var PrivateKey : Optional<dotnet.System.Security.Cryptography.AsymmetricAlgorithm> {
        get {
            return try! get_PrivateKey();
        }
        set(v) {
            return try! set_PrivateKey(value: v!);
        }
    }
    /**
    Gets a  object associated with a certificate.

    */
    open var PublicKey : dotnet.System.Security.Cryptography.X509Certificates.PublicKey {
        get {
            return try! get_PublicKey();
        }
    }
    /**
    Gets the raw data of a certificate.

    */
    open var RawData : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_RawData();
        }
    }
    /**
    Gets the serial number of a certificate as a big-endian hexadecimal string.

    */
    open var SerialNumber : dotnet.System.String {
        get {
            return try! get_SerialNumber();
        }
    }
    /**
    Gets the algorithm used to create the signature of a certificate.

    */
    open var SignatureAlgorithm : dotnet.System.Security.Cryptography.Oid {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
    /**
    Gets the subject distinguished name from a certificate.

    */
    open var SubjectName : dotnet.System.Security.Cryptography.X509Certificates.X500DistinguishedName {
        get {
            return try! get_SubjectName();
        }
    }
    /**
    Gets the thumbprint of a certificate.

    */
    open var Thumbprint : dotnet.System.String {
        get {
            return try! get_Thumbprint();
        }
    }
    /**
    Gets the X.509 format version of a certificate.

    */
    open var Version : Swift.Int32 {
        get {
            return try! get_Version();
        }
    }
} // X509Certificate2


// type: System.Security.Cryptography.X509Certificates.X509Certificate2Collection
    /**
    Represents a collection of  objects. This class cannot be inherited.

    */
open class X509Certificate2Collection
    :
    dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509Certificate2Collection_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor
    /**
    Initializes a new instance of the  class without any  information.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Initializes a new instance of the  class using an  object.

    - Parameter certificate: An  object to start the collection from.
    */
    public init(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_ctor_0__1__X509Certificate2(&__thrown, certificate.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
    /**
    Initializes a new instance of the  class using the specified certificate collection.

    - Parameter certificates: An  object.
    */
    public init(certificates : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_ctor_0__1__X509Certificate2Collection(&__thrown, certificates.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509Certificate2[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2[])
    /**
    Initializes a new instance of the  class using an array of  objects.

    - Parameter certificates: An array of  objects.
    */
    public init(certificates : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_ctor_0__1__X509Certificate2Array(&__thrown, certificates.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Int32 Add(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Add(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Adds an object to the end of the .

    - Parameter certificate: An X.509 certificate represented as an  object.
    - Returns: The  index at which the  has been added.

    */
    open func Add(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_i32__Add_0__1__X509Certificate2(&__thrown, self.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
    /**
    Adds multiple  objects in an  object to another  object.

    - Parameter certificates: An  object.
    */
    open func AddRange(certificates : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__AddRange_0__1__X509Certificate2Collection(&__thrown, self.get_handle(), certificates.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2[])
    /**
    Adds multiple  objects in an array to the  object.

    - Parameter certificates: An array of  objects.
    */
    open func AddRange(certificates : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__AddRange_0__1__X509Certificate2Array(&__thrown, self.get_handle(), certificates.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Contains(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Contains(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Determines whether the  object contains a specific certificate.

    - Parameter certificate: The  object to locate in the collection.
    - Returns: 
         if the  contains the specified ; otherwise, .

    */
    open func Contains(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_bool__Contains_0__1__X509Certificate2(&__thrown, self.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Export(System.Security.Cryptography.X509Certificates.X509ContentType)
    /**
    Exports X.509 certificate information into a byte array.

    - Parameter contentType: A supported  object.
    - Returns: X.509 certificate information in a byte array.

    */
    open func Export(contentType : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType) throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_u8Array__Export_0__1__X509ContentType(&__thrown, self.get_handle(), contentType.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType, System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.String)
    /**
    Exports X.509 certificate information into a byte array using a password.

    - Parameter contentType: A supported  object.
    - Parameter password: A string used to protect the byte array.
    - Returns: X.509 certificate information in a byte array.

    */
    open func Export(contentType : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_u8Array__Export_0__2__X509ContentType_String(&__thrown, self.get_handle(), contentType.get_value(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate2Collection Find(System.Security.Cryptography.X509Certificates.X509FindType, System.Object, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Find(System.Security.Cryptography.X509Certificates.X509FindType,System.Object,System.Boolean)
    /**
    Searches an  object using the search criteria specified by the  enumeration and the  object.

    - Parameter findType: One of the  values.
    - Parameter findValue: The search criteria as an object.
    - Parameter validOnly: 
         to allow only valid certificates to be returned from the search; otherwise, .
    - Returns: An  object.

    */
    open func Find(findType : dotnet.System.Security.Cryptography.X509Certificates.X509FindType, findValue : dotnet.System.Object, validOnly : Bool) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_X509Certificate2Collection__Find_0__3__X509FindType_Object_bool(&__thrown, self.get_handle(), findType.get_value(), findValue.get_handle(), Swift.Int32(validOnly ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection(hndl : __return);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator GetEnumerator()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.GetEnumerator
    /**
    Returns an enumerator that can iterate through a  object.

    - Returns: An  object that can iterate through the  object.

    */
    open func GetEnumerator() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_X509Certificate2Enumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator(hndl : __return);
        }
    }
    // void Import(System.Byte[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.Byte[])
    /**
    Imports a certificate in the form of a byte array into a  object.

    - Parameter rawData: A byte array containing data from an X.509 certificate.
    */
    open func Import(rawData : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__Import_0__1__u8Array(&__thrown, self.get_handle(), rawData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Import(System.Byte[], System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Imports a certificate, in the form of a byte array that requires a password to access the certificate, into a  object.

    - Parameter rawData: A byte array containing data from an  object.
    - Parameter password: The password required to access the certificate information.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control how and where the certificate is imported.
    */
    open func Import(rawData : dotnet.System_Arr<Swift.UInt8>, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags/* TODO default enum */) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__Import_0__3__u8Array_String_X509KeyStorageFlags(&__thrown, self.get_handle(), rawData.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Import(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void Import(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Char>, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// TODO COPE (write_all_methods) (span) void Import(System.ReadOnlySpan<System.Byte>, System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    // void Import(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.String)
    /**
    Imports a certificate file into a  object.

    - Parameter fileName: The name of the file containing the certificate information.
    */
    open func Import(fileName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__Import_0__1__String(&__thrown, self.get_handle(), fileName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Import(System.String, System.ReadOnlySpan<System.Char>, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    // void Import(System.String, System.String, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)
    /**
    Imports a certificate file that requires a password into a  object.

    - Parameter fileName: The name of the file containing the certificate information.
    - Parameter password: The password required to access the certificate information.
    - Parameter keyStorageFlags: A bitwise combination of the enumeration values that control how and where the certificate is imported.
    */
    open func Import(fileName : dotnet.System.String, password : Optional<dotnet.System.String>, keyStorageFlags : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags/* TODO default enum */) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__Import_0__3__String_String_X509KeyStorageFlags(&__thrown, self.get_handle(), fileName.get_handle(), password?.get_handle() ?? nil, keyStorageFlags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportFromPem(System.ReadOnlySpan<System.Char>)
    // void ImportFromPemFile(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.ImportFromPemFile(System.String)
    /**
    Imports a collection of RFC 7468 PEM-encoded certificates.

    - Parameter certPemFilePath: The path for the PEM-encoded X509 certificate collection.
    */
    open func ImportFromPemFile(certPemFilePath : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__ImportFromPemFile_0__1__String(&__thrown, self.get_handle(), certPemFilePath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Insert(System.Int32, System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Insert(System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Inserts an object into the  object at the specified index.

    - Parameter index: The zero-based index at which to insert .
    - Parameter certificate: The  object to insert.
    */
    open func Insert(index : Swift.Int32, certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__Insert_0__2__i32_X509Certificate2(&__thrown, self.get_handle(), index, certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Remove(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Remove(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Removes the first occurrence of a certificate from the  object.

    - Parameter certificate: The  object to be removed from the  object.
    */
    open func Remove(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__Remove_0__1__X509Certificate2(&__thrown, self.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
    /**
    Removes multiple  objects in an  object from another  object.

    - Parameter certificates: An  object.
    */
    open func RemoveRange(certificates : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__RemoveRange_0__1__X509Certificate2Collection(&__thrown, self.get_handle(), certificates.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2[])
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2[])
    /**
    Removes multiple  objects in an array from an  object.

    - Parameter certificates: An array of  objects.
    */
    open func RemoveRange(certificates : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__RemoveRange_0__1__X509Certificate2Array(&__thrown, self.get_handle(), certificates.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate2 get_Item(System.Int32)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.get_Item(System.Int32)
    open override func get_Item(index : Swift.Int32) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Collection_X509Certificate2__get_Item_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Item(System.Int32, System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.set_Item(System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate2)
    open func set_Item(index : Swift.Int32, value : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Collection_void__set_Item_0__2__i32_X509Certificate2(&__thrown, self.get_handle(), index, value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // X509Certificate2Collection


// type: System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator
    /**
    Supports a simple iteration over a  object. This class cannot be inherited.

    */
public final class X509Certificate2Enumerator
    :
    dotnet.System.Object,
    System_Collections_IEnumerator,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509Certificate2Enumerator_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509Certificate2Enumerator_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // bool MoveNext()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator.MoveNext
    /**
    Advances the enumerator to the next element in the  object.

    - Returns: 
         if the enumerator was successfully advanced to the next element;  if the enumerator has passed the end of the collection.

    */
    public func MoveNext() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Enumerator_bool__MoveNext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator.Reset
    /**
    Sets the enumerator to its initial position, which is before the first element in the  object.

    */
    public func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Certificate2Enumerator_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate2 get_Current()
// docid: M:System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator.get_Current
    public func get_Current() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Certificate2Enumerator_X509Certificate2__get_Current_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    /**
    Gets the current element in the  object.

    */
    public var Current : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        get {
            return try! get_Current();
        }
    }
} // X509Certificate2Enumerator


// type: System.Security.Cryptography.X509Certificates.X509CertificateCollection
    /**
    Defines a collection that stores  objects.

    */
open class X509CertificateCollection
    :
    dotnet.System.Collections.CollectionBase
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509CertificateCollection_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509CertificateCollection_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509CertificateCollection_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.#ctor(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
    /**
    Initializes a new instance of the  class from another .

    - Parameter value: The  with which to initialize the new object.
    */
    public init(value : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509CertificateCollection_ctor_0__1__X509CertificateCollection(&__thrown, value.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509Certificate[])
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate[])
    /**
    Initializes a new instance of the  class from an array of  objects.

    - Parameter value: The array of  objects with which to initialize the new object.
    */
    public init(value : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509CertificateCollection_ctor_0__1__X509CertificateArray(&__thrown, value.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Int32 Add(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.Add(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Adds an  with the specified value to the current .

    - Parameter value: The  to add to the current .
    - Returns: The index into the current  at which the new  was inserted.

    */
    open func Add(value : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_i32__Add_0__1__X509Certificate(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void AddRange(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.AddRange(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
    /**
    Copies the elements of the specified  to the end of the current .

    - Parameter value: The  containing the objects to add to the collection.
    */
    open func AddRange(value : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509CertificateCollection_void__AddRange_0__1__X509CertificateCollection(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddRange(System.Security.Cryptography.X509Certificates.X509Certificate[])
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.AddRange(System.Security.Cryptography.X509Certificates.X509Certificate[])
    /**
    Copies the elements of an array of type  to the end of the current .

    - Parameter value: The array of type  containing the objects to add to the current .
    */
    open func AddRange(value : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509CertificateCollection_void__AddRange_0__1__X509CertificateArray(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Contains(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.Contains(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Gets a value indicating whether the current  contains the specified .

    - Parameter value: The  to locate.
    - Returns: 
         if the  is contained in this collection; otherwise, .

    */
    open func Contains(value : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_bool__Contains_0__1__X509Certificate(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void CopyTo(System.Security.Cryptography.X509Certificates.X509Certificate[], System.Int32)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.CopyTo(System.Security.Cryptography.X509Certificates.X509Certificate[],System.Int32)
    /**
    Copies the  values in the current  to a one-dimensional  instance at the specified index.

    - Parameter array: The one-dimensional  that is the destination of the values copied from .
    - Parameter index: The index into  to begin copying.
    */
    open func CopyTo(array : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, index : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509CertificateCollection_void__CopyTo_0__2__X509CertificateArray_i32(&__thrown, self.get_handle(), array.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Security.Cryptography.X509Certificates.X509CertificateCollection.X509CertificateEnumerator GetEnumerator()
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.GetEnumerator
    /**
    Returns an enumerator that can iterate through the .

    - Returns: An enumerator of the subelements of  you can use to iterate through the collection.

    */
    open func GetEnumerator() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection_X509CertificateEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509CertificateCollection_X509CertificateEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection_X509CertificateEnumerator(hndl : __return);
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.GetHashCode
    /**
    Builds a hash value based on all values contained in the current .

    - Returns: A hash value based on all values contained in the current .

    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 IndexOf(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.IndexOf(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Returns the index of the specified  in the current .

    - Parameter value: The  to locate.
    - Returns: The index of the  specified by the  parameter in the , if found; otherwise, -1.

    */
    open func IndexOf(value : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_i32__IndexOf_0__1__X509Certificate(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void Insert(System.Int32, System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.Insert(System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Inserts a  into the current  at the specified index.

    - Parameter index: The zero-based index where  should be inserted.
    - Parameter value: The  to insert.
    */
    open func Insert(index : Swift.Int32, value : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509CertificateCollection_void__Insert_0__2__i32_X509Certificate(&__thrown, self.get_handle(), index, value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Remove(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.Remove(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Removes a specific  from the current .

    - Parameter value: The  to remove from the current .
    */
    open func Remove(value : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509CertificateCollection_void__Remove_0__1__X509Certificate(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate get_Item(System.Int32)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.get_Item(System.Int32)
    open func get_Item(index : Swift.Int32) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509Certificate__get_Item_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Item(System.Int32, System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.set_Item(System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate)
    open func set_Item(index : Swift.Int32, value : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509CertificateCollection_void__set_Item_0__2__i32_X509Certificate(&__thrown, self.get_handle(), index, value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // X509CertificateCollection


// type: System.Security.Cryptography.X509Certificates.X509CertificateCollection+X509CertificateEnumerator
    /**
    Enumerates the  objects in an .

    */
open class X509CertificateCollection_X509CertificateEnumerator
    :
    dotnet.System.Object,
    System_Collections_IEnumerator
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509CertificateEnumerator_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509CertificateEnumerator_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.X509CertificateEnumerator.#ctor(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
    /**
    Initializes a new instance of the  class for the specified .

    - Parameter mappings: The  to enumerate.
    */
    public init(mappings : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509CertificateEnumerator_ctor_0__1__X509CertificateCollection(&__thrown, mappings.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool MoveNext()
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.X509CertificateEnumerator.MoveNext
    /**
    Advances the enumerator to the next element of the collection.

    - Returns: 
         if the enumerator was successfully advanced to the next element;  if the enumerator has passed the end of the collection.

    */
    open func MoveNext() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509CertificateEnumerator_bool__MoveNext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.X509CertificateEnumerator.Reset
    /**
    Sets the enumerator to its initial position, which is before the first element in the collection.

    */
    open func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509CertificateEnumerator_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate get_Current()
// docid: M:System.Security.Cryptography.X509Certificates.X509CertificateCollection.X509CertificateEnumerator.get_Current
    open func get_Current() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509CertificateCollection_X509CertificateEnumerator_X509Certificate__get_Current_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    /**
    Gets the current  in the .

    */
    open var Current : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        get {
            return try! get_Current();
        }
    }
} // X509CertificateCollection_X509CertificateEnumerator


// type: System.Security.Cryptography.X509Certificates.X509Chain
    /**
    Represents a chain-building engine for  certificates.

    */
open class X509Chain
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509Chain_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509Chain_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Chain_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class specifying a value that indicates whether the machine context should be used.

    - Parameter useMachineContext: 
         to use the machine context;  to use the current user context.
    */
    public init(useMachineContext : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Chain_ctor_0__1__bool(&__thrown, Swift.Int32(useMachineContext ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class using an  handle to an X.509 chain.

    - Parameter chainContext: An  handle to an X.509 chain.
    */
    public init(chainContext : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Chain_ctor_0__1__IntPtr(&__thrown, chainContext.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Build(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.Build(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Builds an X.509 chain using the policy specified in .

    - Parameter certificate: An  object.
    - Returns: 
         if the X.509 certificate is valid; otherwise, .

    */
    open func Build(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Chain_bool__Build_0__1__X509Certificate2(&__thrown, self.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Chain Create()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.Create
    /**
    Creates an  object after querying for the mapping defined in the CryptoConfig file, and maps the chain to that mapping.

    - Returns: An  object.

    */
    open class func Create() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Chain {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Chain_X509Chain__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Chain(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.Dispose
    /**
    Releases all of the resources used by this .

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Chain_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.Reset
    /**
    Clears the current  object.

    */
    open func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Chain_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IntPtr get_ChainContext()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.get_ChainContext
    open func get_ChainContext() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Chain_IntPtr__get_ChainContext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainElementCollection get_ChainElements()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.get_ChainElements
    open func get_ChainElements() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ChainElementCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Chain_X509ChainElementCollection__get_ChainElements_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ChainElementCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainPolicy get_ChainPolicy()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.get_ChainPolicy
    open func get_ChainPolicy() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ChainPolicy {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Chain_X509ChainPolicy__get_ChainPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ChainPolicy(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ChainPolicy(System.Security.Cryptography.X509Certificates.X509ChainPolicy)
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.set_ChainPolicy(System.Security.Cryptography.X509Certificates.X509ChainPolicy)
    open func set_ChainPolicy(value : dotnet.System.Security.Cryptography.X509Certificates.X509ChainPolicy) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Chain_void__set_ChainPolicy_0__1__X509ChainPolicy(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainStatus[] get_ChainStatus()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.get_ChainStatus
    open func get_ChainStatus() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatus> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Chain_X509ChainStatusArray__get_ChainStatus_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatus>(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafeX509ChainHandle get_SafeHandle()
// docid: M:System.Security.Cryptography.X509Certificates.X509Chain.get_SafeHandle
    open func get_SafeHandle() throws -> Optional<dotnet.Microsoft.Win32.SafeHandles.SafeX509ChainHandle> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Chain_SafeX509ChainHandle__get_SafeHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.Microsoft.Win32.SafeHandles.SafeX509ChainHandle(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets a handle to an X.509 chain.

    */
    open var ChainContext : dotnet.System.IntPtr {
        get {
            return try! get_ChainContext();
        }
    }
    /**
    Gets a collection of  objects.

    */
    open var ChainElements : dotnet.System.Security.Cryptography.X509Certificates.X509ChainElementCollection {
        get {
            return try! get_ChainElements();
        }
    }
    /**
    Gets or sets the  to use when building an X.509 certificate chain.

    */
    open var ChainPolicy : dotnet.System.Security.Cryptography.X509Certificates.X509ChainPolicy {
        get {
            return try! get_ChainPolicy();
        }
        set(v) {
            return try! set_ChainPolicy(value: v);
        }
    }
    /**
    Gets the status of each element in an  object.

    */
    open var ChainStatus : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatus> {
        get {
            return try! get_ChainStatus();
        }
    }
    /**
    Gets a safe handle for this  instance.

    */
    open var SafeHandle : Optional<dotnet.Microsoft.Win32.SafeHandles.SafeX509ChainHandle> {
        get {
            return try! get_SafeHandle();
        }
    }
} // X509Chain


// type: System.Security.Cryptography.X509Certificates.X509ChainElement
    /**
    Represents an element of an X.509 chain.

    */
open class X509ChainElement
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ChainElement_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509ChainElement_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate2 get_Certificate()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElement.get_Certificate
    open func get_Certificate() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElement_X509Certificate2__get_Certificate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainStatus[] get_ChainElementStatus()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElement.get_ChainElementStatus
    open func get_ChainElementStatus() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatus> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElement_X509ChainStatusArray__get_ChainElementStatus_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatus>(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Information()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElement.get_Information
    open func get_Information() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElement_String__get_Information_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the X.509 certificate at a particular chain element.

    */
    open var Certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        get {
            return try! get_Certificate();
        }
    }
    /**
    Gets the error status of the current X.509 certificate in a chain.

    */
    open var ChainElementStatus : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatus> {
        get {
            return try! get_ChainElementStatus();
        }
    }
    /**
    Gets additional error information from an unmanaged certificate chain structure.

    */
    open var Information : dotnet.System.String {
        get {
            return try! get_Information();
        }
    }
} // X509ChainElement


// type: System.Security.Cryptography.X509Certificates.X509ChainElementCollection
    /**
    Represents a collection of  objects. This class cannot be inherited.

    */
public final class X509ChainElementCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable,
    System_Collections_ICollection
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ChainElementCollection_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509ChainElementCollection_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // void CopyTo(System.Security.Cryptography.X509Certificates.X509ChainElement[], System.Int32)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementCollection.CopyTo(System.Security.Cryptography.X509Certificates.X509ChainElement[],System.Int32)
    /**
    Copies an  object into an array, starting at the specified index.

    - Parameter array: An array of  objects.
    - Parameter index: An integer representing the index value.
    */
    public func CopyTo(array : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509ChainElement>, index : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainElementCollection_void__CopyTo_0__2__X509ChainElementArray_i32(&__thrown, self.get_handle(), array.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator GetEnumerator()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementCollection.GetEnumerator
    /**
    Gets an  object that can be used to navigate through a collection of chain elements.

    - Returns: An  object.

    */
    public func GetEnumerator() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElementCollection_X509ChainElementEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementCollection.get_Count
    public func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElementCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsSynchronized()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementCollection.get_IsSynchronized
    public func get_IsSynchronized() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElementCollection_bool__get_IsSynchronized_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Object get_SyncRoot()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementCollection.get_SyncRoot
    public func get_SyncRoot() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElementCollection_Object__get_SyncRoot_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainElement get_Item(System.Int32)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementCollection.get_Item(System.Int32)
    public func get_Item(index : Swift.Int32) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ChainElement {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElementCollection_X509ChainElement__get_Item_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ChainElement(hndl : __return);
        }
    }
    /**
    Gets the number of elements in the collection.

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a value indicating whether the collection of chain elements is synchronized.

    */
    public var IsSynchronized : Bool {
        get {
            return try! get_IsSynchronized();
        }
    }
    /**
    Gets an object that can be used to synchronize access to an  object.

    */
    public var SyncRoot : dotnet.System.Object {
        get {
            return try! get_SyncRoot();
        }
    }
} // X509ChainElementCollection


// type: System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator
    /**
    Supports a simple iteration over an . This class cannot be inherited.

    */
public final class X509ChainElementEnumerator
    :
    dotnet.System.Object,
    System_Collections_IEnumerator,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ChainElementEnumerator_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509ChainElementEnumerator_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // bool MoveNext()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator.MoveNext
    /**
    Advances the enumerator to the next element in the .

    - Returns: 
         if the enumerator was successfully advanced to the next element;  if the enumerator has passed the end of the collection.

    */
    public func MoveNext() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElementEnumerator_bool__MoveNext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator.Reset
    /**
    Sets the enumerator to its initial position, which is before the first element in the .

    */
    public func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainElementEnumerator_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainElement get_Current()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator.get_Current
    public func get_Current() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ChainElement {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainElementEnumerator_X509ChainElement__get_Current_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ChainElement(hndl : __return);
        }
    }
    /**
    Gets the current element in the .

    */
    public var Current : dotnet.System.Security.Cryptography.X509Certificates.X509ChainElement {
        get {
            return try! get_Current();
        }
    }
} // X509ChainElementEnumerator


// type: System.Security.Cryptography.X509Certificates.X509ChainPolicy
    /**
    Represents the chain policy to be applied when building an X509 certificate chain. This class cannot be inherited.

    */
public final class X509ChainPolicy
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ChainPolicy_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509ChainPolicy_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509ChainPolicy_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.Reset
    /**
    Resets the  members to their default values.

    */
    public func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.OidCollection get_ApplicationPolicy()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_ApplicationPolicy
    public func get_ApplicationPolicy() throws -> dotnet.System.Security.Cryptography.OidCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_OidCollection__get_ApplicationPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.OidCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.OidCollection get_CertificatePolicy()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_CertificatePolicy
    public func get_CertificatePolicy() throws -> dotnet.System.Security.Cryptography.OidCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_OidCollection__get_CertificatePolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.OidCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate2Collection get_CustomTrustStore()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_CustomTrustStore
    public func get_CustomTrustStore() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_X509Certificate2Collection__get_CustomTrustStore_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_DisableCertificateDownloads()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_DisableCertificateDownloads
    public func get_DisableCertificateDownloads() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_bool__get_DisableCertificateDownloads_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DisableCertificateDownloads(bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.set_DisableCertificateDownloads(System.Boolean)
    public func set_DisableCertificateDownloads(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__set_DisableCertificateDownloads_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate2Collection get_ExtraStore()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_ExtraStore
    public func get_ExtraStore() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_X509Certificate2Collection__get_ExtraStore_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509RevocationFlag get_RevocationFlag()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_RevocationFlag
    public func get_RevocationFlag() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_X509RevocationFlag__get_RevocationFlag_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag(val: __return);
        }
    }
    // [IsSpecialName] void set_RevocationFlag(System.Security.Cryptography.X509Certificates.X509RevocationFlag)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.set_RevocationFlag(System.Security.Cryptography.X509Certificates.X509RevocationFlag)
    public func set_RevocationFlag(value : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__set_RevocationFlag_0__1__X509RevocationFlag(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509RevocationMode get_RevocationMode()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_RevocationMode
    public func get_RevocationMode() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_X509RevocationMode__get_RevocationMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode(val: __return);
        }
    }
    // [IsSpecialName] void set_RevocationMode(System.Security.Cryptography.X509Certificates.X509RevocationMode)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.set_RevocationMode(System.Security.Cryptography.X509Certificates.X509RevocationMode)
    public func set_RevocationMode(value : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__set_RevocationMode_0__1__X509RevocationMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainTrustMode get_TrustMode()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_TrustMode
    public func get_TrustMode() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_X509ChainTrustMode__get_TrustMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode(val: __return);
        }
    }
    // [IsSpecialName] void set_TrustMode(System.Security.Cryptography.X509Certificates.X509ChainTrustMode)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.set_TrustMode(System.Security.Cryptography.X509Certificates.X509ChainTrustMode)
    public func set_TrustMode(value : dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__set_TrustMode_0__1__X509ChainTrustMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_UrlRetrievalTimeout()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_UrlRetrievalTimeout
    public func get_UrlRetrievalTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_TimeSpan__get_UrlRetrievalTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_UrlRetrievalTimeout(System.TimeSpan)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.set_UrlRetrievalTimeout(System.TimeSpan)
    public func set_UrlRetrievalTimeout(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__set_UrlRetrievalTimeout_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509VerificationFlags get_VerificationFlags()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_VerificationFlags
    public func get_VerificationFlags() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_X509VerificationFlags__get_VerificationFlags_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: __return);
        }
    }
    // [IsSpecialName] void set_VerificationFlags(System.Security.Cryptography.X509Certificates.X509VerificationFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.set_VerificationFlags(System.Security.Cryptography.X509Certificates.X509VerificationFlags)
    public func set_VerificationFlags(value : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__set_VerificationFlags_0__1__X509VerificationFlags(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.DateTime get_VerificationTime()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.get_VerificationTime
    public func get_VerificationTime() throws -> dotnet.System.DateTime {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainPolicy_DateTime__get_VerificationTime_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTime(hndl : __return);
        }
    }
    // [IsSpecialName] void set_VerificationTime(System.DateTime)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainPolicy.set_VerificationTime(System.DateTime)
    public func set_VerificationTime(value : dotnet.System.DateTime) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainPolicy_void__set_VerificationTime_0__1__DateTime(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a collection of object identifiers (OIDs) specifying which application policies or enhanced key usages (EKUs) the certificate must support.

    */
    public var ApplicationPolicy : dotnet.System.Security.Cryptography.OidCollection {
        get {
            return try! get_ApplicationPolicy();
        }
    }
    /**
    Gets a collection of object identifiers (OIDs) specifying which certificate policies the certificate must support.

    */
    public var CertificatePolicy : dotnet.System.Security.Cryptography.OidCollection {
        get {
            return try! get_CertificatePolicy();
        }
    }
    /**
    Represents a collection of certificates replacing the default certificate trust.

    */
    public var CustomTrustStore : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection {
        get {
            return try! get_CustomTrustStore();
        }
    }
    /**
    Gets or sets a value that indicates whether the chain engine can use the Authority Information Access (AIA) extension to locate unknown issuer certificates.

    */
    public var DisableCertificateDownloads : Bool {
        get {
            return try! get_DisableCertificateDownloads();
        }
        set(v) {
            return try! set_DisableCertificateDownloads(value: v);
        }
    }
    /**
    Gets an object that represents an additional collection of certificates that can be searched by the chaining engine when validating a certificate chain.

    */
    public var ExtraStore : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection {
        get {
            return try! get_ExtraStore();
        }
    }
    /**
    Gets or sets values for X509 revocation flags.

    */
    public var RevocationFlag : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag {
        get {
            return try! get_RevocationFlag();
        }
        set(v) {
            return try! set_RevocationFlag(value: v);
        }
    }
    /**
    Gets or sets values for X509 certificate revocation mode.

    */
    public var RevocationMode : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        get {
            return try! get_RevocationMode();
        }
        set(v) {
            return try! set_RevocationMode(value: v);
        }
    }
    /**
    The mode determining the root trust for building the certificate chain.

    */
    public var TrustMode : dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode {
        get {
            return try! get_TrustMode();
        }
        set(v) {
            return try! set_TrustMode(value: v);
        }
    }
    /**
    Gets or sets the maximum amount of time to be spent during online revocation verification or downloading the certificate revocation list (CRL). A value of  means there are no limits.

    */
    public var UrlRetrievalTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_UrlRetrievalTimeout();
        }
        set(v) {
            return try! set_UrlRetrievalTimeout(value: v);
        }
    }
    /**
    Gets verification flags for the certificate.

    */
    public var VerificationFlags : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
            return try! get_VerificationFlags();
        }
        set(v) {
            return try! set_VerificationFlags(value: v);
        }
    }
    /**
    Gets or sets the time for which the chain is to be validated.

    */
    public var VerificationTime : dotnet.System.DateTime {
        get {
            return try! get_VerificationTime();
        }
        set(v) {
            return try! set_VerificationTime(value: v);
        }
    }
} // X509ChainPolicy


// type: System.Security.Cryptography.X509Certificates.X509ChainStatus
// boxed value type
    /**
    Provides a simple structure for storing X509 chain status and error information.

    */
public final class X509ChainStatus
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ChainStatus_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Specifies the status of the X509 chain.

    */
    public var Status : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
            return try! get_Status();
        }
        set(v) {
            return try! set_Status(value: v);
        }
    }
    /**
    Specifies a description of the  value.

    */
    public var StatusInformation : dotnet.System.String {
        get {
            return try! get_StatusInformation();
        }
        set(v) {
            return try! set_StatusInformation(value: v);
        }
    }
    public override init() {
        let h = System_Security_Cryptography_X509Certificates_X509ChainStatus_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509ChainStatusFlags get_Status()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainStatus.get_Status
    public func get_Status() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainStatus_X509ChainStatusFlags__get_Status_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: __return);
        }
    }
    // [IsSpecialName] void set_Status(System.Security.Cryptography.X509Certificates.X509ChainStatusFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainStatus.set_Status(System.Security.Cryptography.X509Certificates.X509ChainStatusFlags)
    public func set_Status(value : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainStatus_void__set_Status_0__1__X509ChainStatusFlags(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_StatusInformation()
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainStatus.get_StatusInformation
    public func get_StatusInformation() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ChainStatus_String__get_StatusInformation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_StatusInformation(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509ChainStatus.set_StatusInformation(System.String)
    public func set_StatusInformation(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ChainStatus_void__set_StatusInformation_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // X509ChainStatus


// type: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags
    /**
    Defines the status of an X509 chain.

    */
public struct X509ChainStatusFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags NoError
    /**
    Specifies that the X509 chain has no errors.

    */
    public static var NoError : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_NoError());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags NotTimeValid
    /**
    Specifies that the X509 chain is not valid due to an invalid time value, such as a value that indicates an expired certificate.

    */
    public static var NotTimeValid : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_NotTimeValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags NotTimeNested
    /**
    Deprecated. Specifies that the CA (certificate authority) certificate and the issued certificate have validity periods that are not nested. For example, the CA cert can be valid from January 1 to December 1 and the issued certificate from January 2 to December 2, which would mean the validity periods are not nested.

    */
    public static var NotTimeNested : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_NotTimeNested());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags Revoked
    /**
    Specifies that the X509 chain is invalid due to a revoked certificate.

    */
    public static var Revoked : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_Revoked());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags NotSignatureValid
    /**
    Specifies that the X509 chain is invalid due to an invalid certificate signature.

    */
    public static var NotSignatureValid : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_NotSignatureValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags NotValidForUsage
    /**
    Specifies that the key usage is not valid.

    */
    public static var NotValidForUsage : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_NotValidForUsage());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags UntrustedRoot
    /**
    Specifies that the X509 chain is invalid due to an untrusted root certificate.

    */
    public static var UntrustedRoot : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_UntrustedRoot());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags RevocationStatusUnknown
    /**
    Specifies that it is not possible to determine whether the certificate has been revoked. This can be due to the certificate revocation list (CRL) being offline or unavailable.

    */
    public static var RevocationStatusUnknown : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_RevocationStatusUnknown());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags Cyclic
    /**
    Specifies that the X509 chain could not be built.

    */
    public static var Cyclic : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_Cyclic());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags InvalidExtension
    /**
    Specifies that the X509 chain is invalid due to an invalid extension.

    */
    public static var InvalidExtension : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_InvalidExtension());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags InvalidPolicyConstraints
    /**
    Specifies that the X509 chain is invalid due to invalid policy constraints.

    */
    public static var InvalidPolicyConstraints : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_InvalidPolicyConstraints());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags InvalidBasicConstraints
    /**
    Specifies that the X509 chain is invalid due to invalid basic constraints.

    */
    public static var InvalidBasicConstraints : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_InvalidBasicConstraints());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags InvalidNameConstraints
    /**
    Specifies that the X509 chain is invalid due to invalid name constraints.

    */
    public static var InvalidNameConstraints : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_InvalidNameConstraints());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags HasNotSupportedNameConstraint
    /**
    Specifies that the certificate does not have a supported name constraint or has a name constraint that is unsupported.

    */
    public static var HasNotSupportedNameConstraint : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_HasNotSupportedNameConstraint());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags HasNotDefinedNameConstraint
    /**
    Specifies that the certificate has an undefined name constraint.

    */
    public static var HasNotDefinedNameConstraint : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_HasNotDefinedNameConstraint());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags HasNotPermittedNameConstraint
    /**
    Specifies that the certificate has an impermissible name constraint.

    */
    public static var HasNotPermittedNameConstraint : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_HasNotPermittedNameConstraint());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags HasExcludedNameConstraint
    /**
    Specifies that the X509 chain is invalid because a certificate has excluded a name constraint.

    */
    public static var HasExcludedNameConstraint : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_HasExcludedNameConstraint());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags PartialChain
    /**
    Specifies that the X509 chain could not be built up to the root certificate.

    */
    public static var PartialChain : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_PartialChain());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags CtlNotTimeValid
    /**
    Specifies that the certificate trust list (CTL) is not valid because of an invalid time value, such as one that indicates that the CTL has expired.

    */
    public static var CtlNotTimeValid : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_CtlNotTimeValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags CtlNotSignatureValid
    /**
    Specifies that the certificate trust list (CTL) contains an invalid signature.

    */
    public static var CtlNotSignatureValid : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_CtlNotSignatureValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags CtlNotValidForUsage
    /**
    Specifies that the certificate trust list (CTL) is not valid for this use.

    */
    public static var CtlNotValidForUsage : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_CtlNotValidForUsage());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags HasWeakSignature
    /**
    Specifies that the certificate has not been strong signed. Typically, this indicates that the MD2 or MD5 hashing algorithms were used to create a hash of the certificate.

    */
    public static var HasWeakSignature : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_HasWeakSignature());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags OfflineRevocation
    /**
    Specifies that the online certificate revocation list (CRL) the X509 chain relies on is currently offline.

    */
    public static var OfflineRevocation : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_OfflineRevocation());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags NoIssuanceChainPolicy
    /**
    Specifies that there is no certificate policy extension in the certificate. This error would occur if a group policy has specified that all certificates must have a certificate policy.

    */
    public static var NoIssuanceChainPolicy : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_NoIssuanceChainPolicy());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags ExplicitDistrust
    /**
    Specifies that the certificate is explicitly distrusted.

    */
    public static var ExplicitDistrust : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_ExplicitDistrust());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainStatusFlags HasNotSupportedCriticalExtension
    /**
    Specifies that the certificate does not support a critical extension.

    */
    public static var HasNotSupportedCriticalExtension : dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainStatusFlags(val: System_Security_Cryptography_X509Certificates_X509ChainStatusFlags_get_HasNotSupportedCriticalExtension());
            return __return;
        }
    }
} // X509ChainStatusFlags


// type: System.Security.Cryptography.X509Certificates.X509ChainTrustMode
    /**
    The mode determining the root trust for building the certificate chain.

    */
public struct X509ChainTrustMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ChainTrustMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainTrustMode System
    /**
    Use the default (system) root trust.

    */
    public static var System : dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode(val: System_Security_Cryptography_X509Certificates_X509ChainTrustMode_get_System());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ChainTrustMode CustomRootTrust
    /**
    When this value is used, the  will be used instead of the default root trust.

    */
    public static var CustomRootTrust : dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ChainTrustMode(val: System_Security_Cryptography_X509Certificates_X509ChainTrustMode_get_CustomRootTrust());
            return __return;
        }
    }
} // X509ChainTrustMode


// type: System.Security.Cryptography.X509Certificates.X509ContentType
    /**
    Specifies the format of an X.509 certificate.

    */
public struct X509ContentType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ContentType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType Unknown
    /**
    An unknown X.509 certificate.

    */
    public static var Unknown : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_Unknown());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType Cert
    /**
    A single X.509 certificate.

    */
    public static var Cert : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_Cert());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType SerializedCert
    /**
    A single serialized X.509 certificate.

    */
    public static var SerializedCert : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_SerializedCert());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType Pfx
    /**
    A PFX-formatted certificate. The  value is identical to the  value.

    */
    public static var Pfx : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_Pfx());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType Pkcs12
    /**
    A PKCS #12-formatted certificate. The  value is identical to the  value.

    */
    public static var Pkcs12 : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_Pkcs12());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType SerializedStore
    /**
    A serialized store.

    */
    public static var SerializedStore : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_SerializedStore());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType Pkcs7
    /**
    A PKCS #7-formatted certificate.

    */
    public static var Pkcs7 : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_Pkcs7());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509ContentType Authenticode
    /**
    An Authenticode X.509 certificate.

    */
    public static var Authenticode : dotnet.System.Security.Cryptography.X509Certificates.X509ContentType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509ContentType(val: System_Security_Cryptography_X509Certificates_X509ContentType_get_Authenticode());
            return __return;
        }
    }
} // X509ContentType


// type: System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension
    /**
    Defines the collection of object identifiers (OIDs) that indicates the applications that use the key. This class cannot be inherited.

    */
public final class X509EnhancedKeyUsageExtension
    :
    dotnet.System.Security.Cryptography.X509Certificates.X509Extension
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509EnhancedKeyUsageExtension_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509EnhancedKeyUsageExtension_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509EnhancedKeyUsageExtension_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsnEncodedData, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension.#ctor(System.Security.Cryptography.AsnEncodedData,System.Boolean)
    /**
    Initializes a new instance of the  class using an  object and a value that identifies whether the extension is critical.

    - Parameter encodedEnhancedKeyUsages: The encoded data to use to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(encodedEnhancedKeyUsages : dotnet.System.Security.Cryptography.AsnEncodedData, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509EnhancedKeyUsageExtension_ctor_0__2__AsnEncodedData_bool(&__thrown, encodedEnhancedKeyUsages.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.OidCollection, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension.#ctor(System.Security.Cryptography.OidCollection,System.Boolean)
    /**
    Initializes a new instance of the  class using an  and a value that identifies whether the extension is critical.

    - Parameter enhancedKeyUsages: An  collection.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(enhancedKeyUsages : dotnet.System.Security.Cryptography.OidCollection, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509EnhancedKeyUsageExtension_ctor_0__2__OidCollection_bool(&__thrown, enhancedKeyUsages.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void CopyFrom(System.Security.Cryptography.AsnEncodedData)
// docid: M:System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension.CopyFrom(System.Security.Cryptography.AsnEncodedData)
    /**
    Initializes a new instance of the  class using an  object.

    - Parameter asnEncodedData: The encoded data to use to create the extension.
    */
    public override func CopyFrom(asnEncodedData : dotnet.System.Security.Cryptography.AsnEncodedData) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509EnhancedKeyUsageExtension_void__CopyFrom_0__1__AsnEncodedData(&__thrown, self.get_handle(), asnEncodedData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.OidCollection get_EnhancedKeyUsages()
// docid: M:System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension.get_EnhancedKeyUsages
    public func get_EnhancedKeyUsages() throws -> dotnet.System.Security.Cryptography.OidCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509EnhancedKeyUsageExtension_OidCollection__get_EnhancedKeyUsages_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.OidCollection(hndl : __return);
        }
    }
    /**
    Gets the collection of object identifiers (OIDs) that indicate the applications that use the key.

    */
    public var EnhancedKeyUsages : dotnet.System.Security.Cryptography.OidCollection {
        get {
            return try! get_EnhancedKeyUsages();
        }
    }
} // X509EnhancedKeyUsageExtension


// type: System.Security.Cryptography.X509Certificates.X509Extension
    /**
    Represents an X509 extension.

    */
open class X509Extension
    :
    dotnet.System.Security.Cryptography.AsnEncodedData
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509Extension_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509Extension_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Security.Cryptography.AsnEncodedData, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Extension.#ctor(System.Security.Cryptography.AsnEncodedData,System.Boolean)
    /**
    Initializes a new instance of the  class.

    - Parameter encodedExtension: The encoded data to be used to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise .
    */
    public init(encodedExtension : dotnet.System.Security.Cryptography.AsnEncodedData, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Extension_ctor_0__2__AsnEncodedData_bool(&__thrown, encodedExtension.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.Oid, System.Byte[], bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Extension.#ctor(System.Security.Cryptography.Oid,System.Byte[],System.Boolean)
    /**
    Initializes a new instance of the  class.

    - Parameter oid: The object identifier used to identify the extension.
    - Parameter rawData: The encoded data used to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise .
    */
    public init(oid : dotnet.System.Security.Cryptography.Oid, rawData : dotnet.System_Arr<Swift.UInt8>, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Extension_ctor_0__3__Oid_u8Array_bool(&__thrown, oid.get_handle(), rawData.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.Security.Cryptography.Oid, System.ReadOnlySpan<System.Byte>, bool)
    // .ctor(System.String, System.Byte[], bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Extension.#ctor(System.String,System.Byte[],System.Boolean)
    /**
    Initializes a new instance of the  class.

    - Parameter oid: A string representing the object identifier.
    - Parameter rawData: The encoded data used to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise .
    */
    public init(oid : dotnet.System.String, rawData : dotnet.System_Arr<Swift.UInt8>, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Extension_ctor_0__3__String_u8Array_bool(&__thrown, oid.get_handle(), rawData.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.String, System.ReadOnlySpan<System.Byte>, bool)
    // void CopyFrom(System.Security.Cryptography.AsnEncodedData)
// docid: M:System.Security.Cryptography.X509Certificates.X509Extension.CopyFrom(System.Security.Cryptography.AsnEncodedData)
    /**
    Copies the extension properties of the specified  object.

    - Parameter asnEncodedData: The  to be copied.
    */
    open override func CopyFrom(asnEncodedData : dotnet.System.Security.Cryptography.AsnEncodedData) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Extension_void__CopyFrom_0__1__AsnEncodedData(&__thrown, self.get_handle(), asnEncodedData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_Critical()
// docid: M:System.Security.Cryptography.X509Certificates.X509Extension.get_Critical
    open func get_Critical() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Extension_bool__get_Critical_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Critical(bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509Extension.set_Critical(System.Boolean)
    open func set_Critical(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Extension_void__set_Critical_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a Boolean value indicating whether the extension is critical.

    */
    open var Critical : Bool {
        get {
            return try! get_Critical();
        }
        set(v) {
            return try! set_Critical(value: v);
        }
    }
} // X509Extension


// type: System.Security.Cryptography.X509Certificates.X509ExtensionCollection
    /**
    Represents a collection of  objects. This class cannot be inherited.

    */
public final class X509ExtensionCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable,
    System_Collections_ICollection
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ExtensionCollection_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Int32 Add(System.Security.Cryptography.X509Certificates.X509Extension)
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.Add(System.Security.Cryptography.X509Certificates.X509Extension)
    /**
    Adds an  object to an  object.

    - Parameter extension: An  object to add to the  object.
    - Returns: The index at which the  parameter was added.

    */
    public func Add(extension_ : dotnet.System.Security.Cryptography.X509Certificates.X509Extension) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_i32__Add_0__1__X509Extension(&__thrown, self.get_handle(), extension_.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void CopyTo(System.Security.Cryptography.X509Certificates.X509Extension[], System.Int32)
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.CopyTo(System.Security.Cryptography.X509Certificates.X509Extension[],System.Int32)
    /**
    Copies a collection into an array starting at the specified index.

    - Parameter array: An array of  objects.
    - Parameter index: The location in the array at which copying starts.
    */
    public func CopyTo(array : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Extension>, index : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ExtensionCollection_void__CopyTo_0__2__X509ExtensionArray_i32(&__thrown, self.get_handle(), array.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator GetEnumerator()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.GetEnumerator
    /**
    Returns an enumerator that can iterate through an  object.

    - Returns: An  object to use to iterate through the  object.

    */
    public func GetEnumerator() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_X509ExtensionEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.get_Count
    public func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsSynchronized()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.get_IsSynchronized
    public func get_IsSynchronized() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_bool__get_IsSynchronized_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Object get_SyncRoot()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.get_SyncRoot
    public func get_SyncRoot() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_Object__get_SyncRoot_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Extension get_Item(System.Int32)
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.get_Item(System.Int32)
    public func get_Item(index : Swift.Int32) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Extension {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_X509Extension__get_Item_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Extension(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Extension get_Item(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionCollection.get_Item(System.String)
    public func get_Item(oid : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Extension> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionCollection_X509Extension__get_Item_0__1__String(&__thrown, self.get_handle(), oid.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509Extension(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the number of  objects in a  object.

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a value indicating whether the collection is guaranteed to be thread safe.

    */
    public var IsSynchronized : Bool {
        get {
            return try! get_IsSynchronized();
        }
    }
    /**
    Gets an object that you can use to synchronize access to the  object.

    */
    public var SyncRoot : dotnet.System.Object {
        get {
            return try! get_SyncRoot();
        }
    }
} // X509ExtensionCollection


// type: System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator
    /**
    Supports a simple iteration over a . This class cannot be inherited.

    */
public final class X509ExtensionEnumerator
    :
    dotnet.System.Object,
    System_Collections_IEnumerator,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509ExtensionEnumerator_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509ExtensionEnumerator_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // bool MoveNext()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator.MoveNext
    /**
    Advances the enumerator to the next element in the .

    - Returns: 
         if the enumerator was successfully advanced to the next element;  if the enumerator has passed the end of the collection.

    */
    public func MoveNext() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionEnumerator_bool__MoveNext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator.Reset
    /**
    Sets the enumerator to its initial position, which is before the first element in the .

    */
    public func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509ExtensionEnumerator_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Extension get_Current()
// docid: M:System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator.get_Current
    public func get_Current() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Extension {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509ExtensionEnumerator_X509Extension__get_Current_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Extension(hndl : __return);
        }
    }
    /**
    Gets the current element in the .

    */
    public var Current : dotnet.System.Security.Cryptography.X509Certificates.X509Extension {
        get {
            return try! get_Current();
        }
    }
} // X509ExtensionEnumerator


// type: System.Security.Cryptography.X509Certificates.X509FindType
    /**
    Specifies the type of value the  method searches for.

    */
public struct X509FindType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509FindType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByThumbprint
    /**
    The  parameter for the  method must be a string representing the thumbprint of the certificate.

    */
    public static var FindByThumbprint : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByThumbprint());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindBySubjectName
    /**
    The  parameter for the  method must be a string representing the subject name of the certificate. This is a less specific search than that provided by the  enumeration value. Using the  value, the  method performs a case-insensitive string comparison using the supplied value. For example, if you pass "MyCert" to the  method, it will find all certificates with the subject name containing that string, regardless of other subject values. Searching by distinguished name is a more precise search.

    */
    public static var FindBySubjectName : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindBySubjectName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindBySubjectDistinguishedName
    /**
    The  parameter for the  method must be a string representing the subject distinguished name of the certificate. This is a more specific search than that provided by the  enumeration value. Using the  value, the  method performs a case-insensitive string comparison for the entire distinguished name. Searching by subject name is a less precise search.

    */
    public static var FindBySubjectDistinguishedName : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindBySubjectDistinguishedName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByIssuerName
    /**
    The  parameter for the  method must be a string representing the issuer name of the certificate. This is a less specific search than that provided by the  enumeration value. Using the  value, the  method performs a case-insensitive string comparison using the supplied value. For example, if you pass "MyCA" to the  method, it will find all certificates with the issuer name containing that string, regardless of other issuer values.

    */
    public static var FindByIssuerName : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByIssuerName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByIssuerDistinguishedName
    /**
    The  parameter for the  method must be a string representing the issuer distinguished name of the certificate. This is a more specific search than that provided by the  enumeration value. Using the  value, the  method performs a case-insensitive string comparison for the entire distinguished name. Searching by issuer name is a less precise search.

    */
    public static var FindByIssuerDistinguishedName : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByIssuerDistinguishedName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindBySerialNumber
    /**
    The  parameter for the  method must be a string that represents the serial number of the certificate as displayed by the certificate dialog box, but without the spaces, or as returned by the  method.

    */
    public static var FindBySerialNumber : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindBySerialNumber());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByTimeValid
    /**
    The  parameter for the  method must be a  value in local time. You can use  to find all the currently valid certificates.

    */
    public static var FindByTimeValid : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByTimeValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByTimeNotYetValid
    /**
    The  parameter for the  method must be a  value in local time. The value does not have to be in the future. For example, you can use  to find certificates that became valid in the current year by taking the intersection of the results of a  operation for  for the last day of last year with the results of a  operation for  of .

    */
    public static var FindByTimeNotYetValid : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByTimeNotYetValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByTimeExpired
    /**
    The  parameter for the  method must be a  value in local time. For example, you can find all the certificates that will be valid until the end of the year by eliminating the results of a  operation for  of the last day of the year from the results of a  operation for .

    */
    public static var FindByTimeExpired : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByTimeExpired());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByTemplateName
    /**
    The  parameter for the  method must be a string representing the template name of the certificate, such as "ClientAuth". A template name is an X509 version 3 extension that specifies the uses of the certificate.

    */
    public static var FindByTemplateName : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByTemplateName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByApplicationPolicy
    /**
    The  parameter for the  method must be a string representing either the application policy friendly name or the object identifier (OID, or ) of the certificate. For example, "Encrypting File System" or "1.3.6.1.4.1.311.10.3.4" can be used. For an application that will be localized, the OID value must be used, because the friendly name is localized.

    */
    public static var FindByApplicationPolicy : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByApplicationPolicy());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByCertificatePolicy
    /**
    The  parameter for the  method must be a string representing either the friendly name or the object identifier (OID, or ) of the certificate policy. The best practice is to use the OID, such as "1.3.6.1.4.1.311.10.3.4". For an application that will be localized, the OID must be used, because the friendly name is localized.

    */
    public static var FindByCertificatePolicy : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByCertificatePolicy());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByExtension
    /**
    The  parameter for the  method must be a string describing the extension to find. The object identifier (OID) is most commonly used to direct the  method to search for all certificates that have an extension matching that OID value.

    */
    public static var FindByExtension : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByExtension());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindByKeyUsage
    /**
    The  parameter for the  method must be either a string representing the key usage or an integer representing a bit mask containing all the requested key usages. For the string value, only one key usage at a time can be specified, but the  method can be used in a cascading sequence to get the intersection of the requested usages. For example, the  parameter can be set to "KeyEncipherment" or an integer (0x30 indicates "KeyEncipherment" and "DataEncipherment"). Values of the  enumeration can also be used.

    */
    public static var FindByKeyUsage : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindByKeyUsage());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509FindType FindBySubjectKeyIdentifier
    /**
    The  parameter for the  method must be a string representing the subject key identifier in hexadecimal, such as "F3E815D45E83B8477B9284113C64EF208E897112", as displayed in the UI.

    */
    public static var FindBySubjectKeyIdentifier : dotnet.System.Security.Cryptography.X509Certificates.X509FindType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509FindType(val: System_Security_Cryptography_X509Certificates_X509FindType_get_FindBySubjectKeyIdentifier());
            return __return;
        }
    }
} // X509FindType


// type: System.Security.Cryptography.X509Certificates.X509IncludeOption
    /**
    Specifies how much of the X.509 certificate chain should be included in the X.509 data.

    */
public struct X509IncludeOption : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509IncludeOption_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509IncludeOption None
    /**
    No X.509 chain information is included.

    */
    public static var None : dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption(val: System_Security_Cryptography_X509Certificates_X509IncludeOption_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509IncludeOption ExcludeRoot
    /**
    The entire X.509 chain is included except for the root certificate.

    */
    public static var ExcludeRoot : dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption(val: System_Security_Cryptography_X509Certificates_X509IncludeOption_get_ExcludeRoot());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509IncludeOption EndCertOnly
    /**
    Only the end certificate is included in the X.509 chain information.

    */
    public static var EndCertOnly : dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption(val: System_Security_Cryptography_X509Certificates_X509IncludeOption_get_EndCertOnly());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509IncludeOption WholeChain
    /**
    The entire X.509 chain is included.

    */
    public static var WholeChain : dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509IncludeOption(val: System_Security_Cryptography_X509Certificates_X509IncludeOption_get_WholeChain());
            return __return;
        }
    }
} // X509IncludeOption


// type: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags
    /**
    Defines where and how to import the private key of an X.509 certificate.

    */
public struct X509KeyStorageFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags DefaultKeySet
    /**
    The default key set is used.  The user key set is usually the default.

    */
    public static var DefaultKeySet : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_DefaultKeySet());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags UserKeySet
    /**
    Private keys are stored in the current user store rather than the local computer store. This occurs even if the certificate specifies that the keys should go in the local computer store.

    */
    public static var UserKeySet : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_UserKeySet());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags MachineKeySet
    /**
    Private keys are stored in the local computer store rather than the current user store.

    */
    public static var MachineKeySet : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_MachineKeySet());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags Exportable
    /**
    Imported keys are marked as exportable.

    */
    public static var Exportable : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_Exportable());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags UserProtected
    /**
    Notify the user through a dialog box or other method that the key is accessed.  The Cryptographic Service Provider (CSP) in use defines the precise behavior.

    */
    public static var UserProtected : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_UserProtected());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags PersistKeySet
    /**
    The key associated with a PFX file is persisted when importing a certificate.

    */
    public static var PersistKeySet : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_PersistKeySet());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyStorageFlags EphemeralKeySet
    /**
    The key associated with a PFX file is created in memory and not persisted on disk when importing a certificate.

    */
    public static var EphemeralKeySet : dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyStorageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_get_EphemeralKeySet());
            return __return;
        }
    }
} // X509KeyStorageFlags


// type: System.Security.Cryptography.X509Certificates.X509KeyUsageExtension
    /**
    Defines the usage of a key contained within an X.509 certificate.  This class cannot be inherited.

    */
public final class X509KeyUsageExtension
    :
    dotnet.System.Security.Cryptography.X509Certificates.X509Extension
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509KeyUsageExtension_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509KeyUsageExtension_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509KeyUsageExtension_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsnEncodedData, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension.#ctor(System.Security.Cryptography.AsnEncodedData,System.Boolean)
    /**
    Initializes a new instance of the  class using an  object and a value that identifies whether the extension is critical.

    - Parameter encodedKeyUsage: The encoded data to use to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(encodedKeyUsage : dotnet.System.Security.Cryptography.AsnEncodedData, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509KeyUsageExtension_ctor_0__2__AsnEncodedData_bool(&__thrown, encodedKeyUsage.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509KeyUsageFlags, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension.#ctor(System.Security.Cryptography.X509Certificates.X509KeyUsageFlags,System.Boolean)
    /**
    Initializes a new instance of the  class using the specified  value and a value that identifies whether the extension is critical.

    - Parameter keyUsages: One of the  values that describes how to use the key.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(keyUsages : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509KeyUsageExtension_ctor_0__2__X509KeyUsageFlags_bool(&__thrown, keyUsages.get_value(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void CopyFrom(System.Security.Cryptography.AsnEncodedData)
// docid: M:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension.CopyFrom(System.Security.Cryptography.AsnEncodedData)
    /**
    Initializes a new instance of the  class using an  object.

    - Parameter asnEncodedData: The encoded data to use to create the extension.
    */
    public override func CopyFrom(asnEncodedData : dotnet.System.Security.Cryptography.AsnEncodedData) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509KeyUsageExtension_void__CopyFrom_0__1__AsnEncodedData(&__thrown, self.get_handle(), asnEncodedData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509KeyUsageFlags get_KeyUsages()
// docid: M:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension.get_KeyUsages
    public func get_KeyUsages() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509KeyUsageExtension_X509KeyUsageFlags__get_KeyUsages_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: __return);
        }
    }
    /**
    Gets the key usage flag associated with the certificate.

    */
    public var KeyUsages : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
            return try! get_KeyUsages();
        }
    }
} // X509KeyUsageExtension


// type: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags
    /**
    Defines how the certificate key can be used. If this value is not defined, the key can be used for any purpose.

    */
public struct X509KeyUsageFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags None
    /**
    No key usage parameters.

    */
    public static var None : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags EncipherOnly
    /**
    The key can be used for encryption only.

    */
    public static var EncipherOnly : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_EncipherOnly());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags CrlSign
    /**
    The key can be used to sign a certificate revocation list (CRL).

    */
    public static var CrlSign : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_CrlSign());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags KeyCertSign
    /**
    The key can be used to sign certificates.

    */
    public static var KeyCertSign : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_KeyCertSign());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags KeyAgreement
    /**
    The key can be used to determine key agreement, such as a key created using the Diffie-Hellman key agreement algorithm.

    */
    public static var KeyAgreement : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_KeyAgreement());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags DataEncipherment
    /**
    The key can be used for data encryption.

    */
    public static var DataEncipherment : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_DataEncipherment());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags KeyEncipherment
    /**
    The key can be used for key encryption.

    */
    public static var KeyEncipherment : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_KeyEncipherment());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags NonRepudiation
    /**
    The key can be used for authentication.

    */
    public static var NonRepudiation : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_NonRepudiation());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags DigitalSignature
    /**
    The key can be used as a digital signature.

    */
    public static var DigitalSignature : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_DigitalSignature());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509KeyUsageFlags DecipherOnly
    /**
    The key can be used for decryption only.

    */
    public static var DecipherOnly : dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509KeyUsageFlags(val: System_Security_Cryptography_X509Certificates_X509KeyUsageFlags_get_DecipherOnly());
            return __return;
        }
    }
} // X509KeyUsageFlags


// type: System.Security.Cryptography.X509Certificates.X509NameType
    /**
    Specifies the type of name the X509 certificate contains.

    */
public struct X509NameType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509NameType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509NameType SimpleName
    /**
    The simple name of a subject or issuer of an X509 certificate.

    */
    public static var SimpleName : dotnet.System.Security.Cryptography.X509Certificates.X509NameType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509NameType(val: System_Security_Cryptography_X509Certificates_X509NameType_get_SimpleName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509NameType EmailName
    /**
    The email address of the subject or issuer associated of an X509 certificate.

    */
    public static var EmailName : dotnet.System.Security.Cryptography.X509Certificates.X509NameType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509NameType(val: System_Security_Cryptography_X509Certificates_X509NameType_get_EmailName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509NameType UpnName
    /**
    The UPN name of the subject or issuer of an X509 certificate.

    */
    public static var UpnName : dotnet.System.Security.Cryptography.X509Certificates.X509NameType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509NameType(val: System_Security_Cryptography_X509Certificates_X509NameType_get_UpnName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509NameType DnsName
    /**
    The DNS name associated with the alternative name of either the subject or issuer of an X509 certificate.

    */
    public static var DnsName : dotnet.System.Security.Cryptography.X509Certificates.X509NameType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509NameType(val: System_Security_Cryptography_X509Certificates_X509NameType_get_DnsName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509NameType DnsFromAlternativeName
    /**
    The DNS name associated with the alternative name of either the subject or the issuer of an X.509 certificate.  This value is equivalent to the  value.

    */
    public static var DnsFromAlternativeName : dotnet.System.Security.Cryptography.X509Certificates.X509NameType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509NameType(val: System_Security_Cryptography_X509Certificates_X509NameType_get_DnsFromAlternativeName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509NameType UrlName
    /**
    The URL address associated with the alternative name of either the subject or issuer of an X509 certificate.

    */
    public static var UrlName : dotnet.System.Security.Cryptography.X509Certificates.X509NameType {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509NameType(val: System_Security_Cryptography_X509Certificates_X509NameType_get_UrlName());
            return __return;
        }
    }
} // X509NameType


// type: System.Security.Cryptography.X509Certificates.X509RevocationFlag
    /**
    Specifies which X509 certificates in the chain should be checked for revocation.

    */
public struct X509RevocationFlag : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509RevocationFlag_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509RevocationFlag EndCertificateOnly
    /**
    Only the end certificate is checked for revocation.

    */
    public static var EndCertificateOnly : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag(val: System_Security_Cryptography_X509Certificates_X509RevocationFlag_get_EndCertificateOnly());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509RevocationFlag EntireChain
    /**
    The entire chain of certificates is checked for revocation.

    */
    public static var EntireChain : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag(val: System_Security_Cryptography_X509Certificates_X509RevocationFlag_get_EntireChain());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509RevocationFlag ExcludeRoot
    /**
    The entire chain, except the root certificate, is checked for revocation.

    */
    public static var ExcludeRoot : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509RevocationFlag(val: System_Security_Cryptography_X509Certificates_X509RevocationFlag_get_ExcludeRoot());
            return __return;
        }
    }
} // X509RevocationFlag


// type: System.Security.Cryptography.X509Certificates.X509RevocationMode
    /**
    Specifies the mode used to check for X509 certificate revocation.

    */
public struct X509RevocationMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509RevocationMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509RevocationMode NoCheck
    /**
    No revocation check is performed on the certificate.

    */
    public static var NoCheck : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode(val: System_Security_Cryptography_X509Certificates_X509RevocationMode_get_NoCheck());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509RevocationMode Online
    /**
    A revocation check is made using an online certificate revocation list (CRL).

    */
    public static var Online : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode(val: System_Security_Cryptography_X509Certificates_X509RevocationMode_get_Online());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509RevocationMode Offline
    /**
    A revocation check is made using a cached certificate revocation list (CRL).

    */
    public static var Offline : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode(val: System_Security_Cryptography_X509Certificates_X509RevocationMode_get_Offline());
            return __return;
        }
    }
} // X509RevocationMode


// type: System.Security.Cryptography.X509Certificates.X509SignatureGenerator
    /**
    Base class for building encoded signatures as needed for X.509 certificates.

    */
open class X509SignatureGenerator
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509SignatureGenerator_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509SignatureGenerator_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509SignatureGenerator CreateForECDsa(System.Security.Cryptography.ECDsa)
// docid: M:System.Security.Cryptography.X509Certificates.X509SignatureGenerator.CreateForECDsa(System.Security.Cryptography.ECDsa)
    /**
    Creates an  object for ECDSA signatures using the specified private key.

    - Parameter key: The private key.
    - Returns: An  object for ECDSA signatures.

    */
    open class func CreateForECDsa(key : dotnet.System.Security.Cryptography.ECDsa) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509SignatureGenerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509SignatureGenerator_X509SignatureGenerator__CreateForECDsa_0__1__ECDsa(&__thrown, key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509SignatureGenerator(hndl : __return);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509SignatureGenerator CreateForRSA(System.Security.Cryptography.RSA, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.X509Certificates.X509SignatureGenerator.CreateForRSA(System.Security.Cryptography.RSA,System.Security.Cryptography.RSASignaturePadding)
    /**
    Creates an  object for RSA signatures using the specified private key and padding mode.

    - Parameter key: The private key.
    - Parameter signaturePadding: The padding mode.
    - Returns: An  object for RSA signatures.

    */
    open class func CreateForRSA(key : dotnet.System.Security.Cryptography.RSA, signaturePadding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509SignatureGenerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509SignatureGenerator_X509SignatureGenerator__CreateForRSA_0__2__RSA_RSASignaturePadding(&__thrown, key.get_handle(), signaturePadding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509SignatureGenerator(hndl : __return);
        }
    }
    // System.Byte[] GetSignatureAlgorithmIdentifier(System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.X509Certificates.X509SignatureGenerator.GetSignatureAlgorithmIdentifier(System.Security.Cryptography.HashAlgorithmName)
    /**
    When overridden in a derived class, encodes the X.509 algorithm identifier for this signature.

    - Parameter hashAlgorithm: The hash algorithm to use for encoding.
    - Returns: The encoded value for the X.509 algorithm identifier.

    */
    open func GetSignatureAlgorithmIdentifier(hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509SignatureGenerator_u8Array__GetSignatureAlgorithmIdentifier_0__1__HashAlgorithmName(&__thrown, self.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.X509Certificates.X509SignatureGenerator.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    When overridden in a derived class, produces a signature for the specified data using the specified hash algorithm and encodes the results appropriately for X.509 signature values.

    - Parameter data: The input data for which to produce the signature.
    - Parameter hashAlgorithm: The hash algorithm to use to produce the signature.
    - Returns: The X.509 signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509SignatureGenerator_u8Array__SignData_0__2__u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.PublicKey get_PublicKey()
// docid: M:System.Security.Cryptography.X509Certificates.X509SignatureGenerator.get_PublicKey
    open func get_PublicKey() throws -> dotnet.System.Security.Cryptography.X509Certificates.PublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509SignatureGenerator_PublicKey__get_PublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.PublicKey(hndl : __return);
        }
    }
    /**
    Gets the public key associated with the private key with which signatures are being generated.

    */
    open var PublicKey : dotnet.System.Security.Cryptography.X509Certificates.PublicKey {
        get {
            return try! get_PublicKey();
        }
    }
} // X509SignatureGenerator


// type: System.Security.Cryptography.X509Certificates.X509Store
    /**
    Represents an X.509 store, which is a physical store where certificates are persisted and managed. This class cannot be inherited.

    */
public final class X509Store
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509Store_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509Store_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor
    /**
    Initializes a new instance of the  class using the personal certificates store of the current user.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class using an Intptr handle to an  store.

    - Parameter storeHandle: A handle to an  store.
    */
    public init(storeHandle : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__1__IntPtr(&__thrown, storeHandle.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.StoreLocation)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.Security.Cryptography.X509Certificates.StoreLocation)
    /**
    Initializes a new instance of the  class using the personal certificate store from the specified store location value.

    - Parameter storeLocation: One of the enumeration values that specifies the location of the X.509 certificate store.
    */
    public init(storeLocation : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__1__StoreLocation(&__thrown, storeLocation.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.StoreName)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.Security.Cryptography.X509Certificates.StoreName)
    /**
    Initializes a new instance of the  class using the specified store name from the current user's certificate stores.

    - Parameter storeName: One of the enumeration values that specifies the name of the X.509 certificate store.
    */
    public init(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__1__StoreName(&__thrown, storeName.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.StoreName, System.Security.Cryptography.X509Certificates.StoreLocation)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.Security.Cryptography.X509Certificates.StoreName,System.Security.Cryptography.X509Certificates.StoreLocation)
    /**
    Initializes a new instance of the  class using the specified  and  values.

    - Parameter storeName: One of the enumeration values that specifies the name of the X.509 certificate store.
    - Parameter storeLocation: One of the enumeration values that specifies the location of the X.509 certificate store.
    */
    public init(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, storeLocation : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__2__StoreName_StoreLocation(&__thrown, storeName.get_value(), storeLocation.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.StoreName, System.Security.Cryptography.X509Certificates.StoreLocation, System.Security.Cryptography.X509Certificates.OpenFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.Security.Cryptography.X509Certificates.StoreName,System.Security.Cryptography.X509Certificates.StoreLocation,System.Security.Cryptography.X509Certificates.OpenFlags)
    /**
    Initializes a new instance of the  class using the specified store name and store location values, then opens it using the specified flags.

    - Parameter storeName: One of the enumeration values that specifies the name of the X.509 certificate store.
    - Parameter storeLocation: One of the enumeration values that specifies the location of the X.509 certificate store.
    - Parameter flags: A bitwise combination of enumeration values that specifies the way to open the X.509 certificate store.
    */
    public init(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, storeLocation : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation, flags : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__3__StoreName_StoreLocation_OpenFlags(&__thrown, storeName.get_value(), storeLocation.get_value(), flags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.String)
    /**
    Initializes a new instance of the  class using the specified store name.

    - Parameter storeName: The name of the certificate store.
    */
    public init(storeName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__1__String(&__thrown, storeName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.X509Certificates.StoreLocation)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.String,System.Security.Cryptography.X509Certificates.StoreLocation)
    /**
    Initializes a new instance of the  class using a specified store name and store location.

    - Parameter storeName: The name of the certificate store.
    - Parameter storeLocation: One of the enumeration values that specifies the location of the X.509 certificate store.
    */
    public init(storeName : dotnet.System.String, storeLocation : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__2__String_StoreLocation(&__thrown, storeName.get_handle(), storeLocation.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.Cryptography.X509Certificates.StoreLocation, System.Security.Cryptography.X509Certificates.OpenFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.#ctor(System.String,System.Security.Cryptography.X509Certificates.StoreLocation,System.Security.Cryptography.X509Certificates.OpenFlags)
    /**
    Initializes a new instance of the  class using the specified store name and store location values, then opens it using the specified flags.

    - Parameter storeName: The name of the certificate store.
    - Parameter storeLocation: One of the enumeration values that specifies the location of the X.509 certificate store.
    - Parameter flags: A bitwise combination of enumeration values that specifies the way to open the X.509 certificate store.
    */
    public init(storeName : dotnet.System.String, storeLocation : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation, flags : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509Store_ctor_0__3__String_StoreLocation_OpenFlags(&__thrown, storeName.get_handle(), storeLocation.get_value(), flags.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Add(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.Add(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Adds a certificate to an X.509 certificate store.

    - Parameter certificate: The certificate to add.
    */
    public func Add(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Store_void__Add_0__1__X509Certificate2(&__thrown, self.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
    /**
    Adds a collection of certificates to an X.509 certificate store.

    - Parameter certificates: The collection of certificates to add.
    */
    public func AddRange(certificates : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Store_void__AddRange_0__1__X509Certificate2Collection(&__thrown, self.get_handle(), certificates.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Close()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.Close
    /**
    Closes an X.509 certificate store.

    */
    public func Close() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Store_void__Close_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Dispose()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.Dispose
    /**
    Releases the resources used by this .

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Store_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Open(System.Security.Cryptography.X509Certificates.OpenFlags)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.Open(System.Security.Cryptography.X509Certificates.OpenFlags)
    /**
    Opens an X.509 certificate store or creates a new store, depending on  flag settings.

    - Parameter flags: A bitwise combination of enumeration values that specifies the way to open the X.509 certificate store.
    */
    public func Open(flags : dotnet.System.Security.Cryptography.X509Certificates.OpenFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Store_void__Open_0__1__OpenFlags(&__thrown, self.get_handle(), flags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Remove(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.Remove(System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    Removes a certificate from an X.509 certificate store.

    - Parameter certificate: The certificate to remove.
    */
    public func Remove(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Store_void__Remove_0__1__X509Certificate2(&__thrown, self.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)
    /**
    Removes a range of certificates from an X.509 certificate store.

    - Parameter certificates: A range of certificates to remove.
    */
    public func RemoveRange(certificates : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509Store_void__RemoveRange_0__1__X509Certificate2Collection(&__thrown, self.get_handle(), certificates.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate2Collection get_Certificates()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.get_Certificates
    public func get_Certificates() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Store_X509Certificate2Collection__get_Certificates_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsOpen()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.get_IsOpen
    public func get_IsOpen() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Store_bool__get_IsOpen_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.StoreLocation get_Location()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.get_Location
    public func get_Location() throws -> dotnet.System.Security.Cryptography.X509Certificates.StoreLocation {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Store_StoreLocation__get_Location_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.StoreLocation(val: __return);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.get_Name
    public func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Store_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.IntPtr get_StoreHandle()
// docid: M:System.Security.Cryptography.X509Certificates.X509Store.get_StoreHandle
    public func get_StoreHandle() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509Store_IntPtr__get_StoreHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    /**
    Returns a collection of certificates located in an X.509 certificate store.

    */
    public var Certificates : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection {
        get {
            return try! get_Certificates();
        }
    }
    /**
    Gets a value that indicates whether the instance is connected to an open certificate store.

    */
    public var IsOpen : Bool {
        get {
            return try! get_IsOpen();
        }
    }
    /**
    Gets the location of the X.509 certificate store.

    */
    public var Location : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation {
        get {
            return try! get_Location();
        }
    }
    /**
    Gets the name of the X.509 certificate store.

    */
    public var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    Gets an  handle to an  store.

    */
    public var StoreHandle : dotnet.System.IntPtr {
        get {
            return try! get_StoreHandle();
        }
    }
} // X509Store


// type: System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension
    /**
    Defines a string that identifies a certificate's subject key identifier (SKI). This class cannot be inherited.

    */
public final class X509SubjectKeyIdentifierExtension
    :
    dotnet.System.Security.Cryptography.X509Certificates.X509Extension
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.#ctor(System.Byte[],System.Boolean)
    /**
    Initializes a new instance of the  class using a byte array and a value that identifies whether the extension is critical.

    - Parameter subjectKeyIdentifier: A byte array that represents data to use to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(subjectKeyIdentifier : dotnet.System_Arr<Swift.UInt8>, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_ctor_0__2__u8Array_bool(&__thrown, subjectKeyIdentifier.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>, bool)
    // .ctor(System.Security.Cryptography.AsnEncodedData, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.#ctor(System.Security.Cryptography.AsnEncodedData,System.Boolean)
    /**
    Initializes a new instance of the  class using encoded data and a value that identifies whether the extension is critical.

    - Parameter encodedSubjectKeyIdentifier: The  object to use to create the extension.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(encodedSubjectKeyIdentifier : dotnet.System.Security.Cryptography.AsnEncodedData, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_ctor_0__2__AsnEncodedData_bool(&__thrown, encodedSubjectKeyIdentifier.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.PublicKey, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.#ctor(System.Security.Cryptography.X509Certificates.PublicKey,System.Boolean)
    /**
    Initializes a new instance of the  class using a public key and a value indicating whether the extension is critical.

    - Parameter key: A  object to create a subject key identifier (SKI) from.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(key : dotnet.System.Security.Cryptography.X509Certificates.PublicKey, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_ctor_0__2__PublicKey_bool(&__thrown, key.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.PublicKey, System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.#ctor(System.Security.Cryptography.X509Certificates.PublicKey,System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm,System.Boolean)
    /**
    Initializes a new instance of the  class using a public key, a hash algorithm identifier, and a value indicating whether the extension is critical.

    - Parameter key: A  object to create a subject key identifier (SKI) from.
    - Parameter algorithm: One of the  values that identifies which hash algorithm to use.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(key : dotnet.System.Security.Cryptography.X509Certificates.PublicKey, algorithm : dotnet.System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_ctor_0__3__PublicKey_X509SubjectKeyIdentifierHashAlgorithm_bool(&__thrown, key.get_handle(), algorithm.get_value(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, bool)
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.#ctor(System.String,System.Boolean)
    /**
    Initializes a new instance of the  class using a string and a value that identifies whether the extension is critical.

    - Parameter subjectKeyIdentifier: A string, encoded in hexadecimal format, that represents the subject key identifier (SKI) for a certificate.
    - Parameter critical: 
         if the extension is critical; otherwise, .
    */
    public init(subjectKeyIdentifier : dotnet.System.String, critical : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_ctor_0__2__String_bool(&__thrown, subjectKeyIdentifier.get_handle(), Swift.Int32(critical ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void CopyFrom(System.Security.Cryptography.AsnEncodedData)
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.CopyFrom(System.Security.Cryptography.AsnEncodedData)
    /**
    Creates a new instance of the  class by copying information from encoded data.

    - Parameter asnEncodedData: The  object to use to create the extension.
    */
    public override func CopyFrom(asnEncodedData : dotnet.System.Security.Cryptography.AsnEncodedData) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_void__CopyFrom_0__1__AsnEncodedData(&__thrown, self.get_handle(), asnEncodedData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_SubjectKeyIdentifier()
// docid: M:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension.get_SubjectKeyIdentifier
    public func get_SubjectKeyIdentifier() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierExtension_String__get_SubjectKeyIdentifier_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets a string that represents the subject key identifier (SKI) for a certificate.

    */
    public var SubjectKeyIdentifier : Optional<dotnet.System.String> {
        get {
            return try! get_SubjectKeyIdentifier();
        }
    }
} // X509SubjectKeyIdentifierExtension


// type: System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm
    /**
    Defines the type of hash algorithm to use with the  class.

    */
public struct X509SubjectKeyIdentifierHashAlgorithm : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierHashAlgorithm_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm Sha1
    /**
    The SKI is composed of the 160-bit SHA-1 hash of the value of the public key (excluding the tag, length, and number of unused bits).

    */
    public static var Sha1 : dotnet.System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm(val: System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierHashAlgorithm_get_Sha1());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm ShortSha1
    /**
    The SKI is composed of a four-bit type field with the value 0100, followed by the least significant 60 bits of the SHA-1 hash of the value of the public key (excluding the tag, length, and number of unused bit string bits)

    */
    public static var ShortSha1 : dotnet.System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm(val: System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierHashAlgorithm_get_ShortSha1());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm CapiSha1
    /**
    The subject key identifier (SKI) is composed of a 160-bit SHA-1 hash of the encoded public key (including the tag, length, and number of unused bits).

    */
    public static var CapiSha1 : dotnet.System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm(val: System_Security_Cryptography_X509Certificates_X509SubjectKeyIdentifierHashAlgorithm_get_CapiSha1());
            return __return;
        }
    }
} // X509SubjectKeyIdentifierHashAlgorithm


// type: System.Security.Cryptography.X509Certificates.X509VerificationFlags
    /**
    Specifies conditions under which verification of certificates in the X509 chain should be conducted.

    */
public struct X509VerificationFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags NoFlag
    /**
    No flags pertaining to verification are included.

    */
    public static var NoFlag : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_NoFlag());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreNotTimeValid
    /**
    Ignore certificates in the chain that are not valid either because they have expired or they are not yet in effect when determining certificate validity.

    */
    public static var IgnoreNotTimeValid : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreNotTimeValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreCtlNotTimeValid
    /**
    Ignore that the certificate trust list (CTL) is not valid, for reasons such as the CTL has expired, when determining certificate verification.

    */
    public static var IgnoreCtlNotTimeValid : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreCtlNotTimeValid());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreNotTimeNested
    /**
    Ignore that the CA (certificate authority) certificate and the issued certificate have validity periods that are not nested when verifying the certificate. For example, the CA cert can be valid from January 1 to December 1 and the issued certificate from January 2 to December 2, which would mean the validity periods are not nested.

    */
    public static var IgnoreNotTimeNested : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreNotTimeNested());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreInvalidBasicConstraints
    /**
    Ignore that the basic constraints are not valid when determining certificate verification.

    */
    public static var IgnoreInvalidBasicConstraints : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreInvalidBasicConstraints());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags AllowUnknownCertificateAuthority
    /**
    Ignore that the chain cannot be verified due to an unknown certificate authority (CA) or partial chains.

    */
    public static var AllowUnknownCertificateAuthority : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_AllowUnknownCertificateAuthority());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreWrongUsage
    /**
    Ignore that the certificate was not issued for the current use when determining certificate verification.

    */
    public static var IgnoreWrongUsage : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreWrongUsage());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreInvalidName
    /**
    Ignore that the certificate has an invalid name when determining certificate verification.

    */
    public static var IgnoreInvalidName : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreInvalidName());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreInvalidPolicy
    /**
    Ignore that the certificate has invalid policy when determining certificate verification.

    */
    public static var IgnoreInvalidPolicy : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreInvalidPolicy());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreEndRevocationUnknown
    /**
    Ignore that the end certificate (the user certificate) revocation is unknown when determining certificate verification.

    */
    public static var IgnoreEndRevocationUnknown : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreEndRevocationUnknown());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreCtlSignerRevocationUnknown
    /**
    Ignore that the certificate trust list (CTL) signer revocation is unknown when determining certificate verification.

    */
    public static var IgnoreCtlSignerRevocationUnknown : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreCtlSignerRevocationUnknown());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown
    /**
    Ignore that the certificate authority revocation is unknown when determining certificate verification.

    */
    public static var IgnoreCertificateAuthorityRevocationUnknown : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreCertificateAuthorityRevocationUnknown());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags IgnoreRootRevocationUnknown
    /**
    Ignore that the root revocation is unknown when determining certificate verification.

    */
    public static var IgnoreRootRevocationUnknown : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_IgnoreRootRevocationUnknown());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.X509Certificates.X509VerificationFlags AllFlags
    /**
    All flags pertaining to verification are included.

    */
    public static var AllFlags : dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.X509Certificates.X509VerificationFlags(val: System_Security_Cryptography_X509Certificates_X509VerificationFlags_get_AllFlags());
            return __return;
        }
    }
} // X509VerificationFlags


}




// EXTENSION METHOD System.Security.Cryptography.X509Certificates.X509Certificate2 CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.DSA)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func CopyWithPrivateKey(privateKey : dotnet.System.Security.Cryptography.DSA) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        return try dotnet.System.Security.Cryptography.X509Certificates.DSACertificateExtensions.CopyWithPrivateKey(certificate: self, privateKey: privateKey);
    }
}

// EXTENSION METHOD System.Security.Cryptography.DSA GetDSAPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func GetDSAPrivateKey() throws -> Optional<dotnet.System.Security.Cryptography.DSA> {
        return try dotnet.System.Security.Cryptography.X509Certificates.DSACertificateExtensions.GetDSAPrivateKey(certificate: self);
    }
}

// EXTENSION METHOD System.Security.Cryptography.DSA GetDSAPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func GetDSAPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.DSA> {
        return try dotnet.System.Security.Cryptography.X509Certificates.DSACertificateExtensions.GetDSAPublicKey(certificate: self);
    }
}

// EXTENSION METHOD System.Security.Cryptography.X509Certificates.X509Certificate2 CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.ECDsa)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func CopyWithPrivateKey(privateKey : dotnet.System.Security.Cryptography.ECDsa) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        return try dotnet.System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions.CopyWithPrivateKey(certificate: self, privateKey: privateKey);
    }
}

// EXTENSION METHOD System.Security.Cryptography.ECDsa GetECDsaPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func GetECDsaPrivateKey() throws -> Optional<dotnet.System.Security.Cryptography.ECDsa> {
        return try dotnet.System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions.GetECDsaPrivateKey(certificate: self);
    }
}

// EXTENSION METHOD System.Security.Cryptography.ECDsa GetECDsaPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func GetECDsaPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.ECDsa> {
        return try dotnet.System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions.GetECDsaPublicKey(certificate: self);
    }
}

// EXTENSION METHOD System.Security.Cryptography.X509Certificates.X509Certificate2 CopyWithPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.RSA)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func CopyWithPrivateKey(privateKey : dotnet.System.Security.Cryptography.RSA) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        return try dotnet.System.Security.Cryptography.X509Certificates.RSACertificateExtensions.CopyWithPrivateKey(certificate: self, privateKey: privateKey);
    }
}

// EXTENSION METHOD System.Security.Cryptography.RSA GetRSAPrivateKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func GetRSAPrivateKey() throws -> Optional<dotnet.System.Security.Cryptography.RSA> {
        return try dotnet.System.Security.Cryptography.X509Certificates.RSACertificateExtensions.GetRSAPrivateKey(certificate: self);
    }
}

// EXTENSION METHOD System.Security.Cryptography.RSA GetRSAPublicKey(System.Security.Cryptography.X509Certificates.X509Certificate2)
extension dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
    public func GetRSAPublicKey() throws -> Optional<dotnet.System.Security.Cryptography.RSA> {
        return try dotnet.System.Security.Cryptography.X509Certificates.RSACertificateExtensions.GetRSAPublicKey(certificate: self);
    }
}

