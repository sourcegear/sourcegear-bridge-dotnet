// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
// System.Reflection
// System.Reflection.Metadata
extension System.Reflection.Metadata {
// type: System.Reflection.Metadata.AssemblyExtensions
public struct AssemblyExtensions {
// TODO COPE (parm byref pointer): bool TryGetRawMetadata(System.Reflection.Assembly, ref System.Byte*, ref System.Int32)
} // AssemblyExtensions


// type: System.Reflection.Metadata.MetadataUpdateHandlerAttribute
    /**
    Indicates that a type that should receive notifications of metadata updates.

    */
public final class MetadataUpdateHandlerAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Reflection_Metadata_MetadataUpdateHandlerAttribute_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Reflection_Metadata_MetadataUpdateHandlerAttribute_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Type)
// docid: M:System.Reflection.Metadata.MetadataUpdateHandlerAttribute.#ctor(System.Type)
    /**
    Initializes the attribute.

    - Parameter handlerType: A type that handles metadata updates and that should be notified when any occur.
    */
    public init(handlerType : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Metadata_MetadataUpdateHandlerAttribute_ctor_0__1__Type(&__thrown, handlerType.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Type get_HandlerType()
// docid: M:System.Reflection.Metadata.MetadataUpdateHandlerAttribute.get_HandlerType
    public func get_HandlerType() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Metadata_MetadataUpdateHandlerAttribute_Type__get_HandlerType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    /**
    Gets the type that handles metadata updates and that should be notified when any occur.

    */
    public var HandlerType : dotnet.System.Type_ {
        get {
            return try! get_HandlerType();
        }
    }
} // MetadataUpdateHandlerAttribute


// type: System.Reflection.Metadata.MetadataUpdater
public struct MetadataUpdater {
// TODO COPE (write_all_methods) (span) void ApplyUpdate(System.Reflection.Assembly, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // [IsSpecialName] bool get_IsSupported()
// docid: M:System.Reflection.Metadata.MetadataUpdater.get_IsSupported
    public static func get_IsSupported() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Metadata_MetadataUpdater_bool__get_IsSupported_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets a value that indicates whether the assembly update is enabled and available.

    */
    public static var IsSupported : Bool {
        get {
            return try! get_IsSupported();
        }
    }
} // MetadataUpdater


}


// System.Runtime
// System.Runtime.CompilerServices
extension System.Runtime.CompilerServices {
// type: System.Runtime.CompilerServices.CreateNewOnMetadataUpdateAttribute
    /**
    Indicates a type should be replaced rather than updated when applying metadata updates.

    */
public final class CreateNewOnMetadataUpdateAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Runtime_CompilerServices_CreateNewOnMetadataUpdateAttribute_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Runtime_CompilerServices_CreateNewOnMetadataUpdateAttribute_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Runtime.CompilerServices.CreateNewOnMetadataUpdateAttribute.#ctor
    /**
    Creates a new  instance.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Runtime_CompilerServices_CreateNewOnMetadataUpdateAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // CreateNewOnMetadataUpdateAttribute


}

// System.Runtime.Loader
extension System.Runtime.Loader {
// type: System.Runtime.Loader.AssemblyDependencyResolver
    /**
    Allows a program to resolve assemblies and native libraries to paths based on the dependencies of a given assembly.

    */
public final class AssemblyDependencyResolver
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Runtime_Loader_AssemblyDependencyResolver_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Runtime_Loader_AssemblyDependencyResolver_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:System.Runtime.Loader.AssemblyDependencyResolver.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a path to a component's assembly.

    - Parameter componentAssemblyPath: The path to the component or plugin's managed entry point.
    */
    public init(componentAssemblyPath : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Runtime_Loader_AssemblyDependencyResolver_ctor_0__1__String(&__thrown, componentAssemblyPath.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ResolveAssemblyToPath(System.Reflection.AssemblyName)
// docid: M:System.Runtime.Loader.AssemblyDependencyResolver.ResolveAssemblyToPath(System.Reflection.AssemblyName)
    /**
    Resolves a path to an assembly with the given assembly name based on the component's dependencies.

    - Parameter assemblyName: The assembly name to resolve.
    - Returns: The path to an assembly with the given name from the component's deps.json file, or  if the assembly does not exist in the deps.json file or is not on disk in the location specified by the deps.json file.

    */
    public func ResolveAssemblyToPath(assemblyName : dotnet.System.Reflection.AssemblyName) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyDependencyResolver_String__ResolveAssemblyToPath_0__1__AssemblyName(&__thrown, self.get_handle(), assemblyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String ResolveUnmanagedDllToPath(System.String)
// docid: M:System.Runtime.Loader.AssemblyDependencyResolver.ResolveUnmanagedDllToPath(System.String)
    /**
    Resolves a path to a native library with the given name based on the component's dependencies.

    - Parameter unmanagedDllName: The name of the native library to resolve.
    - Returns: The path to a native library with the given name from the component's deps.json file and the current runtime identifier, or  if the assembly does not exist in the deps.json file or is not on disk  in the location specified by the deps.json file.

    */
    public func ResolveUnmanagedDllToPath(unmanagedDllName : dotnet.System.String) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyDependencyResolver_String__ResolveUnmanagedDllToPath_0__1__String(&__thrown, self.get_handle(), unmanagedDllName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // AssemblyDependencyResolver


// type: System.Runtime.Loader.AssemblyLoadContext
    /**
    Represents the runtime's concept of a scope for assembly loading.

    */
open class AssemblyLoadContext
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Runtime_Loader_AssemblyLoadContext_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Runtime_Loader_AssemblyLoadContext_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String, bool)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.String,System.Boolean)
    /**
    Initializes a new instance of the  class with a name and a value that indicates whether unloading is enabled.

    - Parameter name: The value for  in the new instance. Its value can be .
    - Parameter isCollectible: 
         to enable ; otherwise, . The default value is  because there is a performance cost associated with enabling unloading.
    */
    public init(name : Optional<dotnet.System.String>, isCollectible : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Runtime_Loader_AssemblyLoadContext_ctor_0__2__String_bool(&__thrown, name?.get_handle() ?? nil, Swift.Int32(isCollectible ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection
    /**
    Sets  to .

    - Returns: An object to restore the previous value of . It is intended to be used as an  in a  block.

    */
    open func EnterContextualReflection() throws -> dotnet.System.Runtime.Loader.AssemblyLoadContext_ContextualReflectionScope {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_AssemblyLoadContext_ContextualReflectionScope__EnterContextualReflection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Runtime.Loader.AssemblyLoadContext_ContextualReflectionScope(hndl : __return);
        }
    }
    // System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection(System.Reflection.Assembly)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection(System.Reflection.Assembly)
    /**
    Sets  to the  which loaded the assembly.

    - Parameter activating: The assembly that is used to determine the requested  instance.
    - Returns: An object to restore the previous value of . It is intended to be used as an  in a  block.

    */
    open class func EnterContextualReflection(activating : Optional<dotnet.System.Reflection.Assembly>) throws -> dotnet.System.Runtime.Loader.AssemblyLoadContext_ContextualReflectionScope {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_AssemblyLoadContext_ContextualReflectionScope__EnterContextualReflection_0__1__Assembly(&__thrown, activating?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Runtime.Loader.AssemblyLoadContext_ContextualReflectionScope(hndl : __return);
        }
    }
    // System.Reflection.AssemblyName GetAssemblyName(System.String)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)
    /**
    Gets an  for an assembly path.

    - Parameter assemblyPath: The path to the assembly.
    - Returns: An object that contains the fully parsed assembly name for the assembly at .

    */
    open class func GetAssemblyName(assemblyPath : dotnet.System.String) throws -> dotnet.System.Reflection.AssemblyName {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_AssemblyName__GetAssemblyName_0__1__String(&__thrown, assemblyPath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.AssemblyName(hndl : __return);
        }
    }
    // System.Runtime.Loader.AssemblyLoadContext GetLoadContext(System.Reflection.Assembly)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)
    /**
    Gets the  containing the specified .

    - Parameter assembly: An assembly.
    - Returns: The assembly load context containing the . If the  is not provided by the runtime, this method returns null.

    */
    open class func GetLoadContext(assembly : dotnet.System.Reflection.Assembly) throws -> Optional<dotnet.System.Runtime.Loader.AssemblyLoadContext> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_AssemblyLoadContext__GetLoadContext_0__1__Assembly(&__thrown, assembly.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Runtime.Loader.AssemblyLoadContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Reflection.Assembly LoadFromAssemblyName(System.Reflection.AssemblyName)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)
    /**
    Resolves and loads an assembly given its .

    - Parameter assemblyName: The object that describes the assembly to load.
    - Returns: The loaded assembly, or throws.

    */
    open func LoadFromAssemblyName(assemblyName : dotnet.System.Reflection.AssemblyName) throws -> dotnet.System.Reflection.Assembly {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_Assembly__LoadFromAssemblyName_0__1__AssemblyName(&__thrown, self.get_handle(), assemblyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Assembly(hndl : __return);
        }
    }
    // System.Reflection.Assembly LoadFromAssemblyPath(System.String)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)
    /**
    Loads the contents of an assembly file on the specified path.

    - Parameter assemblyPath: The fully qualified path of the file to load.
    - Returns: The loaded assembly.

    */
    open func LoadFromAssemblyPath(assemblyPath : dotnet.System.String) throws -> dotnet.System.Reflection.Assembly {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_Assembly__LoadFromAssemblyPath_0__1__String(&__thrown, self.get_handle(), assemblyPath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Assembly(hndl : __return);
        }
    }
    // System.Reflection.Assembly LoadFromNativeImagePath(System.String, System.String)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)
    /**
    Loads the contents of the native image of a managed assembly file on the specified path.

    - Parameter nativeImagePath: The fully qualified path of the file to load.
    - Parameter assemblyPath: The fully qualified path of the IL version of the file to load, or .
    - Returns: The loaded assembly.

    */
    open func LoadFromNativeImagePath(nativeImagePath : dotnet.System.String, assemblyPath : Optional<dotnet.System.String>) throws -> dotnet.System.Reflection.Assembly {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_Assembly__LoadFromNativeImagePath_0__2__String_String(&__thrown, self.get_handle(), nativeImagePath.get_handle(), assemblyPath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Assembly(hndl : __return);
        }
    }
    // System.Reflection.Assembly LoadFromStream(System.IO.Stream)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)
    /**
    Loads the assembly with a common object file format (COFF)-based image containing a managed assembly.

    - Parameter assembly: A byte array that is a COFF-based image containing a managed assembly.
    - Returns: The loaded assembly.

    */
    open func LoadFromStream(assembly : dotnet.System.IO.Stream) throws -> dotnet.System.Reflection.Assembly {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_Assembly__LoadFromStream_0__1__Stream(&__thrown, self.get_handle(), assembly.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Assembly(hndl : __return);
        }
    }
    // System.Reflection.Assembly LoadFromStream(System.IO.Stream, System.IO.Stream)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)
    /**
    Loads the assembly with a common object file format (COFF)-based image containing a managed assembly, optionally including symbols for the assembly.

    - Parameter assembly: A byte array that is a COFF-based image containing a managed assembly.
    - Parameter assemblySymbols: A byte array that contains the raw bytes representing the symbols for the assembly.
    - Returns: The loaded assembly.

    */
    open func LoadFromStream(assembly : dotnet.System.IO.Stream, assemblySymbols : Optional<dotnet.System.IO.Stream>) throws -> dotnet.System.Reflection.Assembly {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_Assembly__LoadFromStream_0__2__Stream_Stream(&__thrown, self.get_handle(), assembly.get_handle(), assemblySymbols?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Assembly(hndl : __return);
        }
    }
    // void SetProfileOptimizationRoot(System.String)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)
    /**
    Sets the root path where the optimization profiles for this load context are stored.

    - Parameter directoryPath: The full path to the directory where the optimization profiles are stored.
    */
    open func SetProfileOptimizationRoot(directoryPath : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__SetProfileOptimizationRoot_0__1__String(&__thrown, self.get_handle(), directoryPath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void StartProfileOptimization(System.String)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)
    /**
    Starts the profile optimization for the specified profile.

    - Parameter profile: The name of the optimization profile.
    */
    open func StartProfileOptimization(profile : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__StartProfileOptimization_0__1__String(&__thrown, self.get_handle(), profile?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String ToString()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.ToString
    /**
    Returns the string representation of this load context.

    - Returns: The string representation of this load context.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // void Unload()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.Unload
    /**
    Initiates an unload of this .

    */
    open func Unload() throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__Unload_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<System.Runtime.Loader.AssemblyLoadContext> get_All()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.get_All
    open class func get_All() throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Runtime.Loader.AssemblyLoadContext> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_System_Collections_Generic_IEnumerable_System_Runtime_Loader_AssemblyLoadContext___get_All_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<System.Reflection.Assembly> get_Assemblies()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.get_Assemblies
    open func get_Assemblies() throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Reflection.Assembly> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_System_Collections_Generic_IEnumerable_System_Reflection_Assembly___get_Assemblies_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Runtime.Loader.AssemblyLoadContext get_CurrentContextualReflectionContext()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.get_CurrentContextualReflectionContext
    open class func get_CurrentContextualReflectionContext() throws -> Optional<dotnet.System.Runtime.Loader.AssemblyLoadContext> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_AssemblyLoadContext__get_CurrentContextualReflectionContext_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Runtime.Loader.AssemblyLoadContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Runtime.Loader.AssemblyLoadContext get_Default()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.get_Default
    open class func get_Default() throws -> dotnet.System.Runtime.Loader.AssemblyLoadContext {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_AssemblyLoadContext__get_Default_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Runtime.Loader.AssemblyLoadContext(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsCollectible()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.get_IsCollectible
    open func get_IsCollectible() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_bool__get_IsCollectible_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.get_Name
    open func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_Loader_AssemblyLoadContext_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void add_Resolving(System.Func<System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly>)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.add_Resolving(System.Func{System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly})
    open func add_Resolving(value : Optional<dotnet.System.Func_3<dotnet.System.Runtime.Loader.AssemblyLoadContext,dotnet.System.Reflection.AssemblyName,dotnet.System.Reflection.Assembly>>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__add_Resolving_0__1__System_Func_System_Runtime_Loader_AssemblyLoadContext_System_Reflection_AssemblyName_System_Reflection_Assembly_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func add_Resolving(value : @escaping (dotnet.System.Runtime.Loader.AssemblyLoadContext, dotnet.System.Reflection.AssemblyName) throws -> dotnet.System.Reflection.Assembly) throws {
        let del_value = try dotnet.System.Func_3<dotnet.System.Runtime.Loader.AssemblyLoadContext,dotnet.System.Reflection.AssemblyName,dotnet.System.Reflection.Assembly>(value);
        return try add_Resolving(value: del_value);
    }
    // [IsSpecialName] void remove_Resolving(System.Func<System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly>)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.remove_Resolving(System.Func{System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly})
    open func remove_Resolving(value : Optional<dotnet.System.Func_3<dotnet.System.Runtime.Loader.AssemblyLoadContext,dotnet.System.Reflection.AssemblyName,dotnet.System.Reflection.Assembly>>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__remove_Resolving_0__1__System_Func_System_Runtime_Loader_AssemblyLoadContext_System_Reflection_AssemblyName_System_Reflection_Assembly_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func remove_Resolving(value : @escaping (dotnet.System.Runtime.Loader.AssemblyLoadContext, dotnet.System.Reflection.AssemblyName) throws -> dotnet.System.Reflection.Assembly) throws {
        let del_value = try dotnet.System.Func_3<dotnet.System.Runtime.Loader.AssemblyLoadContext,dotnet.System.Reflection.AssemblyName,dotnet.System.Reflection.Assembly>(value);
        return try remove_Resolving(value: del_value);
    }
    // [IsSpecialName] void add_ResolvingUnmanagedDll(System.Func<System.Reflection.Assembly,System.String,System.IntPtr>)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.add_ResolvingUnmanagedDll(System.Func{System.Reflection.Assembly,System.String,System.IntPtr})
    open func add_ResolvingUnmanagedDll(value : Optional<dotnet.System.Func_3<dotnet.System.Reflection.Assembly,dotnet.System.String,dotnet.System.IntPtr>>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__add_ResolvingUnmanagedDll_0__1__System_Func_System_Reflection_Assembly_string_System_IntPtr_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func add_ResolvingUnmanagedDll(value : @escaping (dotnet.System.Reflection.Assembly, dotnet.System.String) throws -> dotnet.System.IntPtr) throws {
        let del_value = try dotnet.System.Func_3<dotnet.System.Reflection.Assembly,dotnet.System.String,dotnet.System.IntPtr>(value);
        return try add_ResolvingUnmanagedDll(value: del_value);
    }
    // [IsSpecialName] void remove_ResolvingUnmanagedDll(System.Func<System.Reflection.Assembly,System.String,System.IntPtr>)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.remove_ResolvingUnmanagedDll(System.Func{System.Reflection.Assembly,System.String,System.IntPtr})
    open func remove_ResolvingUnmanagedDll(value : Optional<dotnet.System.Func_3<dotnet.System.Reflection.Assembly,dotnet.System.String,dotnet.System.IntPtr>>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__remove_ResolvingUnmanagedDll_0__1__System_Func_System_Reflection_Assembly_string_System_IntPtr_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func remove_ResolvingUnmanagedDll(value : @escaping (dotnet.System.Reflection.Assembly, dotnet.System.String) throws -> dotnet.System.IntPtr) throws {
        let del_value = try dotnet.System.Func_3<dotnet.System.Reflection.Assembly,dotnet.System.String,dotnet.System.IntPtr>(value);
        return try remove_ResolvingUnmanagedDll(value: del_value);
    }
    // [IsSpecialName] void add_Unloading(System.Action<System.Runtime.Loader.AssemblyLoadContext>)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.add_Unloading(System.Action{System.Runtime.Loader.AssemblyLoadContext})
    open func add_Unloading(value : Optional<dotnet.System.Action_1<dotnet.System.Runtime.Loader.AssemblyLoadContext>>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__add_Unloading_0__1__System_Action_System_Runtime_Loader_AssemblyLoadContext_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func add_Unloading(value : @escaping (dotnet.System.Runtime.Loader.AssemblyLoadContext) throws -> Void) throws {
        let del_value = try dotnet.System.Action_1<dotnet.System.Runtime.Loader.AssemblyLoadContext>(value);
        return try add_Unloading(value: del_value);
    }
    // [IsSpecialName] void remove_Unloading(System.Action<System.Runtime.Loader.AssemblyLoadContext>)
// docid: M:System.Runtime.Loader.AssemblyLoadContext.remove_Unloading(System.Action{System.Runtime.Loader.AssemblyLoadContext})
    open func remove_Unloading(value : Optional<dotnet.System.Action_1<dotnet.System.Runtime.Loader.AssemblyLoadContext>>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_void__remove_Unloading_0__1__System_Action_System_Runtime_Loader_AssemblyLoadContext_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func remove_Unloading(value : @escaping (dotnet.System.Runtime.Loader.AssemblyLoadContext) throws -> Void) throws {
        let del_value = try dotnet.System.Action_1<dotnet.System.Runtime.Loader.AssemblyLoadContext>(value);
        return try remove_Unloading(value: del_value);
    }
    /**
    Returns a collection of all  instances.

    */
    public static var All : dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Runtime.Loader.AssemblyLoadContext> {
        get {
            return try! get_All();
        }
    }
    /**
    Returns a collection of the  instances loaded in the .

    */
    open var Assemblies : dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Reflection.Assembly> {
        get {
            return try! get_Assemblies();
        }
    }
    /**
    Gets the  set by the most recent call to .

    */
    public static var CurrentContextualReflectionContext : Optional<dotnet.System.Runtime.Loader.AssemblyLoadContext> {
        get {
            return try! get_CurrentContextualReflectionContext();
        }
    }
    /**
    Gets the default . The default context contains the main application assembly and its static dependencies.

    */
    public static var Default : dotnet.System.Runtime.Loader.AssemblyLoadContext {
        get {
            return try! get_Default();
        }
    }
    /**
    Gets a value that indicates whether this  is collectible.

    */
    open var IsCollectible : Bool {
        get {
            return try! get_IsCollectible();
        }
    }
    /**
    Get the name of the .

    */
    open var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
} // AssemblyLoadContext


// type: System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope
// boxed value type
    /**
    Provides a return type used exclusively for . It is intended to be used as an  in a  block.

    */
public final class AssemblyLoadContext_ContextualReflectionScope
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Runtime_Loader_AssemblyLoadContext_ContextualReflectionScope_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Runtime_Loader_AssemblyLoadContext_ContextualReflectionScope_implicit_ctor();
            super.init(hndl: h);
    }
    // void Dispose()
// docid: M:System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope.Dispose
    /**
    Sets  to the value preceding the call to  which returned this instance.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_Loader_AssemblyLoadContext_ContextualReflectionScope_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // AssemblyLoadContext_ContextualReflectionScope


}



// TODO COPE (parm byref pointer): bool TryGetRawMetadata(System.Reflection.Assembly, ref System.Byte*, ref System.Int32)
