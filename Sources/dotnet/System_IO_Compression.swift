// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
// System.IO
// System.IO.Compression
extension System.IO.Compression {
// type: System.IO.Compression.CompressionLevel
    /**
    Specifies values that indicate whether a compression operation emphasizes speed or compression size.

    */
public struct CompressionLevel : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_Compression_CompressionLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.Compression.CompressionLevel Optimal
    /**
    The compression operation should be optimally compressed, even if the operation takes a longer time to complete.

    */
    public static var Optimal : dotnet.System.IO.Compression.CompressionLevel {
        get {
        let __return = dotnet.System.IO.Compression.CompressionLevel(val: System_IO_Compression_CompressionLevel_get_Optimal());
            return __return;
        }
    }
    // static field: System.IO.Compression.CompressionLevel Fastest
    /**
    The compression operation should complete as quickly as possible, even if the resulting file is not optimally compressed.

    */
    public static var Fastest : dotnet.System.IO.Compression.CompressionLevel {
        get {
        let __return = dotnet.System.IO.Compression.CompressionLevel(val: System_IO_Compression_CompressionLevel_get_Fastest());
            return __return;
        }
    }
    // static field: System.IO.Compression.CompressionLevel NoCompression
    /**
    No compression should be performed on the file.

    */
    public static var NoCompression : dotnet.System.IO.Compression.CompressionLevel {
        get {
        let __return = dotnet.System.IO.Compression.CompressionLevel(val: System_IO_Compression_CompressionLevel_get_NoCompression());
            return __return;
        }
    }
    // static field: System.IO.Compression.CompressionLevel SmallestSize
    /**
    The compression operation should create output as small as possible, even if the operation takes a longer time to complete.

    */
    public static var SmallestSize : dotnet.System.IO.Compression.CompressionLevel {
        get {
        let __return = dotnet.System.IO.Compression.CompressionLevel(val: System_IO_Compression_CompressionLevel_get_SmallestSize());
            return __return;
        }
    }
} // CompressionLevel


// type: System.IO.Compression.CompressionMode
    /**
    Specifies whether to compress or decompress the underlying stream.

    */
public struct CompressionMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_Compression_CompressionMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.Compression.CompressionMode Decompress
    /**
    Decompresses the underlying stream.

    */
    public static var Decompress : dotnet.System.IO.Compression.CompressionMode {
        get {
        let __return = dotnet.System.IO.Compression.CompressionMode(val: System_IO_Compression_CompressionMode_get_Decompress());
            return __return;
        }
    }
    // static field: System.IO.Compression.CompressionMode Compress
    /**
    Compresses the underlying stream.

    */
    public static var Compress : dotnet.System.IO.Compression.CompressionMode {
        get {
        let __return = dotnet.System.IO.Compression.CompressionMode(val: System_IO_Compression_CompressionMode_get_Compress());
            return __return;
        }
    }
} // CompressionMode


// type: System.IO.Compression.DeflateStream
    /**
    Provides methods and properties for compressing and decompressing streams by using the Deflate algorithm.

    */
open class DeflateStream
    :
    dotnet.System.IO.Stream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Compression_DeflateStream_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionLevel)
// docid: M:System.IO.Compression.DeflateStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel)
    /**
    Initializes a new instance of the  class by using the specified stream and compression level.

    - Parameter stream: The stream to compress.
    - Parameter compressionLevel: One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.
    */
    public init(stream : dotnet.System.IO.Stream, compressionLevel : dotnet.System.IO.Compression.CompressionLevel) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_DeflateStream_ctor_0__2__Stream_CompressionLevel(&__thrown, stream.get_handle(), compressionLevel.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionLevel, bool)
// docid: M:System.IO.Compression.DeflateStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel,System.Boolean)
    /**
    Initializes a new instance of the  class by using the specified stream and compression level, and optionally leaves the stream open.

    - Parameter stream: The stream to compress.
    - Parameter compressionLevel: One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.
    - Parameter leaveOpen: 
         to leave the stream object open after disposing the  object; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, compressionLevel : dotnet.System.IO.Compression.CompressionLevel, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_DeflateStream_ctor_0__3__Stream_CompressionLevel_bool(&__thrown, stream.get_handle(), compressionLevel.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionMode)
// docid: M:System.IO.Compression.DeflateStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode)
    /**
    Initializes a new instance of the  class by using the specified stream and compression mode.

    - Parameter stream: The stream to compress or decompress.
    - Parameter mode: One of the enumeration values that indicates whether to compress or decompress the stream.
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.CompressionMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_DeflateStream_ctor_0__2__Stream_CompressionMode(&__thrown, stream.get_handle(), mode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionMode, bool)
// docid: M:System.IO.Compression.DeflateStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode,System.Boolean)
    /**
    Initializes a new instance of the  class by using the specified stream and compression mode, and optionally leaves the stream open.

    - Parameter stream: The stream to compress or decompress.
    - Parameter mode: One of the enumeration values that indicates whether to compress or decompress the stream.
    - Parameter leaveOpen: 
         to leave the stream open after disposing the  object; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.CompressionMode, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_DeflateStream_ctor_0__3__Stream_CompressionMode_bool(&__thrown, stream.get_handle(), mode.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Compression.DeflateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read operation. (Consider using the  method instead.)

    - Parameter buffer: The byte array to read the data into.
    - Parameter offset: The byte offset in  at which to begin reading data from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter asyncCallback: An optional asynchronous callback, to be called when the read operation is complete.
    - Parameter asyncState: A user-provided object that distinguishes this particular asynchronous read request from other requests.
    - Returns: An  object that represents the asynchronous read operation, which could still be pending.

    */
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Compression.DeflateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write operation. (Consider using the  method instead.)

    - Parameter buffer: The buffer to write data from.
    - Parameter offset: The byte offset in  to begin writing from.
    - Parameter count: The maximum number of bytes to write.
    - Parameter asyncCallback: An optional asynchronous callback, to be called when the write operation is complete.
    - Parameter asyncState: A user-provided object that distinguishes this particular asynchronous write request from other requests.
    - Returns: An object that represents the asynchronous write operation, which could still be pending.

    */
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // void CopyTo(System.IO.Stream, System.Int32)
// docid: M:System.IO.Compression.DeflateStream.CopyTo(System.IO.Stream,System.Int32)
    /**
    Reads the bytes from the current Deflate stream and writes them to another stream, using a specified buffer size.

    - Parameter destination: The stream to which the contents of the current Deflate stream will be copied.
    - Parameter bufferSize: The size of the buffer. This value must be greater than zero. The default size is 81920.
    */
    open override func CopyTo(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_DeflateStream_void__CopyTo_0__2__Stream_i32(&__thrown, self.get_handle(), destination.get_handle(), bufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task CopyToAsync(System.IO.Stream, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.DeflateStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads the bytes from the current Deflate stream and writes them to another stream, using a specified buffer size.

    - Parameter destination: The stream to which the contents of the current Deflate stream will be copied.
    - Parameter bufferSize: The size, in bytes, of the buffer. This value must be greater than zero. The default size is 81920.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous copy operation.

    */
    open override func CopyToAsync(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_Task__CopyToAsync_0__3__Stream_i32_CancellationToken(&__thrown, self.get_handle(), destination.get_handle(), bufferSize, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.IO.Compression.DeflateStream.DisposeAsync
    /**
    Asynchronously releases the unmanaged resources used by the .

    - Returns: A task that represents the asynchronous dispose operation.

    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.IO.Compression.DeflateStream.EndRead(System.IAsyncResult)
    /**
    Waits for the pending asynchronous read to complete. (Consider using the  method instead.)

    - Parameter asyncResult: The reference to the pending asynchronous request to finish.
    - Returns: The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.  returns 0 only at the end of the stream; otherwise, it blocks until at least one byte is available.

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.IO.Compression.DeflateStream.EndWrite(System.IAsyncResult)
    /**
    Ends an asynchronous write operation. (Consider using the  method instead.)

    - Parameter asyncResult: A reference to the outstanding asynchronous I/O request.
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_DeflateStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.IO.Compression.DeflateStream.Flush
    /**
    The current implementation of this method has no functionality.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_DeflateStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Compression.DeflateStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Asynchronously clears all buffers for this Deflate stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous flush operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Compression.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads a number of decompressed bytes into the specified byte array.

    - Parameter buffer: 
    - Parameter offset: The byte offset in  at which the read bytes will be placed.
    - Parameter count: The maximum number of decompressed bytes to read.
    - Returns: The number of bytes that were read into the byte array.

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Read(System.Span<System.Byte>)
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.DeflateStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current Deflate stream, writes them to a byte array, advances the position within the Deflate stream by the number of bytes read, and monitors cancellation requests.

    - Parameter offset: The byte offset in  at which to begin writing data from the Deflate stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Parameter buffer: 
    - Returns: A task that represents the asynchronous read operation, which wraps the total number of bytes read into the . The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the Deflate stream has been reached.

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.DeflateStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current Deflate stream, writes them to a byte memory range, advances the position within the Deflate stream by the number of bytes read, and monitors cancellation requests.

    - Parameter buffer: The region of memory to write the data into.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous read operation, which wraps the total number of bytes read into the buffer. The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the Deflate stream has been reached.

    */
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.IO.Compression.DeflateStream.ReadByte
    /**
    Reads a byte from the Deflate stream and advances the position within the stream by one byte, or returns -1 if at the end of the Deflate stream.

    - Returns: The unsigned byte cast to an , or -1 if at the end of the stream.

    */
    open override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.IO.Compression.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    This operation is not supported and always throws a .

    - Parameter offset: The location in the stream.
    - Parameter origin: One of the  values.
    - Returns: A long value.

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.IO.Compression.DeflateStream.SetLength(System.Int64)
    /**
    This operation is not supported and always throws a .

    - Parameter value: The length of the stream.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_DeflateStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Compression.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Writes compressed bytes to the underlying stream from the specified byte array.

    - Parameter buffer: 
    - Parameter offset: The byte offset in  from which the bytes will be read.
    - Parameter count: The maximum number of bytes to write.
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_DeflateStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Write(System.ReadOnlySpan<System.Byte>)
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.DeflateStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously writes compressed bytes to the underlying Deflate stream from the specified byte array.

    - Parameter offset: The zero-based byte offset in  from which to begin copying bytes to the Deflate stream.
    - Parameter count: The maximum number of bytes to write.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Parameter buffer: 
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.DeflateStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously writes compressed bytes to the underlying Deflate stream from the specified read-only memory region.

    - Parameter buffer: The region of memory to write data from.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Stream get_BaseStream()
// docid: M:System.IO.Compression.DeflateStream.get_BaseStream
    open func get_BaseStream() throws -> dotnet.System.IO.Stream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_Stream__get_BaseStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Stream(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.IO.Compression.DeflateStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.IO.Compression.DeflateStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.IO.Compression.DeflateStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.IO.Compression.DeflateStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.IO.Compression.DeflateStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_DeflateStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.IO.Compression.DeflateStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_DeflateStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a reference to the underlying stream.

    */
    open var BaseStream : dotnet.System.IO.Stream {
        get {
            return try! get_BaseStream();
        }
    }
    /**
    Gets a value indicating whether the stream supports reading while decompressing a file.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a value indicating whether the stream supports seeking.

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a value indicating whether the stream supports writing.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    This property is not supported and always throws a .

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    This property is not supported and always throws a .

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
} // DeflateStream


// type: System.IO.Compression.GZipStream
    /**
    Provides methods and properties used to compress and decompress streams by using the GZip data format specification.

    */
open class GZipStream
    :
    dotnet.System.IO.Stream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Compression_GZipStream_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionLevel)
// docid: M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel)
    /**
    Initializes a new instance of the  class by using the specified stream and compression level.

    - Parameter stream: The stream to compress.
    - Parameter compressionLevel: One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.
    */
    public init(stream : dotnet.System.IO.Stream, compressionLevel : dotnet.System.IO.Compression.CompressionLevel) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_GZipStream_ctor_0__2__Stream_CompressionLevel(&__thrown, stream.get_handle(), compressionLevel.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionLevel, bool)
// docid: M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel,System.Boolean)
    /**
    Initializes a new instance of the  class by using the specified stream and compression level, and optionally leaves the stream open.

    - Parameter stream: The stream to write the compressed data to.
    - Parameter compressionLevel: One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.
    - Parameter leaveOpen: 
         to leave the stream object open after disposing the  object; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, compressionLevel : dotnet.System.IO.Compression.CompressionLevel, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_GZipStream_ctor_0__3__Stream_CompressionLevel_bool(&__thrown, stream.get_handle(), compressionLevel.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionMode)
// docid: M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode)
    /**
    Initializes a new instance of the  class by using the specified stream and compression mode.

    - Parameter stream: The stream the compressed or decompressed data is written to.
    - Parameter mode: One of the enumeration values that indicates whether to compress or decompress the stream.
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.CompressionMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_GZipStream_ctor_0__2__Stream_CompressionMode(&__thrown, stream.get_handle(), mode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionMode, bool)
// docid: M:System.IO.Compression.GZipStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode,System.Boolean)
    /**
    Initializes a new instance of the  class by using the specified stream and compression mode, and optionally leaves the stream open.

    - Parameter stream: The stream to compress.
    - Parameter mode: One of the enumeration values that indicates whether to compress or decompress the stream.
    - Parameter leaveOpen: 
         to leave the stream open after disposing the  object; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.CompressionMode, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_GZipStream_ctor_0__3__Stream_CompressionMode_bool(&__thrown, stream.get_handle(), mode.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Compression.GZipStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read operation. (Consider using the  method instead.)

    - Parameter buffer: The byte array to read the data into.
    - Parameter offset: The byte offset in  at which to begin reading data from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter asyncCallback: An optional asynchronous callback, to be called when the read operation is complete.
    - Parameter asyncState: A user-provided object that distinguishes this particular asynchronous read request from other requests.
    - Returns: An object that represents the asynchronous read operation, which could still be pending.

    */
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Compression.GZipStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write operation. (Consider using the  method instead.)

    - Parameter buffer: The buffer containing data to write to the current stream.
    - Parameter offset: The byte offset in  at which to begin writing.
    - Parameter count: The maximum number of bytes to write.
    - Parameter asyncCallback: An optional asynchronous callback to be called when the write operation is complete.
    - Parameter asyncState: A user-provided object that distinguishes this particular asynchronous write request from other requests.
    - Returns: An  object that represents the asynchronous write operation, which could still be pending.

    */
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // void CopyTo(System.IO.Stream, System.Int32)
// docid: M:System.IO.Compression.GZipStream.CopyTo(System.IO.Stream,System.Int32)
    /**
    Reads the bytes from the current GZip stream and writes them to another stream, using a specified buffer size.

    - Parameter destination: The stream to which the contents of the current GZip stream will be copied.
    - Parameter bufferSize: The size of the buffer. This value must be greater than zero. The default size is 81920.
    */
    open override func CopyTo(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_GZipStream_void__CopyTo_0__2__Stream_i32(&__thrown, self.get_handle(), destination.get_handle(), bufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task CopyToAsync(System.IO.Stream, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.GZipStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads the bytes from the current GZip stream and writes them to another stream, using a specified buffer size.

    - Parameter destination: The stream to which the contents of the current GZip stream will be copied.
    - Parameter bufferSize: The size, in bytes, of the buffer. This value must be greater than zero. The default size is 81920.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous copy operation.

    */
    open override func CopyToAsync(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_Task__CopyToAsync_0__3__Stream_i32_CancellationToken(&__thrown, self.get_handle(), destination.get_handle(), bufferSize, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.IO.Compression.GZipStream.DisposeAsync
    /**
    Asynchronously releases the unmanaged resources used by the .

    - Returns: A task that represents the asynchronous dispose operation.

    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.IO.Compression.GZipStream.EndRead(System.IAsyncResult)
    /**
    Waits for the pending asynchronous read to complete. (Consider using the  method instead.)

    - Parameter asyncResult: The reference to the pending asynchronous request to finish.
    - Returns: The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.  returns 0 only at the end of the stream; otherwise, it blocks until at least one byte is available.

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.IO.Compression.GZipStream.EndWrite(System.IAsyncResult)
    /**
    Handles the end of an asynchronous write operation. (Consider using the  method instead.)

    - Parameter asyncResult: The object that represents the asynchronous call.
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_GZipStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.IO.Compression.GZipStream.Flush
    /**
    Flushes the internal buffers.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_GZipStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Compression.GZipStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Asynchronously clears all buffers for this GZip stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous flush operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Compression.GZipStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads a number of decompressed bytes into the specified byte array.

    - Parameter buffer: 
    - Parameter offset: The byte offset in  at which the read bytes will be placed.
    - Parameter count: The maximum number of decompressed bytes to read.
    - Returns: The number of bytes that were decompressed into the byte array. If the end of the stream has been reached, zero or the number of bytes read is returned.

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Read(System.Span<System.Byte>)
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.GZipStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current GZip stream into a byte array, advances the position within the GZip stream by the number of bytes read, and monitors cancellation requests.

    - Parameter offset: The byte offset in  at which to begin writing data from the GZip stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Parameter buffer: 
    - Returns: A task that represents the asynchronous read operation, which wraps the total number of bytes read into the . The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the GZip stream has been reached.

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.GZipStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current GZip stream into a byte memory region, advances the position within the GZip stream by the number of bytes read, and monitors cancellation requests.

    - Parameter buffer: The region of memory to write the data into.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous read operation, which wraps the total number of bytes read into the buffer. The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the GZip stream has been reached.

    */
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.IO.Compression.GZipStream.ReadByte
    /**
    Reads a byte from the GZip stream and advances the position within the stream by one byte, or returns -1 if at the end of the GZip stream.

    - Returns: The unsigned byte cast to an , or -1 if at the end of the stream.

    */
    open override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.IO.Compression.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    This property is not supported and always throws a .

    - Parameter offset: The location in the stream.
    - Parameter origin: One of the  values.
    - Returns: A long value.

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.IO.Compression.GZipStream.SetLength(System.Int64)
    /**
    This property is not supported and always throws a .

    - Parameter value: The length of the stream.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_GZipStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Compression.GZipStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Writes compressed bytes to the underlying GZip stream from the specified byte array.

    - Parameter buffer: 
    - Parameter offset: The byte offset in  from which the bytes will be read.
    - Parameter count: The maximum number of bytes to write.
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_GZipStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Write(System.ReadOnlySpan<System.Byte>)
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.GZipStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously writes compressed bytes to the underlying GZip stream from the specified byte array.

    - Parameter offset: The zero-based byte offset in  from which to begin copying bytes to the GZip stream.
    - Parameter count: The maximum number of bytes to write.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Parameter buffer: 
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.GZipStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously writes compressed bytes to the underlying GZip stream from the specified read-only byte memory region.

    - Parameter buffer: The region of memory to write data from.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Stream get_BaseStream()
// docid: M:System.IO.Compression.GZipStream.get_BaseStream
    open func get_BaseStream() throws -> dotnet.System.IO.Stream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_Stream__get_BaseStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Stream(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.IO.Compression.GZipStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.IO.Compression.GZipStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.IO.Compression.GZipStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.IO.Compression.GZipStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.IO.Compression.GZipStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_GZipStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.IO.Compression.GZipStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_GZipStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a reference to the underlying stream.

    */
    open var BaseStream : dotnet.System.IO.Stream {
        get {
            return try! get_BaseStream();
        }
    }
    /**
    Gets a value indicating whether the stream supports reading while decompressing a file.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a value indicating whether the stream supports seeking.

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a value indicating whether the stream supports writing.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    This property is not supported and always throws a .

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    This property is not supported and always throws a .

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
} // GZipStream


// type: System.IO.Compression.ZLibStream
    /**
    Provides methods and properties used to compress and decompress streams by using the zlib data format specification.

    */
public final class ZLibStream
    :
    dotnet.System.IO.Stream
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Compression_ZLibStream_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionLevel)
// docid: M:System.IO.Compression.ZLibStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel)
    /**
    Initializes a new instance of the  class by using the specified stream and compression level.

    - Parameter stream: The stream to which compressed data is written.
    - Parameter compressionLevel: One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.
    */
    public init(stream : dotnet.System.IO.Stream, compressionLevel : dotnet.System.IO.Compression.CompressionLevel) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZLibStream_ctor_0__2__Stream_CompressionLevel(&__thrown, stream.get_handle(), compressionLevel.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionLevel, bool)
// docid: M:System.IO.Compression.ZLibStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionLevel,System.Boolean)
    /**
    Initializes a new instance of the  class by using the specified stream, compression level, and whether to leave the  open.

    - Parameter stream: The stream to which compressed data is written.
    - Parameter compressionLevel: One of the enumeration values that indicates whether to emphasize speed or compression efficiency when compressing the stream.
    - Parameter leaveOpen: 
         to leave the stream object open after disposing the  object; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, compressionLevel : dotnet.System.IO.Compression.CompressionLevel, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZLibStream_ctor_0__3__Stream_CompressionLevel_bool(&__thrown, stream.get_handle(), compressionLevel.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionMode)
// docid: M:System.IO.Compression.ZLibStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode)
    /**
    Initializes a new instance of the  class by using the specified stream and compression mode.

    - Parameter stream: The stream to which compressed data is written or from which decompressed data is read.
    - Parameter mode: One of the enumeration values that indicates whether to compress or decompress the stream.
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.CompressionMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZLibStream_ctor_0__2__Stream_CompressionMode(&__thrown, stream.get_handle(), mode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.CompressionMode, bool)
// docid: M:System.IO.Compression.ZLibStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode,System.Boolean)
    /**
    Initializes a new instance of the  class by using the specified stream, compression mode, and whether to leave the  open.

    - Parameter stream: The stream to which compressed data is written or from which decompressed data is read.
    - Parameter mode: One of the enumeration values that indicates whether to compress or decompress the stream.
    - Parameter leaveOpen: 
         to leave the stream object open after disposing the  object; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.CompressionMode, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZLibStream_ctor_0__3__Stream_CompressionMode_bool(&__thrown, stream.get_handle(), mode.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Compression.ZLibStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read operation.

    - Parameter buffer: The byte array to read the data into.
    - Parameter offset: The byte offset in  at which to begin reading data from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter asyncCallback: An optional asynchronous callback, to be called when the read operation is complete.
    - Parameter asyncState: A user-provided object that distinguishes this particular asynchronous read request from other requests.
    - Returns: An object that represents the asynchronous read operation, which could still be pending.

    */
    public func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    public func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Compression.ZLibStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write operation.

    - Parameter buffer: The buffer to write data from.
    - Parameter offset: The byte offset in  to begin writing from.
    - Parameter count: The maximum number of bytes to write.
    - Parameter asyncCallback: An optional asynchronous callback, to be called when the write operation is complete.
    - Parameter asyncState: A user-provided object that distinguishes this particular asynchronous write request from other requests.
    - Returns: An object that represents the asynchronous write operation, which could still be pending.

    */
    public func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    public func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // void CopyTo(System.IO.Stream, System.Int32)
// docid: M:System.IO.Compression.ZLibStream.CopyTo(System.IO.Stream,System.Int32)
    /**
    Reads the bytes from the current stream and writes them to another stream, using the specified buffer size.

    - Parameter destination: The stream to which the contents of the current stream will be copied.
    - Parameter bufferSize: The size of the buffer. This value must be greater than zero.
    */
    public override func CopyTo(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZLibStream_void__CopyTo_0__2__Stream_i32(&__thrown, self.get_handle(), destination.get_handle(), bufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task CopyToAsync(System.IO.Stream, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.ZLibStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.

    - Parameter destination: The stream to which the contents of the current stream will be copied.
    - Parameter bufferSize: The size, in bytes, of the buffer. This value must be greater than zero.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous copy operation.

    */
    public override func CopyToAsync(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_Task__CopyToAsync_0__3__Stream_i32_CancellationToken(&__thrown, self.get_handle(), destination.get_handle(), bufferSize, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.IO.Compression.ZLibStream.DisposeAsync
    /**
    Asynchronously releases all resources used by the stream.

    - Returns: A task that represents the completion of the disposal operation.

    */
    public override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.IO.Compression.ZLibStream.EndRead(System.IAsyncResult)
    /**
    Waits for the pending asynchronous read to complete.

    - Parameter asyncResult: The reference to the pending asynchronous request to finish.
    - Returns: The number of bytes that were read into the byte array.

    */
    public override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.IO.Compression.ZLibStream.EndWrite(System.IAsyncResult)
    /**
    Ends an asynchronous write operation.

    - Parameter asyncResult: The reference to the pending asynchronous request to finish.
    */
    public override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZLibStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.IO.Compression.ZLibStream.Flush
    /**
    Flushes the internal buffers.

    */
    public override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZLibStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Compression.ZLibStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous flush operation.

    */
    public override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Compression.ZLibStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads a number of decompressed bytes into the specified byte array.

    - Parameter buffer: The byte array to read the data into.
    - Parameter offset: The byte offset in array at which to begin reading data from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Returns: The number of bytes that were read into the byte array.

    */
    public override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Read(System.Span<System.Byte>)
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.ZLibStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.

    - Parameter buffer: The byte array to read the data into.
    - Parameter offset: The byte offset in array at which to begin reading data from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous completion of the operation.

    */
    public override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.ZLibStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.

    - Parameter buffer: The byte span to read the data into.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous completion of the operation.

    */
    public override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.IO.Compression.ZLibStream.ReadByte
    /**
    Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.

    - Returns: The unsigned byte cast to an , or -1 if at the end of the stream.

    */
    public override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.IO.Compression.ZLibStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    This method is not supported and always throws a .

    - Parameter offset: Not supported.
    - Parameter origin: Not supported.
    - Returns: This method is not supported and always throws a .

    */
    public override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.IO.Compression.ZLibStream.SetLength(System.Int64)
    /**
    This method is not supported and always throws a .

    - Parameter value: Not supported.
    */
    public override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZLibStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Compression.ZLibStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Writes compressed bytes to the underlying stream from the specified byte array.

    - Parameter buffer: The buffer to write data from.
    - Parameter offset: The byte offset in buffer to begin writing from.
    - Parameter count: The maximum number of bytes to write.
    */
    public override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZLibStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Write(System.ReadOnlySpan<System.Byte>)
    // void WriteByte(System.Byte)
// docid: M:System.IO.Compression.ZLibStream.WriteByte(System.Byte)
    /**
    Writes a byte to the current position in the stream and advances the position within the stream by one byte.

    - Parameter value: The byte to write to the stream.
    */
    public override func WriteByte(value : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZLibStream_void__WriteByte_0__1__u8(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.ZLibStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.

    - Parameter buffer: The buffer to write data from.
    - Parameter offset: The byte offset in buffer to begin writing from.
    - Parameter count: The maximum number of bytes to write.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous completion of the operation.

    */
    public override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Compression.ZLibStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.

    - Parameter buffer: The buffer to write data from.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous completion of the operation.

    */
    public override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Stream get_BaseStream()
// docid: M:System.IO.Compression.ZLibStream.get_BaseStream
    public func get_BaseStream() throws -> dotnet.System.IO.Stream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_Stream__get_BaseStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Stream(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.IO.Compression.ZLibStream.get_CanRead
    public override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.IO.Compression.ZLibStream.get_CanSeek
    public override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.IO.Compression.ZLibStream.get_CanWrite
    public override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.IO.Compression.ZLibStream.get_Length
    public override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.IO.Compression.ZLibStream.get_Position
    public override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZLibStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.IO.Compression.ZLibStream.set_Position(System.Int64)
    public override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZLibStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a reference to the underlying stream.

    */
    public var BaseStream : dotnet.System.IO.Stream {
        get {
            return try! get_BaseStream();
        }
    }
    /**
    Gets a value indicating whether the stream supports reading.

    */
    public override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a value indicating whether the stream supports seeking.

    */
    public override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a value indicating whether the stream supports writing.

    */
    public override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    This property is not supported and always throws a .

    */
    public override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    This property is not supported and always throws a .

    */
    public override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
} // ZLibStream


// type: System.IO.Compression.ZipArchive
    /**
    Represents a package of compressed files in the zip archive format.

    */
open class ZipArchive
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Compression_ZipArchive_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Stream)
// docid: M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream)
    /**
    Initializes a new instance of the  class from the specified stream.

    - Parameter stream: The stream that contains the archive to be read.
    */
    public init(stream : dotnet.System.IO.Stream) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZipArchive_ctor_0__1__Stream(&__thrown, stream.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.ZipArchiveMode)
// docid: M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode)
    /**
    Initializes a new instance of the  class from the specified stream and with the specified mode.

    - Parameter stream: The input or output stream.
    - Parameter mode: One of the enumeration values that indicates whether the zip archive is used to read, create, or update entries.
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.ZipArchiveMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZipArchive_ctor_0__2__Stream_ZipArchiveMode(&__thrown, stream.get_handle(), mode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.ZipArchiveMode, bool)
// docid: M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode,System.Boolean)
    /**
    Initializes a new instance of the  class on the specified stream for the specified mode, and optionally leaves the stream open.

    - Parameter stream: The input or output stream.
    - Parameter mode: One of the enumeration values that indicates whether the zip archive is used to read, create, or update entries.
    - Parameter leaveOpen: 
         to leave the stream open after the  object is disposed; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.ZipArchiveMode, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZipArchive_ctor_0__3__Stream_ZipArchiveMode_bool(&__thrown, stream.get_handle(), mode.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.IO.Compression.ZipArchiveMode, bool, System.Text.Encoding)
// docid: M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode,System.Boolean,System.Text.Encoding)
    /**
    Initializes a new instance of the  class on the specified stream for the specified mode, uses the specified encoding for entry names, and optionally leaves the stream open.

    - Parameter stream: The input or output stream.
    - Parameter mode: One of the enumeration values that indicates whether the zip archive is used to read, create, or update entries.
    - Parameter leaveOpen: 
         to leave the stream open after the  object is disposed; otherwise, .
    - Parameter entryNameEncoding: The encoding to use when reading or writing entry names in this archive. Specify a value for this parameter only when an encoding is required for interoperability with zip archive tools and libraries that do not support UTF-8 encoding for entry names.
    */
    public init(stream : dotnet.System.IO.Stream, mode : dotnet.System.IO.Compression.ZipArchiveMode, leaveOpen : Bool, entryNameEncoding : Optional<dotnet.System.Text.Encoding>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Compression_ZipArchive_ctor_0__4__Stream_ZipArchiveMode_bool_Encoding(&__thrown, stream.get_handle(), mode.get_value(), Swift.Int32(leaveOpen ? 1 : 0), entryNameEncoding?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IO.Compression.ZipArchiveEntry CreateEntry(System.String)
// docid: M:System.IO.Compression.ZipArchive.CreateEntry(System.String)
    /**
    Creates an empty entry that has the specified path and entry name in the zip archive.

    - Parameter entryName: A path, relative to the root of the archive, that specifies the name of the entry to be created.
    - Returns: An empty entry in the zip archive.

    */
    open func CreateEntry(entryName : dotnet.System.String) throws -> dotnet.System.IO.Compression.ZipArchiveEntry {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchive_ZipArchiveEntry__CreateEntry_0__1__String(&__thrown, self.get_handle(), entryName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Compression.ZipArchiveEntry(hndl : __return);
        }
    }
    // System.IO.Compression.ZipArchiveEntry CreateEntry(System.String, System.IO.Compression.CompressionLevel)
// docid: M:System.IO.Compression.ZipArchive.CreateEntry(System.String,System.IO.Compression.CompressionLevel)
    /**
    Creates an empty entry that has the specified entry name and compression level in the zip archive.

    - Parameter entryName: A path, relative to the root of the archive, that specifies the name of the entry to be created.
    - Parameter compressionLevel: One of the enumeration values that indicates whether to emphasize speed or compression effectiveness when creating the entry.
    - Returns: An empty entry in the zip archive.

    */
    open func CreateEntry(entryName : dotnet.System.String, compressionLevel : dotnet.System.IO.Compression.CompressionLevel) throws -> dotnet.System.IO.Compression.ZipArchiveEntry {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchive_ZipArchiveEntry__CreateEntry_0__2__String_CompressionLevel(&__thrown, self.get_handle(), entryName.get_handle(), compressionLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Compression.ZipArchiveEntry(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.IO.Compression.ZipArchive.Dispose
    /**
    Releases the resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZipArchive_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IO.Compression.ZipArchiveEntry GetEntry(System.String)
// docid: M:System.IO.Compression.ZipArchive.GetEntry(System.String)
    /**
    Retrieves a wrapper for the specified entry in the zip archive.

    - Parameter entryName: A path, relative to the root of the archive, that identifies the entry to retrieve.
    - Returns: A wrapper for the specified entry in the archive;  if the entry does not exist in the archive.

    */
    open func GetEntry(entryName : dotnet.System.String) throws -> Optional<dotnet.System.IO.Compression.ZipArchiveEntry> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchive_ZipArchiveEntry__GetEntry_0__1__String(&__thrown, self.get_handle(), entryName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IO.Compression.ZipArchiveEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.ObjectModel.ReadOnlyCollection<System.IO.Compression.ZipArchiveEntry> get_Entries()
// docid: M:System.IO.Compression.ZipArchive.get_Entries
    open func get_Entries() throws -> dotnet.System.Collections.ObjectModel.ReadOnlyCollection_1<dotnet.System.IO.Compression.ZipArchiveEntry> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchive_System_Collections_ObjectModel_ReadOnlyCollection_System_IO_Compression_ZipArchiveEntry___get_Entries_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.ObjectModel.ReadOnlyCollection_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Compression.ZipArchiveMode get_Mode()
// docid: M:System.IO.Compression.ZipArchive.get_Mode
    open func get_Mode() throws -> dotnet.System.IO.Compression.ZipArchiveMode {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchive_ZipArchiveMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Compression.ZipArchiveMode(val: __return);
        }
    }
    /**
    Gets the collection of entries that are currently in the zip archive.

    */
    open var Entries : dotnet.System.Collections.ObjectModel.ReadOnlyCollection_1<dotnet.System.IO.Compression.ZipArchiveEntry> {
        get {
            return try! get_Entries();
        }
    }
    /**
    Gets a value that describes the type of action the zip archive can perform on entries.

    */
    open var Mode : dotnet.System.IO.Compression.ZipArchiveMode {
        get {
            return try! get_Mode();
        }
    }
} // ZipArchive


// type: System.IO.Compression.ZipArchiveEntry
    /**
    Represents a compressed file within a zip archive.

    */
open class ZipArchiveEntry
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Compression_ZipArchiveEntry_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Delete()
// docid: M:System.IO.Compression.ZipArchiveEntry.Delete
    /**
    Deletes the entry from the zip archive.

    */
    open func Delete() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZipArchiveEntry_void__Delete_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IO.Stream Open()
// docid: M:System.IO.Compression.ZipArchiveEntry.Open
    /**
    Opens the entry from the zip archive.

    - Returns: The stream that represents the contents of the entry.

    */
    open func Open() throws -> dotnet.System.IO.Stream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_Stream__Open_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Stream(hndl : __return);
        }
    }
    // System.String ToString()
// docid: M:System.IO.Compression.ZipArchiveEntry.ToString
    /**
    Retrieves the relative path of the entry in the zip archive.

    - Returns: The relative path of the entry, which is the value stored in the  property.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Compression.ZipArchive get_Archive()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_Archive
    open func get_Archive() throws -> dotnet.System.IO.Compression.ZipArchive {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_ZipArchive__get_Archive_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Compression.ZipArchive(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_CompressedLength()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_CompressedLength
    open func get_CompressedLength() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_i64__get_CompressedLength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.UInt32 get_Crc32()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_Crc32
    open func get_Crc32() throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_u32__get_Crc32_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_ExternalAttributes()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_ExternalAttributes
    open func get_ExternalAttributes() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_i32__get_ExternalAttributes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ExternalAttributes(System.Int32)
// docid: M:System.IO.Compression.ZipArchiveEntry.set_ExternalAttributes(System.Int32)
    open func set_ExternalAttributes(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZipArchiveEntry_void__set_ExternalAttributes_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_FullName()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_FullName
    open func get_FullName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_String__get_FullName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_LastWriteTime()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_LastWriteTime
    open func get_LastWriteTime() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_DateTimeOffset__get_LastWriteTime_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] void set_LastWriteTime(System.DateTimeOffset)
// docid: M:System.IO.Compression.ZipArchiveEntry.set_LastWriteTime(System.DateTimeOffset)
    open func set_LastWriteTime(value : dotnet.System.DateTimeOffset) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Compression_ZipArchiveEntry_void__set_LastWriteTime_0__1__DateTimeOffset(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_Length
    open func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.IO.Compression.ZipArchiveEntry.get_Name
    open func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Compression_ZipArchiveEntry_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the zip archive that the entry belongs to.

    */
    open var Archive : dotnet.System.IO.Compression.ZipArchive {
        get {
            return try! get_Archive();
        }
    }
    /**
    Gets the compressed size of the entry in the zip archive.

    */
    open var CompressedLength : Swift.Int64 {
        get {
            return try! get_CompressedLength();
        }
    }
    /**
    The 32-bit Cyclic Redundant Check.

    */
    open var Crc32 : Swift.UInt32 {
        get {
            return try! get_Crc32();
        }
    }
    /**
    OS and application specific file attributes.

    */
    open var ExternalAttributes : Swift.Int32 {
        get {
            return try! get_ExternalAttributes();
        }
        set(v) {
            return try! set_ExternalAttributes(value: v);
        }
    }
    /**
    Gets the relative path of the entry in the zip archive.

    */
    open var FullName : dotnet.System.String {
        get {
            return try! get_FullName();
        }
    }
    /**
    Gets or sets the last time the entry in the zip archive was changed.

    */
    open var LastWriteTime : dotnet.System.DateTimeOffset {
        get {
            return try! get_LastWriteTime();
        }
        set(v) {
            return try! set_LastWriteTime(value: v);
        }
    }
    /**
    Gets the uncompressed size of the entry in the zip archive.

    */
    open var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets the file name of the entry in the zip archive.

    */
    open var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
    }
} // ZipArchiveEntry


// type: System.IO.Compression.ZipArchiveMode
    /**
    Specifies values for interacting with zip archive entries.

    */
public struct ZipArchiveMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_Compression_ZipArchiveMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.Compression.ZipArchiveMode Read
    /**
    Only reading archive entries is permitted.

    */
    public static var Read : dotnet.System.IO.Compression.ZipArchiveMode {
        get {
        let __return = dotnet.System.IO.Compression.ZipArchiveMode(val: System_IO_Compression_ZipArchiveMode_get_Read());
            return __return;
        }
    }
    // static field: System.IO.Compression.ZipArchiveMode Create
    /**
    Only creating new archive entries is permitted.

    */
    public static var Create : dotnet.System.IO.Compression.ZipArchiveMode {
        get {
        let __return = dotnet.System.IO.Compression.ZipArchiveMode(val: System_IO_Compression_ZipArchiveMode_get_Create());
            return __return;
        }
    }
    // static field: System.IO.Compression.ZipArchiveMode Update
    /**
    Both read and write operations are permitted for archive entries.

    */
    public static var Update : dotnet.System.IO.Compression.ZipArchiveMode {
        get {
        let __return = dotnet.System.IO.Compression.ZipArchiveMode(val: System_IO_Compression_ZipArchiveMode_get_Update());
            return __return;
        }
    }
} // ZipArchiveMode


}



