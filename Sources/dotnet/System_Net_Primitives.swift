// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
// System.Net
extension System.Net {
// type: System.Net.AuthenticationSchemes
    /**
    Specifies protocols for authentication.

    */
public struct AuthenticationSchemes : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_AuthenticationSchemes_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.AuthenticationSchemes None
    /**
    No authentication is allowed. A client requesting an  object with this flag set will always receive a 403 Forbidden status. Use this flag when a resource should never be served to a client.

    */
    public static var None : dotnet.System.Net.AuthenticationSchemes {
        get {
        let __return = dotnet.System.Net.AuthenticationSchemes(val: System_Net_AuthenticationSchemes_get_None());
            return __return;
        }
    }
    // static field: System.Net.AuthenticationSchemes Digest
    /**
    Specifies digest authentication.

    */
    public static var Digest : dotnet.System.Net.AuthenticationSchemes {
        get {
        let __return = dotnet.System.Net.AuthenticationSchemes(val: System_Net_AuthenticationSchemes_get_Digest());
            return __return;
        }
    }
    // static field: System.Net.AuthenticationSchemes Negotiate
    /**
    Negotiates with the client to determine the authentication scheme. If both client and server support Kerberos, it is used; otherwise, NTLM is used.

    */
    public static var Negotiate : dotnet.System.Net.AuthenticationSchemes {
        get {
        let __return = dotnet.System.Net.AuthenticationSchemes(val: System_Net_AuthenticationSchemes_get_Negotiate());
            return __return;
        }
    }
    // static field: System.Net.AuthenticationSchemes Ntlm
    /**
    Specifies NTLM authentication.

    */
    public static var Ntlm : dotnet.System.Net.AuthenticationSchemes {
        get {
        let __return = dotnet.System.Net.AuthenticationSchemes(val: System_Net_AuthenticationSchemes_get_Ntlm());
            return __return;
        }
    }
    // static field: System.Net.AuthenticationSchemes IntegratedWindowsAuthentication
    /**
    Specifies Windows authentication.

    */
    public static var IntegratedWindowsAuthentication : dotnet.System.Net.AuthenticationSchemes {
        get {
        let __return = dotnet.System.Net.AuthenticationSchemes(val: System_Net_AuthenticationSchemes_get_IntegratedWindowsAuthentication());
            return __return;
        }
    }
    // static field: System.Net.AuthenticationSchemes Basic
    /**
    Specifies basic authentication.

    */
    public static var Basic : dotnet.System.Net.AuthenticationSchemes {
        get {
        let __return = dotnet.System.Net.AuthenticationSchemes(val: System_Net_AuthenticationSchemes_get_Basic());
            return __return;
        }
    }
    // static field: System.Net.AuthenticationSchemes Anonymous
    /**
    Specifies anonymous authentication.

    */
    public static var Anonymous : dotnet.System.Net.AuthenticationSchemes {
        get {
        let __return = dotnet.System.Net.AuthenticationSchemes(val: System_Net_AuthenticationSchemes_get_Anonymous());
            return __return;
        }
    }
} // AuthenticationSchemes


// type: System.Net.Cookie
    /**
    Provides a set of properties and methods that are used to manage cookies. This class cannot be inherited.

    */
public final class Cookie
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Cookie_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.Cookie.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Cookie_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String)
// docid: M:System.Net.Cookie.#ctor(System.String,System.String)
    /**
    Initializes a new instance of the  class with a specified  and .

    - Parameter name: The name of a . The following characters must not be used inside : equal sign, semicolon, comma, newline (\n), return (\r), tab (\t), and space character. The dollar sign character ("$") cannot be the first character.
    - Parameter value: The value of a . The following characters must not be used inside : semicolon, comma.
    */
    public init(name : dotnet.System.String, value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Cookie_ctor_0__2__String_String(&__thrown, name.get_handle(), value?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.String)
// docid: M:System.Net.Cookie.#ctor(System.String,System.String,System.String)
    /**
    Initializes a new instance of the  class with a specified , , and .

    - Parameter name: The name of a . The following characters must not be used inside : equal sign, semicolon, comma, newline (\n), return (\r), tab (\t), and space character. The dollar sign character ("$") cannot be the first character.
    - Parameter value: The value of a . The following characters must not be used inside : semicolon, comma.
    - Parameter path: The subset of URIs on the origin server to which this  applies. The default value is "/".
    */
    public init(name : dotnet.System.String, value : Optional<dotnet.System.String>, path : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Cookie_ctor_0__3__String_String_String(&__thrown, name.get_handle(), value?.get_handle() ?? nil, path?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.String, System.String)
// docid: M:System.Net.Cookie.#ctor(System.String,System.String,System.String,System.String)
    /**
    Initializes a new instance of the  class with a specified , , , and .

    - Parameter name: The name of a . The following characters must not be used inside : equal sign, semicolon, comma, newline (\n), return (\r), tab (\t), and space character. The dollar sign character ("$") cannot be the first character.
    - Parameter value: The value of a  object. The following characters must not be used inside : semicolon, comma.
    - Parameter path: The subset of URIs on the origin server to which this  applies. The default value is "/".
    - Parameter domain: The optional internet domain for which this  is valid. The default value is the host this  has been received from.
    */
    public init(name : dotnet.System.String, value : Optional<dotnet.System.String>, path : Optional<dotnet.System.String>, domain : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Cookie_ctor_0__4__String_String_String_String(&__thrown, name.get_handle(), value?.get_handle() ?? nil, path?.get_handle() ?? nil, domain?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Net.Cookie.Equals(System.Object)
    /**
    Overrides the  method.

    - Parameter comparand: A reference to a .
    - Returns: Returns  if the  is equal to . Two  instances are equal if their , , , , and  properties are equal.  and  string comparisons are case-insensitive.

    */
    public func Equals(comparand : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_bool__Equals_0__1__Object(&__thrown, self.get_handle(), comparand?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.Cookie.GetHashCode
    /**
    Overrides the  method.

    - Returns: The 32-bit signed integer hash code for this instance.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.String ToString()
// docid: M:System.Net.Cookie.ToString
    /**
    Overrides the  method.

    - Returns: Returns a string representation of this  object that is suitable for including in a HTTP Cookie: request header.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Comment()
// docid: M:System.Net.Cookie.get_Comment
    public func get_Comment() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_String__get_Comment_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Comment(System.String)
// docid: M:System.Net.Cookie.set_Comment(System.String)
    public func set_Comment(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Comment_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Uri get_CommentUri()
// docid: M:System.Net.Cookie.get_CommentUri
    public func get_CommentUri() throws -> Optional<dotnet.System.Uri> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_Uri__get_CommentUri_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Uri(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_CommentUri(System.Uri)
// docid: M:System.Net.Cookie.set_CommentUri(System.Uri)
    public func set_CommentUri(value : Optional<dotnet.System.Uri>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_CommentUri_0__1__Uri(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_Discard()
// docid: M:System.Net.Cookie.get_Discard
    public func get_Discard() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_bool__get_Discard_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Discard(bool)
// docid: M:System.Net.Cookie.set_Discard(System.Boolean)
    public func set_Discard(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Discard_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Domain()
// docid: M:System.Net.Cookie.get_Domain
    public func get_Domain() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_String__get_Domain_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Domain(System.String)
// docid: M:System.Net.Cookie.set_Domain(System.String)
    public func set_Domain(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Domain_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_Expired()
// docid: M:System.Net.Cookie.get_Expired
    public func get_Expired() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_bool__get_Expired_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Expired(bool)
// docid: M:System.Net.Cookie.set_Expired(System.Boolean)
    public func set_Expired(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Expired_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.DateTime get_Expires()
// docid: M:System.Net.Cookie.get_Expires
    public func get_Expires() throws -> dotnet.System.DateTime {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_DateTime__get_Expires_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTime(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Expires(System.DateTime)
// docid: M:System.Net.Cookie.set_Expires(System.DateTime)
    public func set_Expires(value : dotnet.System.DateTime) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Expires_0__1__DateTime(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_HttpOnly()
// docid: M:System.Net.Cookie.get_HttpOnly
    public func get_HttpOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_bool__get_HttpOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_HttpOnly(bool)
// docid: M:System.Net.Cookie.set_HttpOnly(System.Boolean)
    public func set_HttpOnly(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_HttpOnly_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Net.Cookie.get_Name
    public func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Name(System.String)
// docid: M:System.Net.Cookie.set_Name(System.String)
    public func set_Name(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Name_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Path()
// docid: M:System.Net.Cookie.get_Path
    public func get_Path() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_String__get_Path_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Path(System.String)
// docid: M:System.Net.Cookie.set_Path(System.String)
    public func set_Path(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Path_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Port()
// docid: M:System.Net.Cookie.get_Port
    public func get_Port() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_String__get_Port_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Port(System.String)
// docid: M:System.Net.Cookie.set_Port(System.String)
    public func set_Port(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Port_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_Secure()
// docid: M:System.Net.Cookie.get_Secure
    public func get_Secure() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_bool__get_Secure_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Secure(bool)
// docid: M:System.Net.Cookie.set_Secure(System.Boolean)
    public func set_Secure(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Secure_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.DateTime get_TimeStamp()
// docid: M:System.Net.Cookie.get_TimeStamp
    public func get_TimeStamp() throws -> dotnet.System.DateTime {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_DateTime__get_TimeStamp_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTime(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Value()
// docid: M:System.Net.Cookie.get_Value
    public func get_Value() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_String__get_Value_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Value(System.String)
// docid: M:System.Net.Cookie.set_Value(System.String)
    public func set_Value(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Value_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Version()
// docid: M:System.Net.Cookie.get_Version
    public func get_Version() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cookie_i32__get_Version_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Version(System.Int32)
// docid: M:System.Net.Cookie.set_Version(System.Int32)
    public func set_Version(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Cookie_void__set_Version_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets a comment that the server can add to a .

    */
    public var Comment : dotnet.System.String {
        get {
            return try! get_Comment();
        }
        set(v) {
            return try! set_Comment(value: v);
        }
    }
    /**
    Gets or sets a URI comment that the server can provide with a .

    */
    public var CommentUri : Optional<dotnet.System.Uri> {
        get {
            return try! get_CommentUri();
        }
        set(v) {
            return try! set_CommentUri(value: v!);
        }
    }
    /**
    Gets or sets the discard flag set by the server.

    */
    public var Discard : Bool {
        get {
            return try! get_Discard();
        }
        set(v) {
            return try! set_Discard(value: v);
        }
    }
    /**
    Gets or sets the URI for which the  is valid.

    */
    public var Domain : dotnet.System.String {
        get {
            return try! get_Domain();
        }
        set(v) {
            return try! set_Domain(value: v);
        }
    }
    /**
    Gets or sets the current state of the .

    */
    public var Expired : Bool {
        get {
            return try! get_Expired();
        }
        set(v) {
            return try! set_Expired(value: v);
        }
    }
    /**
    Gets or sets the expiration date and time for the  as a .

    */
    public var Expires : dotnet.System.DateTime {
        get {
            return try! get_Expires();
        }
        set(v) {
            return try! set_Expires(value: v);
        }
    }
    /**
    Determines whether a page script or other active content can access this cookie.

    */
    public var HttpOnly : Bool {
        get {
            return try! get_HttpOnly();
        }
        set(v) {
            return try! set_HttpOnly(value: v);
        }
    }
    /**
    Gets or sets the name for the .

    */
    public var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
        set(v) {
            return try! set_Name(value: v);
        }
    }
    /**
    Gets or sets the URIs to which the  applies.

    */
    public var Path : dotnet.System.String {
        get {
            return try! get_Path();
        }
        set(v) {
            return try! set_Path(value: v);
        }
    }
    /**
    Gets or sets a list of TCP ports that the  applies to.

    */
    public var Port : dotnet.System.String {
        get {
            return try! get_Port();
        }
        set(v) {
            return try! set_Port(value: v);
        }
    }
    /**
    Gets or sets the security level of a .

    */
    public var Secure : Bool {
        get {
            return try! get_Secure();
        }
        set(v) {
            return try! set_Secure(value: v);
        }
    }
    /**
    Gets the time when the cookie was issued as a .

    */
    public var TimeStamp : dotnet.System.DateTime {
        get {
            return try! get_TimeStamp();
        }
    }
    /**
    Gets or sets the  for the .

    */
    public var Value : dotnet.System.String {
        get {
            return try! get_Value();
        }
        set(v) {
            return try! set_Value(value: v);
        }
    }
    /**
    Gets or sets the version of HTTP state maintenance to which the cookie conforms.

    */
    public var Version : Swift.Int32 {
        get {
            return try! get_Version();
        }
        set(v) {
            return try! set_Version(value: v);
        }
    }
} // Cookie


// type: System.Net.CookieCollection
    /**
    Provides a collection container for instances of the  class.

    */
open class CookieCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable,
    System_Collections_ICollection
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_CookieCollection_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.CookieCollection.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_CookieCollection_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Add(System.Net.Cookie)
// docid: M:System.Net.CookieCollection.Add(System.Net.Cookie)
    /**
    Adds a  to a .

    - Parameter cookie: The  to be added to a .
    */
    open /* method final */ func Add(cookie : dotnet.System.Net.Cookie) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieCollection_void__Add_0__1__Cookie(&__thrown, self.get_handle(), cookie.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Add(System.Net.CookieCollection)
// docid: M:System.Net.CookieCollection.Add(System.Net.CookieCollection)
    /**
    Adds the contents of a  to the current instance.

    - Parameter cookies: The  to be added.
    */
    open func Add(cookies : dotnet.System.Net.CookieCollection) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieCollection_void__Add_0__1__CookieCollection(&__thrown, self.get_handle(), cookies.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Clear()
// docid: M:System.Net.CookieCollection.Clear
    /**
    Removes all elements from the  object.

    */
    open /* method final */ func Clear() throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieCollection_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Contains(System.Net.Cookie)
// docid: M:System.Net.CookieCollection.Contains(System.Net.Cookie)
    /**
    Determines whether the specified cookie is in the .

    - Parameter cookie: The cookie to locate in the .
    - Returns: 
         if the specified cookie is found in the ; otherwise, .

    */
    open /* method final */ func Contains(cookie : dotnet.System.Net.Cookie) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_bool__Contains_0__1__Cookie(&__thrown, self.get_handle(), cookie.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void CopyTo(System.Array, System.Int32)
// docid: M:System.Net.CookieCollection.CopyTo(System.Array,System.Int32)
    /**
    Copies the elements of a  to the specified array, starting at a particular index.

    - Parameter array: The target array to which the  will be copied.
    - Parameter index: The zero-based index in the target array where copying begins.
    */
    open /* method final */ func CopyTo(array : dotnet.System.Array, index : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieCollection_void__CopyTo_0__2__Array_i32(&__thrown, self.get_handle(), array.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CopyTo(System.Net.Cookie[], System.Int32)
// docid: M:System.Net.CookieCollection.CopyTo(System.Net.Cookie[],System.Int32)
    /**
    Copies the elements of this  to a  array starting at the specified index of the target array.

    - Parameter array: The target  array to which the  will be copied.
    - Parameter index: The zero-based index in the target array where copying begins.
    */
    open /* method final */ func CopyTo(array : dotnet.System_Arr<dotnet.System.Net.Cookie>, index : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieCollection_void__CopyTo_0__2__CookieArray_i32(&__thrown, self.get_handle(), array.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Collections.IEnumerator GetEnumerator()
// docid: M:System.Net.CookieCollection.GetEnumerator
    /**
    Gets an enumerator that can iterate through a .

    - Returns: An  for this collection.

    */
    open /* method final */ func GetEnumerator() throws -> dotnet.System.Collections.IEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_IEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.IEnumerator(hndl : __return);
        }
    }
    // bool Remove(System.Net.Cookie)
// docid: M:System.Net.CookieCollection.Remove(System.Net.Cookie)
    /**
    Removes the specified cookie from the .

    - Parameter cookie: The cookie to remove from the .
    - Returns: 
         if  was successfully removed from the ; otherwise, . This method also returns  if item is not found in the original collection.

    */
    open /* method final */ func Remove(cookie : dotnet.System.Net.Cookie) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_bool__Remove_0__1__Cookie(&__thrown, self.get_handle(), cookie.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Net.CookieCollection.get_Count
    open /* method final */ func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadOnly()
// docid: M:System.Net.CookieCollection.get_IsReadOnly
    open /* method final */ func get_IsReadOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_bool__get_IsReadOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSynchronized()
// docid: M:System.Net.CookieCollection.get_IsSynchronized
    open /* method final */ func get_IsSynchronized() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_bool__get_IsSynchronized_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Object get_SyncRoot()
// docid: M:System.Net.CookieCollection.get_SyncRoot
    open /* method final */ func get_SyncRoot() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_Object__get_SyncRoot_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Cookie get_Item(System.Int32)
// docid: M:System.Net.CookieCollection.get_Item(System.Int32)
    open func get_Item(index : Swift.Int32) throws -> dotnet.System.Net.Cookie {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_Cookie__get_Item_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Cookie(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Cookie get_Item(System.String)
// docid: M:System.Net.CookieCollection.get_Item(System.String)
    open func get_Item(name : dotnet.System.String) throws -> Optional<dotnet.System.Net.Cookie> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieCollection_Cookie__get_Item_0__1__String(&__thrown, self.get_handle(), name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Cookie(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the number of cookies contained in a .

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a value that indicates whether a  is read-only.

    */
    public var IsReadOnly : Bool {
        get {
            return try! get_IsReadOnly();
        }
    }
    /**
    Gets a value that indicates whether access to a  is thread safe.

    */
    public var IsSynchronized : Bool {
        get {
            return try! get_IsSynchronized();
        }
    }
    /**
    Gets an object to synchronize access to the .

    */
    public var SyncRoot : dotnet.System.Object {
        get {
            return try! get_SyncRoot();
        }
    }
} // CookieCollection


// type: System.Net.CookieContainer
    /**
    Provides a container for a collection of  objects.

    */
open class CookieContainer
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_CookieContainer_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Int32 DefaultCookieLengthLimit
    /**
    Represents the default maximum size, in bytes, of the  instances that the  can hold. This field is constant.

    */
    open class var DefaultCookieLengthLimit : Swift.Int32 {
        get {
        let __return = System_Net_CookieContainer_get_DefaultCookieLengthLimit();
            return __return;
        }
    }
    // static field: System.Int32 DefaultCookieLimit
    /**
    Represents the default maximum number of  instances that the  can hold. This field is constant.

    */
    open class var DefaultCookieLimit : Swift.Int32 {
        get {
        let __return = System_Net_CookieContainer_get_DefaultCookieLimit();
            return __return;
        }
    }
    // static field: System.Int32 DefaultPerDomainCookieLimit
    /**
    Represents the default maximum number of  instances that the  can reference per domain. This field is constant.

    */
    open class var DefaultPerDomainCookieLimit : Swift.Int32 {
        get {
        let __return = System_Net_CookieContainer_get_DefaultPerDomainCookieLimit();
            return __return;
        }
    }
    // .ctor()
// docid: M:System.Net.CookieContainer.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_CookieContainer_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Net.CookieContainer.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a specified value for the number of  instances that the container can hold.

    - Parameter capacity: The number of  instances that the  can hold.
    */
    public init(capacity : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_CookieContainer_ctor_0__1__i32(&__thrown, capacity);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Int32, System.Int32)
// docid: M:System.Net.CookieContainer.#ctor(System.Int32,System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class with specific properties.

    - Parameter capacity: The number of  instances that the  can hold.
    - Parameter perDomainCapacity: The number of  instances per domain.
    - Parameter maxCookieSize: The maximum size in bytes for any single  in a .
    */
    public init(capacity : Swift.Int32, perDomainCapacity : Swift.Int32, maxCookieSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_CookieContainer_ctor_0__3__i32_i32_i32(&__thrown, capacity, perDomainCapacity, maxCookieSize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Add(System.Net.Cookie)
// docid: M:System.Net.CookieContainer.Add(System.Net.Cookie)
    /**
    Adds a  to a . This method uses the domain from the  to determine which domain collection to associate the  with.

    - Parameter cookie: The  to be added to the .
    */
    open func Add(cookie : dotnet.System.Net.Cookie) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__Add_0__1__Cookie(&__thrown, self.get_handle(), cookie.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Add(System.Net.CookieCollection)
// docid: M:System.Net.CookieContainer.Add(System.Net.CookieCollection)
    /**
    Adds the contents of a  to the .

    - Parameter cookies: The  to be added to the .
    */
    open func Add(cookies : dotnet.System.Net.CookieCollection) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__Add_0__1__CookieCollection(&__thrown, self.get_handle(), cookies.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Add(System.Uri, System.Net.Cookie)
// docid: M:System.Net.CookieContainer.Add(System.Uri,System.Net.Cookie)
    /**
    Adds a  to the  for a particular URI.

    - Parameter uri: The URI of the  to be added to the .
    - Parameter cookie: The  to be added to the .
    */
    open func Add(uri : dotnet.System.Uri, cookie : dotnet.System.Net.Cookie) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__Add_0__2__Uri_Cookie(&__thrown, self.get_handle(), uri.get_handle(), cookie.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Add(System.Uri, System.Net.CookieCollection)
// docid: M:System.Net.CookieContainer.Add(System.Uri,System.Net.CookieCollection)
    /**
    Adds the contents of a  to the  for a particular URI.

    - Parameter uri: The URI of the  to be added to the .
    - Parameter cookies: The  to be added to the .
    */
    open func Add(uri : dotnet.System.Uri, cookies : dotnet.System.Net.CookieCollection) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__Add_0__2__Uri_CookieCollection(&__thrown, self.get_handle(), uri.get_handle(), cookies.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String GetCookieHeader(System.Uri)
// docid: M:System.Net.CookieContainer.GetCookieHeader(System.Uri)
    /**
    Gets the HTTP cookie header that contains the HTTP cookies that represent the  instances that are associated with a specific URI.

    - Parameter uri: The URI of the  instances desired.
    - Returns: An HTTP cookie header, with strings representing  instances delimited by semicolons.

    */
    open func GetCookieHeader(uri : dotnet.System.Uri) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieContainer_String__GetCookieHeader_0__1__Uri(&__thrown, self.get_handle(), uri.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Net.CookieCollection GetCookies(System.Uri)
// docid: M:System.Net.CookieContainer.GetCookies(System.Uri)
    /**
    Gets a  that contains the  instances that are associated with a specific URI.

    - Parameter uri: The URI of the  instances desired.
    - Returns: A  that contains the  instances that are associated with a specific URI.

    */
    open func GetCookies(uri : dotnet.System.Uri) throws -> dotnet.System.Net.CookieCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieContainer_CookieCollection__GetCookies_0__1__Uri(&__thrown, self.get_handle(), uri.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.CookieCollection(hndl : __return);
        }
    }
    // System.Net.CookieCollection GetAllCookies()
// docid: M:System.Net.CookieContainer.GetAllCookies
    /**
    Gets a  that contains all of the  instances in the container.

    - Returns: A  that contains all of the  instances in the container.

    */
    open func GetAllCookies() throws -> dotnet.System.Net.CookieCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieContainer_CookieCollection__GetAllCookies_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.CookieCollection(hndl : __return);
        }
    }
    // void SetCookies(System.Uri, System.String)
// docid: M:System.Net.CookieContainer.SetCookies(System.Uri,System.String)
    /**
    Adds  instances for one or more cookies from an HTTP cookie header to the  for a specific URI.

    - Parameter uri: The URI of the .
    - Parameter cookieHeader: The contents of an HTTP set-cookie header as returned by a HTTP server, with  instances delimited by commas.
    */
    open func SetCookies(uri : dotnet.System.Uri, cookieHeader : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__SetCookies_0__2__Uri_String(&__thrown, self.get_handle(), uri.get_handle(), cookieHeader.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Capacity()
// docid: M:System.Net.CookieContainer.get_Capacity
    open func get_Capacity() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieContainer_i32__get_Capacity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Capacity(System.Int32)
// docid: M:System.Net.CookieContainer.set_Capacity(System.Int32)
    open func set_Capacity(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__set_Capacity_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Net.CookieContainer.get_Count
    open func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieContainer_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxCookieSize()
// docid: M:System.Net.CookieContainer.get_MaxCookieSize
    open func get_MaxCookieSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieContainer_i32__get_MaxCookieSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxCookieSize(System.Int32)
// docid: M:System.Net.CookieContainer.set_MaxCookieSize(System.Int32)
    open func set_MaxCookieSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__set_MaxCookieSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_PerDomainCapacity()
// docid: M:System.Net.CookieContainer.get_PerDomainCapacity
    open func get_PerDomainCapacity() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CookieContainer_i32__get_PerDomainCapacity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_PerDomainCapacity(System.Int32)
// docid: M:System.Net.CookieContainer.set_PerDomainCapacity(System.Int32)
    open func set_PerDomainCapacity(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieContainer_void__set_PerDomainCapacity_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the number of  instances that a  can hold.

    */
    open var Capacity : Swift.Int32 {
        get {
            return try! get_Capacity();
        }
        set(v) {
            return try! set_Capacity(value: v);
        }
    }
    /**
    Gets the number of  instances that a  currently holds.

    */
    open var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Represents the maximum allowed length of a .

    */
    open var MaxCookieSize : Swift.Int32 {
        get {
            return try! get_MaxCookieSize();
        }
        set(v) {
            return try! set_MaxCookieSize(value: v);
        }
    }
    /**
    Gets or sets the number of  instances that a  can hold per domain.

    */
    open var PerDomainCapacity : Swift.Int32 {
        get {
            return try! get_PerDomainCapacity();
        }
        set(v) {
            return try! set_PerDomainCapacity(value: v);
        }
    }
} // CookieContainer


// type: System.Net.CookieException
    /**
    The exception that is thrown when an error is made adding a  to a .

    */
open class CookieException
    :
    dotnet.System.FormatException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_CookieException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.CookieException.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_CookieException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
// docid: M:System.Net.CookieException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    /**
    Populates a  instance with the data needed to serialize the .

    - Parameter serializationInfo: The object that holds the serialized object data. The  to populate with data.
    - Parameter streamingContext: The contextual information about the source or destination. A  that specifies the destination for this serialization.
    */
    open func GetObjectData(serializationInfo : dotnet.System.Runtime.Serialization.SerializationInfo, streamingContext : dotnet.System.Runtime.Serialization.StreamingContext) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CookieException_void__GetObjectData_0__2__SerializationInfo_StreamingContext(&__thrown, self.get_handle(), serializationInfo.get_handle(), streamingContext.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // CookieException


// type: System.Net.CredentialCache
    /**
    Provides storage for multiple credentials.

    */
open class CredentialCache
    :
    dotnet.System.Object,
    System_Collections_IEnumerable,
    System_Net_ICredentials,
    System_Net_ICredentialsByHost
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_CredentialCache_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.CredentialCache.#ctor
    /**
    Creates a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_CredentialCache_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Add(System.String, System.Int32, System.String, System.Net.NetworkCredential)
// docid: M:System.Net.CredentialCache.Add(System.String,System.Int32,System.String,System.Net.NetworkCredential)
    /**
    Adds a  instance for use with SMTP to the credential cache and associates it with a host computer, port, and authentication protocol. Credentials added using this method are valid for SMTP only. This method does not work for HTTP or FTP requests.

    - Parameter host: A  that identifies the host computer.
    - Parameter port: A  that specifies the port to connect to on .
    - Parameter authenticationType: A  that identifies the authentication scheme used when connecting to  using .
    - Parameter credential: The  to add to the credential cache.
    */
    open func Add(host : dotnet.System.String, port : Swift.Int32, authenticationType : dotnet.System.String, credential : dotnet.System.Net.NetworkCredential) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CredentialCache_void__Add_0__4__String_i32_String_NetworkCredential(&__thrown, self.get_handle(), host.get_handle(), port, authenticationType.get_handle(), credential.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Add(System.Uri, System.String, System.Net.NetworkCredential)
// docid: M:System.Net.CredentialCache.Add(System.Uri,System.String,System.Net.NetworkCredential)
    /**
    Adds a  instance to the credential cache for use with protocols other than SMTP and associates it with a Uniform Resource Identifier (URI) prefix and authentication protocol.

    - Parameter uriPrefix: A  that specifies the URI prefix of the resources that the credential grants access to.
    - Parameter authType: The authentication scheme used by the resource named in .
    - Parameter cred: The  to add to the credential cache.
    */
    open func Add(uriPrefix : dotnet.System.Uri, authType : dotnet.System.String, cred : dotnet.System.Net.NetworkCredential) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CredentialCache_void__Add_0__3__Uri_String_NetworkCredential(&__thrown, self.get_handle(), uriPrefix.get_handle(), authType.get_handle(), cred.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Net.NetworkCredential GetCredential(System.String, System.Int32, System.String)
// docid: M:System.Net.CredentialCache.GetCredential(System.String,System.Int32,System.String)
    /**
    Returns the  instance associated with the specified host, port, and authentication protocol.

    - Parameter host: A  that identifies the host computer.
    - Parameter port: A  that specifies the port to connect to on .
    - Parameter authenticationType: A  that identifies the authentication scheme used when connecting to .
    - Returns: A  or, if there is no matching credential in the cache, .

    */
    open /* method final */ func GetCredential(host : dotnet.System.String, port : Swift.Int32, authenticationType : dotnet.System.String) throws -> Optional<dotnet.System.Net.NetworkCredential> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CredentialCache_NetworkCredential__GetCredential_0__3__String_i32_String(&__thrown, self.get_handle(), host.get_handle(), port, authenticationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.NetworkCredential(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Net.NetworkCredential GetCredential(System.Uri, System.String)
// docid: M:System.Net.CredentialCache.GetCredential(System.Uri,System.String)
    /**
    Returns the  instance associated with the specified Uniform Resource Identifier (URI) and authentication type.

    - Parameter uriPrefix: A  that specifies the URI prefix of the resources that the credential grants access to.
    - Parameter authType: The authentication scheme used by the resource named in .
    - Returns: A  or, if there is no matching credential in the cache, .

    */
    open /* method final */ func GetCredential(uriPrefix : dotnet.System.Uri, authType : dotnet.System.String) throws -> Optional<dotnet.System.Net.NetworkCredential> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CredentialCache_NetworkCredential__GetCredential_0__2__Uri_String(&__thrown, self.get_handle(), uriPrefix.get_handle(), authType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.NetworkCredential(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Collections.IEnumerator GetEnumerator()
// docid: M:System.Net.CredentialCache.GetEnumerator
    /**
    Returns an enumerator that can iterate through the  instance.

    - Returns: An  for the .

    */
    open /* method final */ func GetEnumerator() throws -> dotnet.System.Collections.IEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CredentialCache_IEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.IEnumerator(hndl : __return);
        }
    }
    // void Remove(System.String, System.Int32, System.String)
// docid: M:System.Net.CredentialCache.Remove(System.String,System.Int32,System.String)
    /**
    Deletes a  instance from the cache if it is associated with the specified host, port, and authentication protocol.

    - Parameter host: A  that identifies the host computer.
    - Parameter port: A  that specifies the port to connect to on .
    - Parameter authenticationType: A  that identifies the authentication scheme used when connecting to .
    */
    open func Remove(host : Optional<dotnet.System.String>, port : Swift.Int32, authenticationType : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CredentialCache_void__Remove_0__3__String_i32_String(&__thrown, self.get_handle(), host?.get_handle() ?? nil, port, authenticationType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Remove(System.Uri, System.String)
// docid: M:System.Net.CredentialCache.Remove(System.Uri,System.String)
    /**
    Deletes a  instance from the cache if it is associated with the specified Uniform Resource Identifier (URI) prefix and authentication protocol.

    - Parameter uriPrefix: A  that specifies the URI prefix of the resources that the credential is used for.
    - Parameter authType: The authentication scheme used by the host named in .
    */
    open func Remove(uriPrefix : Optional<dotnet.System.Uri>, authType : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_CredentialCache_void__Remove_0__2__Uri_String(&__thrown, self.get_handle(), uriPrefix?.get_handle() ?? nil, authType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.ICredentials get_DefaultCredentials()
// docid: M:System.Net.CredentialCache.get_DefaultCredentials
    open class func get_DefaultCredentials() throws -> dotnet.System.Net.ICredentials {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CredentialCache_ICredentials__get_DefaultCredentials_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.ICredentials(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.NetworkCredential get_DefaultNetworkCredentials()
// docid: M:System.Net.CredentialCache.get_DefaultNetworkCredentials
    open class func get_DefaultNetworkCredentials() throws -> dotnet.System.Net.NetworkCredential {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_CredentialCache_NetworkCredential__get_DefaultNetworkCredentials_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.NetworkCredential(hndl : __return);
        }
    }
    /**
    Gets the system credentials of the application.

    */
    public static var DefaultCredentials : dotnet.System.Net.ICredentials {
        get {
            return try! get_DefaultCredentials();
        }
    }
    /**
    Gets the network credentials of the current security context.

    */
    public static var DefaultNetworkCredentials : dotnet.System.Net.NetworkCredential {
        get {
            return try! get_DefaultNetworkCredentials();
        }
    }
} // CredentialCache


// type: System.Net.DecompressionMethods
    /**
    Represents the file compression and decompression encoding format to be used to compress the data received in response to an .

    */
public struct DecompressionMethods : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_DecompressionMethods_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.DecompressionMethods All
    /**
    Use all compression-decompression algorithms.

    */
    public static var All : dotnet.System.Net.DecompressionMethods {
        get {
        let __return = dotnet.System.Net.DecompressionMethods(val: System_Net_DecompressionMethods_get_All());
            return __return;
        }
    }
    // static field: System.Net.DecompressionMethods None
    /**
    Do not use compression.

    */
    public static var None : dotnet.System.Net.DecompressionMethods {
        get {
        let __return = dotnet.System.Net.DecompressionMethods(val: System_Net_DecompressionMethods_get_None());
            return __return;
        }
    }
    // static field: System.Net.DecompressionMethods GZip
    /**
    Use the gZip compression-decompression algorithm.

    */
    public static var GZip : dotnet.System.Net.DecompressionMethods {
        get {
        let __return = dotnet.System.Net.DecompressionMethods(val: System_Net_DecompressionMethods_get_GZip());
            return __return;
        }
    }
    // static field: System.Net.DecompressionMethods Deflate
    /**
    Use the deflate compression-decompression algorithm.

    */
    public static var Deflate : dotnet.System.Net.DecompressionMethods {
        get {
        let __return = dotnet.System.Net.DecompressionMethods(val: System_Net_DecompressionMethods_get_Deflate());
            return __return;
        }
    }
    // static field: System.Net.DecompressionMethods Brotli
    /**
    Use the Brotli compression-decompression algorithm.

    */
    public static var Brotli : dotnet.System.Net.DecompressionMethods {
        get {
        let __return = dotnet.System.Net.DecompressionMethods(val: System_Net_DecompressionMethods_get_Brotli());
            return __return;
        }
    }
} // DecompressionMethods


// type: System.Net.DnsEndPoint
    /**
    Represents a network endpoint as a host name or a string representation of an IP address and a port number.

    */
open class DnsEndPoint
    :
    dotnet.System.Net.EndPoint
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_DnsEndPoint_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Int32)
// docid: M:System.Net.DnsEndPoint.#ctor(System.String,System.Int32)
    /**
    Initializes a new instance of the  class with the host name or string representation of an IP address and a port number.

    - Parameter host: The host name or a string representation of the IP address.
    - Parameter port: The port number associated with the address, or 0 to specify any available port.  is in host order.
    */
    public init(host : dotnet.System.String, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_DnsEndPoint_ctor_0__2__String_i32(&__thrown, host.get_handle(), port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32, System.Net.Sockets.AddressFamily)
// docid: M:System.Net.DnsEndPoint.#ctor(System.String,System.Int32,System.Net.Sockets.AddressFamily)
    /**
    Initializes a new instance of the  class with the host name or string representation of an IP address, a port number, and an address family.

    - Parameter host: The host name or a string representation of the IP address.
    - Parameter port: The port number associated with the address, or 0 to specify any available port.  is in host order.
    - Parameter addressFamily: One of the  values.
    */
    public init(host : dotnet.System.String, port : Swift.Int32, addressFamily : dotnet.System.Net.Sockets.AddressFamily) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_DnsEndPoint_ctor_0__3__String_i32_AddressFamily(&__thrown, host.get_handle(), port, addressFamily.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Net.DnsEndPoint.Equals(System.Object)
    /**
    Compares two  objects.

    - Parameter comparand: A  instance to compare to the current instance.
    - Returns: 
         if the two  instances are equal; otherwise, .

    */
    open func Equals(comparand : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_DnsEndPoint_bool__Equals_0__1__Object(&__thrown, self.get_handle(), comparand?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.DnsEndPoint.GetHashCode
    /**
    Returns a hash value for a .

    - Returns: An integer hash value for the .

    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_DnsEndPoint_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.String ToString()
// docid: M:System.Net.DnsEndPoint.ToString
    /**
    Returns the host name or string representation of the IP address and port number of the .

    - Returns: A string containing the address family, host name or IP address string, and the port number of the specified .

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_DnsEndPoint_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Sockets.AddressFamily get_AddressFamily()
// docid: M:System.Net.DnsEndPoint.get_AddressFamily
    open override func get_AddressFamily() throws -> dotnet.System.Net.Sockets.AddressFamily {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_DnsEndPoint_AddressFamily__get_AddressFamily_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.AddressFamily(val: __return);
        }
    }
    // [IsSpecialName] System.String get_Host()
// docid: M:System.Net.DnsEndPoint.get_Host
    open func get_Host() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_DnsEndPoint_String__get_Host_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Port()
// docid: M:System.Net.DnsEndPoint.get_Port
    open func get_Port() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_DnsEndPoint_i32__get_Port_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the Internet Protocol (IP) address family.

    */
    open override var AddressFamily : dotnet.System.Net.Sockets.AddressFamily {
        get {
            return try! get_AddressFamily();
        }
    }
    /**
    Gets the host name or string representation of the Internet Protocol (IP) address of the host.

    */
    open var Host : dotnet.System.String {
        get {
            return try! get_Host();
        }
    }
    /**
    Gets the port number of the .

    */
    open var Port : Swift.Int32 {
        get {
            return try! get_Port();
        }
    }
} // DnsEndPoint


// type: System.Net.EndPoint
    /**
    Identifies a network address. This is an  class.

    */
open class EndPoint
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_EndPoint_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Net.EndPoint Create(System.Net.SocketAddress)
// docid: M:System.Net.EndPoint.Create(System.Net.SocketAddress)
    /**
    Creates an  instance from a  instance.

    - Parameter socketAddress: The socket address that serves as the endpoint for a connection.
    - Returns: A new  instance that is initialized from the specified  instance.

    */
    open func Create(socketAddress : dotnet.System.Net.SocketAddress) throws -> dotnet.System.Net.EndPoint {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_EndPoint_EndPoint__Create_0__1__SocketAddress(&__thrown, self.get_handle(), socketAddress.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.EndPoint(hndl : __return);
        }
    }
    // System.Net.SocketAddress Serialize()
// docid: M:System.Net.EndPoint.Serialize
    /**
    Serializes endpoint information into a  instance.

    - Returns: A  instance that contains the endpoint information.

    */
    open func Serialize() throws -> dotnet.System.Net.SocketAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_EndPoint_SocketAddress__Serialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.SocketAddress(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Sockets.AddressFamily get_AddressFamily()
// docid: M:System.Net.EndPoint.get_AddressFamily
    open func get_AddressFamily() throws -> dotnet.System.Net.Sockets.AddressFamily {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_EndPoint_AddressFamily__get_AddressFamily_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.AddressFamily(val: __return);
        }
    }
    /**
    Gets the address family to which the endpoint belongs.

    */
    open var AddressFamily : dotnet.System.Net.Sockets.AddressFamily {
        get {
            return try! get_AddressFamily();
        }
    }
} // EndPoint


// type: System.Net.HttpStatusCode
    /**
    Contains the values of status codes defined for HTTP.

    */
public struct HttpStatusCode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_HttpStatusCode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.HttpStatusCode Continue
    /**
    Equivalent to HTTP status 100.  indicates that the client can continue with its request.

    */
    public static var Continue : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Continue());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode SwitchingProtocols
    /**
    Equivalent to HTTP status 101.  indicates that the protocol version or protocol is being changed.

    */
    public static var SwitchingProtocols : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_SwitchingProtocols());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Processing
    /**
    Equivalent to HTTP status 102.  indicates that the server has accepted the complete request but hasn't completed it yet.

    */
    public static var Processing : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Processing());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode EarlyHints
    /**
    Equivalent to HTTP status 103.  indicates to the client that the server is likely to send a final response with the header fields included in the informational response.

    */
    public static var EarlyHints : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_EarlyHints());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode OK
    /**
    Equivalent to HTTP status 200.  indicates that the request succeeded and that the requested information is in the response. This is the most common status code to receive.

    */
    public static var OK : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_OK());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Created
    /**
    Equivalent to HTTP status 201.  indicates that the request resulted in a new resource created before the response was sent.

    */
    public static var Created : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Created());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Accepted
    /**
    Equivalent to HTTP status 202.  indicates that the request has been accepted for further processing.

    */
    public static var Accepted : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Accepted());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NonAuthoritativeInformation
    /**
    Equivalent to HTTP status 203.  indicates that the returned meta information is from a cached copy instead of the origin server and therefore may be incorrect.

    */
    public static var NonAuthoritativeInformation : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NonAuthoritativeInformation());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NoContent
    /**
    Equivalent to HTTP status 204.  indicates that the request has been successfully processed and that the response is intentionally blank.

    */
    public static var NoContent : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NoContent());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode ResetContent
    /**
    Equivalent to HTTP status 205.  indicates that the client should reset (not reload) the current resource.

    */
    public static var ResetContent : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_ResetContent());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode PartialContent
    /**
    Equivalent to HTTP status 206.  indicates that the response is a partial response as requested by a GET request that includes a byte range.

    */
    public static var PartialContent : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_PartialContent());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode MultiStatus
    /**
    Equivalent to HTTP status 207.  indicates multiple status codes for a single response during a Web Distributed Authoring and Versioning (WebDAV) operation. The response body contains XML that describes the status codes.

    */
    public static var MultiStatus : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_MultiStatus());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode AlreadyReported
    /**
    Equivalent to HTTP status 208.  indicates that the members of a WebDAV binding have already been enumerated in a preceding part of the multistatus response, and are not being included again.

    */
    public static var AlreadyReported : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_AlreadyReported());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode IMUsed
    /**
    Equivalent to HTTP status 226.  indicates that the server has fulfilled a request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.

    */
    public static var IMUsed : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_IMUsed());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Ambiguous
    /**
    Equivalent to HTTP status 300.  indicates that the requested information has multiple representations. The default action is to treat this status as a redirect and follow the contents of the Location header associated with this response. Ambiguous is a synonym for MultipleChoices.

    */
    public static var Ambiguous : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Ambiguous());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode MultipleChoices
    /**
    Equivalent to HTTP status 300.  indicates that the requested information has multiple representations. The default action is to treat this status as a redirect and follow the contents of the Location header associated with this response. MultipleChoices is a synonym for Ambiguous.

    */
    public static var MultipleChoices : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_MultipleChoices());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Moved
    /**
    Equivalent to HTTP status 301.  indicates that the requested information has been moved to the URI specified in the Location header. The default action when this status is received is to follow the Location header associated with the response. When the original request method was POST, the redirected request will use the GET method. Moved is a synonym for MovedPermanently.

    */
    public static var Moved : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Moved());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode MovedPermanently
    /**
    Equivalent to HTTP status 301.  indicates that the requested information has been moved to the URI specified in the Location header. The default action when this status is received is to follow the Location header associated with the response. MovedPermanently is a synonym for Moved.

    */
    public static var MovedPermanently : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_MovedPermanently());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Found
    /**
    Equivalent to HTTP status 302.  indicates that the requested information is located at the URI specified in the Location header. The default action when this status is received is to follow the Location header associated with the response. When the original request method was POST, the redirected request will use the GET method. Found is a synonym for Redirect.

    */
    public static var Found : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Found());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Redirect
    /**
    Equivalent to HTTP status 302.  indicates that the requested information is located at the URI specified in the Location header. The default action when this status is received is to follow the Location header associated with the response. When the original request method was POST, the redirected request will use the GET method. Redirect is a synonym for Found.

    */
    public static var Redirect : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Redirect());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode RedirectMethod
    /**
    Equivalent to HTTP status 303.  automatically redirects the client to the URI specified in the Location header as the result of a POST. The request to the resource specified by the Location header will be made with a GET. RedirectMethod is a synonym for SeeOther.

    */
    public static var RedirectMethod : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_RedirectMethod());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode SeeOther
    /**
    Equivalent to HTTP status 303.  automatically redirects the client to the URI specified in the Location header as the result of a POST. The request to the resource specified by the Location header will be made with a GET. SeeOther is a synonym for RedirectMethod.

    */
    public static var SeeOther : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_SeeOther());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NotModified
    /**
    Equivalent to HTTP status 304.  indicates that the client's cached copy is up to date. The contents of the resource are not transferred.

    */
    public static var NotModified : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NotModified());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode UseProxy
    /**
    Equivalent to HTTP status 305.  indicates that the request should use the proxy server at the URI specified in the Location header.

    */
    public static var UseProxy : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_UseProxy());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Unused
    /**
    Equivalent to HTTP status 306.  is a proposed extension to the HTTP/1.1 specification that is not fully specified.

    */
    public static var Unused : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Unused());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode RedirectKeepVerb
    /**
    Equivalent to HTTP status 307.  indicates that the request information is located at the URI specified in the Location header. The default action when this status is received is to follow the Location header associated with the response. When the original request method was POST, the redirected request will also use the POST method. RedirectKeepVerb is a synonym for TemporaryRedirect.

    */
    public static var RedirectKeepVerb : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_RedirectKeepVerb());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode TemporaryRedirect
    /**
    Equivalent to HTTP status 307.  indicates that the request information is located at the URI specified in the Location header. The default action when this status is received is to follow the Location header associated with the response. When the original request method was POST, the redirected request will also use the POST method. TemporaryRedirect is a synonym for RedirectKeepVerb.

    */
    public static var TemporaryRedirect : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_TemporaryRedirect());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode PermanentRedirect
    /**
    Equivalent to HTTP status 308.  indicates that the request information is located at the URI specified in the Location header. The default action when this status is received is to follow the Location header associated with the response. When the original request method was POST, the redirected request will also use the POST method.

    */
    public static var PermanentRedirect : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_PermanentRedirect());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode BadRequest
    /**
    Equivalent to HTTP status 400.  indicates that the request could not be understood by the server.  is sent when no other error is applicable, or if the exact error is unknown or does not have its own error code.

    */
    public static var BadRequest : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_BadRequest());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Unauthorized
    /**
    Equivalent to HTTP status 401.  indicates that the requested resource requires authentication. The WWW-Authenticate header contains the details of how to perform the authentication.

    */
    public static var Unauthorized : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Unauthorized());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode PaymentRequired
    /**
    Equivalent to HTTP status 402.  is reserved for future use.

    */
    public static var PaymentRequired : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_PaymentRequired());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Forbidden
    /**
    Equivalent to HTTP status 403.  indicates that the server refuses to fulfill the request.

    */
    public static var Forbidden : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Forbidden());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NotFound
    /**
    Equivalent to HTTP status 404.  indicates that the requested resource does not exist on the server.

    */
    public static var NotFound : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NotFound());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode MethodNotAllowed
    /**
    Equivalent to HTTP status 405.  indicates that the request method (POST or GET) is not allowed on the requested resource.

    */
    public static var MethodNotAllowed : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_MethodNotAllowed());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NotAcceptable
    /**
    Equivalent to HTTP status 406.  indicates that the client has indicated with Accept headers that it will not accept any of the available representations of the resource.

    */
    public static var NotAcceptable : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NotAcceptable());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode ProxyAuthenticationRequired
    /**
    Equivalent to HTTP status 407.  indicates that the requested proxy requires authentication. The Proxy-authenticate header contains the details of how to perform the authentication.

    */
    public static var ProxyAuthenticationRequired : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_ProxyAuthenticationRequired());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode RequestTimeout
    /**
    Equivalent to HTTP status 408.  indicates that the client did not send a request within the time the server was expecting the request.

    */
    public static var RequestTimeout : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_RequestTimeout());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Conflict
    /**
    Equivalent to HTTP status 409.  indicates that the request could not be carried out because of a conflict on the server.

    */
    public static var Conflict : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Conflict());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Gone
    /**
    Equivalent to HTTP status 410.  indicates that the requested resource is no longer available.

    */
    public static var Gone : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Gone());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode LengthRequired
    /**
    Equivalent to HTTP status 411.  indicates that the required Content-length header is missing.

    */
    public static var LengthRequired : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_LengthRequired());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode PreconditionFailed
    /**
    Equivalent to HTTP status 412.  indicates that a condition set for this request failed, and the request cannot be carried out. Conditions are set with conditional request headers like If-Match, If-None-Match, or If-Unmodified-Since.

    */
    public static var PreconditionFailed : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_PreconditionFailed());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode RequestEntityTooLarge
    /**
    Equivalent to HTTP status 413.  indicates that the request is too large for the server to process.

    */
    public static var RequestEntityTooLarge : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_RequestEntityTooLarge());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode RequestUriTooLong
    /**
    Equivalent to HTTP status 414.  indicates that the URI is too long.

    */
    public static var RequestUriTooLong : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_RequestUriTooLong());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode UnsupportedMediaType
    /**
    Equivalent to HTTP status 415.  indicates that the request is an unsupported type.

    */
    public static var UnsupportedMediaType : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_UnsupportedMediaType());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode RequestedRangeNotSatisfiable
    /**
    Equivalent to HTTP status 416.  indicates that the range of data requested from the resource cannot be returned, either because the beginning of the range is before the beginning of the resource, or the end of the range is after the end of the resource.

    */
    public static var RequestedRangeNotSatisfiable : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_RequestedRangeNotSatisfiable());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode ExpectationFailed
    /**
    Equivalent to HTTP status 417.  indicates that an expectation given in an Expect header could not be met by the server.

    */
    public static var ExpectationFailed : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_ExpectationFailed());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode MisdirectedRequest
    /**
    Equivalent to HTTP status 421.  indicates that the request was directed at a server that is not able to produce a response.

    */
    public static var MisdirectedRequest : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_MisdirectedRequest());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode UnprocessableEntity
    /**
    Equivalent to HTTP status 422.  indicates that the request was well-formed but was unable to be followed due to semantic errors.

    */
    public static var UnprocessableEntity : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_UnprocessableEntity());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode Locked
    /**
    Equivalent to HTTP status 423.  indicates that the source or destination resource is locked.

    */
    public static var Locked : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_Locked());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode FailedDependency
    /**
    Equivalent to HTTP status 424.  indicates that the method couldn't be performed on the resource because the requested action depended on another action and that action failed.

    */
    public static var FailedDependency : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_FailedDependency());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode UpgradeRequired
    /**
    Equivalent to HTTP status 426.  indicates that the client should switch to a different protocol such as TLS/1.0.

    */
    public static var UpgradeRequired : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_UpgradeRequired());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode PreconditionRequired
    /**
    Equivalent to HTTP status 428.  indicates that the server requires the request to be conditional.

    */
    public static var PreconditionRequired : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_PreconditionRequired());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode TooManyRequests
    /**
    Equivalent to HTTP status 429.  indicates that the user has sent too many requests in a given amount of time.

    */
    public static var TooManyRequests : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_TooManyRequests());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode RequestHeaderFieldsTooLarge
    /**
    Equivalent to HTTP status 431.  indicates that the server is unwilling to process the request because its header fields (either an individual header field or all the header fields collectively) are too large.

    */
    public static var RequestHeaderFieldsTooLarge : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_RequestHeaderFieldsTooLarge());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode UnavailableForLegalReasons
    /**
    Equivalent to HTTP status 451.  indicates that the server is denying access to the resource as a consequence of a legal demand.

    */
    public static var UnavailableForLegalReasons : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_UnavailableForLegalReasons());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode InternalServerError
    /**
    Equivalent to HTTP status 500.  indicates that a generic error has occurred on the server.

    */
    public static var InternalServerError : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_InternalServerError());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NotImplemented
    /**
    Equivalent to HTTP status 501.  indicates that the server does not support the requested function.

    */
    public static var NotImplemented : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NotImplemented());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode BadGateway
    /**
    Equivalent to HTTP status 502.  indicates that an intermediate proxy server received a bad response from another proxy or the origin server.

    */
    public static var BadGateway : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_BadGateway());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode ServiceUnavailable
    /**
    Equivalent to HTTP status 503.  indicates that the server is temporarily unavailable, usually due to high load or maintenance.

    */
    public static var ServiceUnavailable : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_ServiceUnavailable());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode GatewayTimeout
    /**
    Equivalent to HTTP status 504.  indicates that an intermediate proxy server timed out while waiting for a response from another proxy or the origin server.

    */
    public static var GatewayTimeout : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_GatewayTimeout());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode HttpVersionNotSupported
    /**
    Equivalent to HTTP status 505.  indicates that the requested HTTP version is not supported by the server.

    */
    public static var HttpVersionNotSupported : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_HttpVersionNotSupported());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode VariantAlsoNegotiates
    /**
    Equivalent to HTTP status 506.  indicates that the chosen variant resource is configured to engage in transparent content negotiation itself and, therefore, isn't a proper endpoint in the negotiation process.

    */
    public static var VariantAlsoNegotiates : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_VariantAlsoNegotiates());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode InsufficientStorage
    /**
    Equivalent to HTTP status 507.  indicates that the server is unable to store the representation needed to complete the request.

    */
    public static var InsufficientStorage : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_InsufficientStorage());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode LoopDetected
    /**
    Equivalent to HTTP status 508.  indicates that the server terminated an operation because it encountered an infinite loop while processing a WebDAV request with "Depth: infinity". This status code is meant for backward compatibility with clients not aware of the 208 status code  appearing in multistatus response bodies.

    */
    public static var LoopDetected : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_LoopDetected());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NotExtended
    /**
    Equivalent to HTTP status 510.  indicates that further extensions to the request are required for the server to fulfill it.

    */
    public static var NotExtended : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NotExtended());
            return __return;
        }
    }
    // static field: System.Net.HttpStatusCode NetworkAuthenticationRequired
    /**
    Equivalent to HTTP status 511.  indicates that the client needs to authenticate to gain network access; it's intended for use by intercepting proxies used to control access to the network.

    */
    public static var NetworkAuthenticationRequired : dotnet.System.Net.HttpStatusCode {
        get {
        let __return = dotnet.System.Net.HttpStatusCode(val: System_Net_HttpStatusCode_get_NetworkAuthenticationRequired());
            return __return;
        }
    }
} // HttpStatusCode


// type: System.Net.HttpVersion
public struct HttpVersion {
    // static field: System.Version Unknown
    /**
    Defines a  instance for an unknown HTTP version.

    */
    public static var Unknown : dotnet.System.Version {
        get {
        let __return = dotnet.System.Version(hndl: System_Net_HttpVersion_get_Unknown());
            return __return;
        }
    }
    // static field: System.Version Version10
    /**
    Defines a  instance for HTTP 1.0.

    */
    public static var Version10 : dotnet.System.Version {
        get {
        let __return = dotnet.System.Version(hndl: System_Net_HttpVersion_get_Version10());
            return __return;
        }
    }
    // static field: System.Version Version11
    /**
    Defines a  instance for HTTP 1.1.

    */
    public static var Version11 : dotnet.System.Version {
        get {
        let __return = dotnet.System.Version(hndl: System_Net_HttpVersion_get_Version11());
            return __return;
        }
    }
    // static field: System.Version Version20
    /**
    Defines a  instance for HTTP 2.0.

    */
    public static var Version20 : dotnet.System.Version {
        get {
        let __return = dotnet.System.Version(hndl: System_Net_HttpVersion_get_Version20());
            return __return;
        }
    }
    // static field: System.Version Version30
    /**
    Defines a  instance for HTTP 3.0.

    */
    public static var Version30 : dotnet.System.Version {
        get {
        let __return = dotnet.System.Version(hndl: System_Net_HttpVersion_get_Version30());
            return __return;
        }
    }
} // HttpVersion


// type: System.Net.ICredentials
    /**
    Provides the base authentication interface for retrieving credentials for Web client authentication.

    */
open class ICredentials
    :
    SGBridgeGenericValue,
    System_Net_ICredentials
{
    open class func get_type_handle() -> TypeHandle {
        return System_Net_ICredentials_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Net.NetworkCredential GetCredential(System.Uri, System.String)
// docid: M:System.Net.ICredentials.GetCredential(System.Uri,System.String)
    /**
    Returns a  object that is associated with the specified URI, and authentication type.

    - Parameter uri: The  that the client is providing authentication for.
    - Parameter authType: The type of authentication, as defined in the  property.
    - Returns: The  that is associated with the specified URI and authentication type, or, if no credentials are available, .

    */
    open func GetCredential(uri : dotnet.System.Uri, authType : dotnet.System.String) throws -> Optional<dotnet.System.Net.NetworkCredential> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_ICredentials_NetworkCredential__GetCredential_0__2__Uri_String(&__thrown, self.get_handle(), uri.get_handle(), authType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.NetworkCredential(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ICredentials


// type: System.Net.ICredentialsByHost
    /**
    Provides the interface for retrieving credentials for a host, port, and authentication type.

    */
open class ICredentialsByHost
    :
    SGBridgeGenericValue,
    System_Net_ICredentialsByHost
{
    open class func get_type_handle() -> TypeHandle {
        return System_Net_ICredentialsByHost_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Net.NetworkCredential GetCredential(System.String, System.Int32, System.String)
// docid: M:System.Net.ICredentialsByHost.GetCredential(System.String,System.Int32,System.String)
    /**
    Returns the credential for the specified host, port, and authentication protocol.

    - Parameter host: The host computer that is authenticating the client.
    - Parameter port: The port on  that the client will communicate with.
    - Parameter authenticationType: The authentication protocol.
    - Returns: A  for the specified host, port, and authentication protocol, or  if there are no credentials available for the specified host, port, and authentication protocol.

    */
    open func GetCredential(host : dotnet.System.String, port : Swift.Int32, authenticationType : dotnet.System.String) throws -> Optional<dotnet.System.Net.NetworkCredential> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_ICredentialsByHost_NetworkCredential__GetCredential_0__3__String_i32_String(&__thrown, self.get_handle(), host.get_handle(), port, authenticationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.NetworkCredential(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ICredentialsByHost


// type: System.Net.IPAddress
    /**
    Provides an Internet Protocol (IP) address.

    */
open class IPAddress
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_IPAddress_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Net.IPAddress Any
    /**
    Provides an IP address that indicates that the server must listen for client activity on all network interfaces. This field is read-only.

    */
    open class var Any_ : dotnet.System.Net.IPAddress {
        get {
        let __return = dotnet.System.Net.IPAddress(hndl: System_Net_IPAddress_get_Any());
            return __return;
        }
    }
    // static field: System.Net.IPAddress Broadcast
    /**
    Provides the IP broadcast address. This field is read-only.

    */
    open class var Broadcast : dotnet.System.Net.IPAddress {
        get {
        let __return = dotnet.System.Net.IPAddress(hndl: System_Net_IPAddress_get_Broadcast());
            return __return;
        }
    }
    // static field: System.Net.IPAddress IPv6Any
    /**
    The  method uses the  field to indicate that a  must listen for client activity on all network interfaces.

    */
    open class var IPv6Any : dotnet.System.Net.IPAddress {
        get {
        let __return = dotnet.System.Net.IPAddress(hndl: System_Net_IPAddress_get_IPv6Any());
            return __return;
        }
    }
    // static field: System.Net.IPAddress IPv6Loopback
    /**
    Provides the IP loopback address. This property is read-only.

    */
    open class var IPv6Loopback : dotnet.System.Net.IPAddress {
        get {
        let __return = dotnet.System.Net.IPAddress(hndl: System_Net_IPAddress_get_IPv6Loopback());
            return __return;
        }
    }
    // static field: System.Net.IPAddress IPv6None
    /**
    Provides an IP address that indicates that no network interface should be used. This property is read-only.

    */
    open class var IPv6None : dotnet.System.Net.IPAddress {
        get {
        let __return = dotnet.System.Net.IPAddress(hndl: System_Net_IPAddress_get_IPv6None());
            return __return;
        }
    }
    // static field: System.Net.IPAddress Loopback
    /**
    Provides the IP loopback address. This field is read-only.

    */
    open class var Loopback : dotnet.System.Net.IPAddress {
        get {
        let __return = dotnet.System.Net.IPAddress(hndl: System_Net_IPAddress_get_Loopback());
            return __return;
        }
    }
    // static field: System.Net.IPAddress None
    /**
    Provides an IP address that indicates that no network interface should be used. This field is read-only.

    */
    open class var None : dotnet.System.Net.IPAddress {
        get {
        let __return = dotnet.System.Net.IPAddress(hndl: System_Net_IPAddress_get_None());
            return __return;
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Net.IPAddress.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class with the address specified as a  array.

    - Parameter address: The byte array value of the IP address.
    */
    public init(address : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_IPAddress_ctor_0__1__u8Array(&__thrown, address.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Int64)
// docid: M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)
    /**
    Initializes a new instance of the  class with the address specified as a  array and the specified scope identifier.

    - Parameter address: The byte array value of the IP address.
    - Parameter scopeid: The long value of the scope identifier.
    */
    public init(address : dotnet.System_Arr<Swift.UInt8>, scopeid : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_IPAddress_ctor_0__2__u8Array_i64(&__thrown, address.get_handle(), scopeid);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int64)
// docid: M:System.Net.IPAddress.#ctor(System.Int64)
    /**
    Initializes a new instance of the  class with the address specified as an .

    - Parameter newAddress: The long value of the IP address. For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".
    */
    public init(newAddress : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_IPAddress_ctor_0__1__i64(&__thrown, newAddress);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>)
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>, System.Int64)
    // bool Equals(System.Object)
// docid: M:System.Net.IPAddress.Equals(System.Object)
    /**
    Compares two IP addresses.

    - Parameter comparand: An  instance to compare to the current instance.
    - Returns: 
         if the two addresses are equal; otherwise, .

    */
    open func Equals(comparand : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__Equals_0__1__Object(&__thrown, self.get_handle(), comparand?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Byte[] GetAddressBytes()
// docid: M:System.Net.IPAddress.GetAddressBytes
    /**
    Provides a copy of the  as an array of bytes.

    - Returns: A  array.

    */
    open func GetAddressBytes() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_u8Array__GetAddressBytes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.IPAddress.GetHashCode
    /**
    Returns a hash value for an IP address.

    - Returns: An integer hash value.

    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int16 HostToNetworkOrder(System.Int16)
// docid: M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)
    /**
    Converts a short value from host byte order to network byte order.

    - Parameter host: The number to convert, expressed in host byte order.
    - Returns: A short value, expressed in network byte order.

    */
    open class func HostToNetworkOrder(host : Swift.Int16) throws -> Swift.Int16 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i16__HostToNetworkOrder_0__1__i16(&__thrown, host);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 HostToNetworkOrder(System.Int32)
// docid: M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)
    /**
    Converts an integer value from host byte order to network byte order.

    - Parameter host: The number to convert, expressed in host byte order.
    - Returns: An integer value, expressed in network byte order.

    */
    open class func HostToNetworkOrder(host : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i32__HostToNetworkOrder_0__1__i32(&__thrown, host);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 HostToNetworkOrder(System.Int64)
// docid: M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)
    /**
    Converts a long value from host byte order to network byte order.

    - Parameter host: The number to convert, expressed in host byte order.
    - Returns: A long value, expressed in network byte order.

    */
    open class func HostToNetworkOrder(host : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i64__HostToNetworkOrder_0__1__i64(&__thrown, host);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // bool IsLoopback(System.Net.IPAddress)
// docid: M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)
    /**
    Indicates whether the specified IP address is the loopback address.

    - Parameter address: An IP address.
    - Returns: 
         if  is the loopback address; otherwise, .

    */
    open class func IsLoopback(address : dotnet.System.Net.IPAddress) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__IsLoopback_0__1__IPAddress(&__thrown, address.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Net.IPAddress MapToIPv4()
// docid: M:System.Net.IPAddress.MapToIPv4
    /**
    Maps the  object to an IPv4 address.

    - Returns: Returns .  
  
 An IPv4 address.

    */
    open func MapToIPv4() throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_IPAddress__MapToIPv4_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    // System.Net.IPAddress MapToIPv6()
// docid: M:System.Net.IPAddress.MapToIPv6
    /**
    Maps the  object to an IPv6 address.

    - Returns: Returns .  
  
 An IPv6 address.

    */
    open func MapToIPv6() throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_IPAddress__MapToIPv6_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    // System.Int16 NetworkToHostOrder(System.Int16)
// docid: M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)
    /**
    Converts a short value from network byte order to host byte order.

    - Parameter network: The number to convert, expressed in network byte order.
    - Returns: A short value, expressed in host byte order.

    */
    open class func NetworkToHostOrder(network : Swift.Int16) throws -> Swift.Int16 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i16__NetworkToHostOrder_0__1__i16(&__thrown, network);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 NetworkToHostOrder(System.Int32)
// docid: M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)
    /**
    Converts an integer value from network byte order to host byte order.

    - Parameter network: The number to convert, expressed in network byte order.
    - Returns: An integer value, expressed in host byte order.

    */
    open class func NetworkToHostOrder(network : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i32__NetworkToHostOrder_0__1__i32(&__thrown, network);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 NetworkToHostOrder(System.Int64)
// docid: M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)
    /**
    Converts a long value from network byte order to host byte order.

    - Parameter network: The number to convert, expressed in network byte order.
    - Returns: A long value, expressed in host byte order.

    */
    open class func NetworkToHostOrder(network : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i64__NetworkToHostOrder_0__1__i64(&__thrown, network);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Net.IPAddress Parse(System.ReadOnlySpan<System.Char>)
    // System.Net.IPAddress Parse(System.String)
// docid: M:System.Net.IPAddress.Parse(System.String)
    /**
    Converts an IP address string to an  instance.

    - Parameter ipString: A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.
    - Returns: An  instance.

    */
    open class func Parse(ipString : dotnet.System.String) throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_IPAddress__Parse_0__1__String(&__thrown, ipString.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    // System.String ToString()
// docid: M:System.Net.IPAddress.ToString
    /**
    Converts an Internet address to its standard notation.

    - Returns: A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryFormat(System.Span<System.Char>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Char>, ref System.Net.IPAddress)
    // bool TryParse(System.String, ref System.Net.IPAddress)
// docid: M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)
    /**
    Determines whether a string is a valid IP address.

    - Parameter ipString: The string to validate.
    - Parameter address: The  version of the string.
    - Returns: 
         if  was able to be parsed as an IP address; otherwise, .

    */
    open class func TryParse(ipString : Optional<dotnet.System.String>, address : inout Optional<dotnet.System.Net.IPAddress>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_address = (address != nil) ? (address!.get_handle()) : nil;
        let __return = System_Net_IPAddress_bool__TryParse_0__2__String_outIPAddress(&__thrown, ipString?.get_handle() ?? nil, &_tmp_out_address);
        let __h__tmp2_address = _tmp_out_address;
        let _tmp2_address = (__h__tmp2_address != nil) ? dotnet.System.Net.IPAddress(hndl: __h__tmp2_address!) : nil;
            address = _tmp2_address;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryWriteBytes(System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Int64 get_Address()
// docid: M:System.Net.IPAddress.get_Address
    open func get_Address() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i64__get_Address_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Address(System.Int64)
// docid: M:System.Net.IPAddress.set_Address(System.Int64)
    open func set_Address(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_IPAddress_void__set_Address_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.AddressFamily get_AddressFamily()
// docid: M:System.Net.IPAddress.get_AddressFamily
    open func get_AddressFamily() throws -> dotnet.System.Net.Sockets.AddressFamily {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_AddressFamily__get_AddressFamily_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.AddressFamily(val: __return);
        }
    }
    // [IsSpecialName] bool get_IsIPv4MappedToIPv6()
// docid: M:System.Net.IPAddress.get_IsIPv4MappedToIPv6
    open func get_IsIPv4MappedToIPv6() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__get_IsIPv4MappedToIPv6_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsIPv6LinkLocal()
// docid: M:System.Net.IPAddress.get_IsIPv6LinkLocal
    open func get_IsIPv6LinkLocal() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__get_IsIPv6LinkLocal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsIPv6Multicast()
// docid: M:System.Net.IPAddress.get_IsIPv6Multicast
    open func get_IsIPv6Multicast() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__get_IsIPv6Multicast_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsIPv6SiteLocal()
// docid: M:System.Net.IPAddress.get_IsIPv6SiteLocal
    open func get_IsIPv6SiteLocal() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__get_IsIPv6SiteLocal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsIPv6Teredo()
// docid: M:System.Net.IPAddress.get_IsIPv6Teredo
    open func get_IsIPv6Teredo() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__get_IsIPv6Teredo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsIPv6UniqueLocal()
// docid: M:System.Net.IPAddress.get_IsIPv6UniqueLocal
    open func get_IsIPv6UniqueLocal() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_bool__get_IsIPv6UniqueLocal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_ScopeId()
// docid: M:System.Net.IPAddress.get_ScopeId
    open func get_ScopeId() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPAddress_i64__get_ScopeId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ScopeId(System.Int64)
// docid: M:System.Net.IPAddress.set_ScopeId(System.Int64)
    open func set_ScopeId(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_IPAddress_void__set_ScopeId_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    An Internet Protocol (IP) address.

    */
    open var Address : Swift.Int64 {
        get {
            return try! get_Address();
        }
        set(v) {
            return try! set_Address(value: v);
        }
    }
    /**
    Gets the address family of the IP address.

    */
    open var AddressFamily : dotnet.System.Net.Sockets.AddressFamily {
        get {
            return try! get_AddressFamily();
        }
    }
    /**
    Gets whether the IP address is an IPv4-mapped IPv6 address.

    */
    open var IsIPv4MappedToIPv6 : Bool {
        get {
            return try! get_IsIPv4MappedToIPv6();
        }
    }
    /**
    Gets whether the address is an IPv6 link local address.

    */
    open var IsIPv6LinkLocal : Bool {
        get {
            return try! get_IsIPv6LinkLocal();
        }
    }
    /**
    Gets whether the address is an IPv6 multicast global address.

    */
    open var IsIPv6Multicast : Bool {
        get {
            return try! get_IsIPv6Multicast();
        }
    }
    /**
    Gets whether the address is an IPv6 site local address.

    */
    open var IsIPv6SiteLocal : Bool {
        get {
            return try! get_IsIPv6SiteLocal();
        }
    }
    /**
    Gets whether the address is an IPv6 Teredo address.

    */
    open var IsIPv6Teredo : Bool {
        get {
            return try! get_IsIPv6Teredo();
        }
    }
    /**
    Gets whether the address is an IPv6 Unique Local address.

    */
    open var IsIPv6UniqueLocal : Bool {
        get {
            return try! get_IsIPv6UniqueLocal();
        }
    }
    /**
    Gets or sets the IPv6 address scope identifier.

    */
    open var ScopeId : Swift.Int64 {
        get {
            return try! get_ScopeId();
        }
        set(v) {
            return try! set_ScopeId(value: v);
        }
    }
} // IPAddress


// type: System.Net.IPEndPoint
    /**
    Represents a network endpoint as an IP address and a port number.

    */
open class IPEndPoint
    :
    dotnet.System.Net.EndPoint
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_IPEndPoint_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Int32 MaxPort
    /**
    Specifies the maximum value that can be assigned to the  property. The MaxPort value is set to 0x0000FFFF. This field is read-only.

    */
    open class var MaxPort : Swift.Int32 {
        get {
        let __return = System_Net_IPEndPoint_get_MaxPort();
            return __return;
        }
    }
    // static field: System.Int32 MinPort
    /**
    Specifies the minimum value that can be assigned to the  property. This field is read-only.

    */
    open class var MinPort : Swift.Int32 {
        get {
        let __return = System_Net_IPEndPoint_get_MinPort();
            return __return;
        }
    }
    // .ctor(System.Int64, System.Int32)
// docid: M:System.Net.IPEndPoint.#ctor(System.Int64,System.Int32)
    /**
    Initializes a new instance of the  class with the specified address and port number.

    - Parameter address: The IP address of the Internet host. For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".
    - Parameter port: The port number associated with the , or 0 to specify any available port.  is in host order.
    */
    public init(address : Swift.Int64, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_IPEndPoint_ctor_0__2__i64_i32(&__thrown, address, port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.IPAddress, System.Int32)
// docid: M:System.Net.IPEndPoint.#ctor(System.Net.IPAddress,System.Int32)
    /**
    Initializes a new instance of the  class with the specified address and port number.

    - Parameter address: An .
    - Parameter port: The port number associated with the , or 0 to specify any available port.  is in host order.
    */
    public init(address : dotnet.System.Net.IPAddress, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_IPEndPoint_ctor_0__2__IPAddress_i32(&__thrown, address.get_handle(), port);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Net.EndPoint Create(System.Net.SocketAddress)
// docid: M:System.Net.IPEndPoint.Create(System.Net.SocketAddress)
    /**
    Creates an endpoint from a socket address.

    - Parameter socketAddress: The  to use for the endpoint.
    - Returns: An  instance using the specified socket address.

    */
    open override func Create(socketAddress : dotnet.System.Net.SocketAddress) throws -> dotnet.System.Net.EndPoint {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_EndPoint__Create_0__1__SocketAddress(&__thrown, self.get_handle(), socketAddress.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.EndPoint(hndl : __return);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Net.IPEndPoint.Equals(System.Object)
    /**
    Determines whether the specified  is equal to the current .

    - Parameter comparand: The  to compare with the current .
    - Returns: 
         if the specified  is equal to the current ; otherwise, .

    */
    open func Equals(comparand : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_bool__Equals_0__1__Object(&__thrown, self.get_handle(), comparand?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.IPEndPoint.GetHashCode
    /**
    Returns a hash value for a  instance.

    - Returns: An integer hash value.

    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Net.IPEndPoint Parse(System.ReadOnlySpan<System.Char>)
    // System.Net.IPEndPoint Parse(System.String)
// docid: M:System.Net.IPEndPoint.Parse(System.String)
    /**
    Converts an IP network endpoint (address and port) represented as a string to an  instance.

    - Parameter s: A string that contains an IP endpoint in dotted-quad notation or network byte order for IPv4 and in colon-hexadecimal notation for IPv6.
    - Returns: The object representation of an IP network endpoint.

    */
    open class func Parse(s : dotnet.System.String) throws -> dotnet.System.Net.IPEndPoint {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_IPEndPoint__Parse_0__1__String(&__thrown, s.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPEndPoint(hndl : __return);
        }
    }
    // System.Net.SocketAddress Serialize()
// docid: M:System.Net.IPEndPoint.Serialize
    /**
    Serializes endpoint information into a  instance.

    - Returns: A  instance containing the socket address for the endpoint.

    */
    open override func Serialize() throws -> dotnet.System.Net.SocketAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_SocketAddress__Serialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.SocketAddress(hndl : __return);
        }
    }
    // System.String ToString()
// docid: M:System.Net.IPEndPoint.ToString
    /**
    Returns the IP address and port number of the specified endpoint.

    - Returns: A string containing the IP address and the port number of the specified endpoint (for example, 192.168.1.2:80).

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryParse(System.ReadOnlySpan<System.Char>, ref System.Net.IPEndPoint)
    // bool TryParse(System.String, ref System.Net.IPEndPoint)
// docid: M:System.Net.IPEndPoint.TryParse(System.String,System.Net.IPEndPoint@)
    /**
    Tries to convert an IP network endpoint (address and port) represented as a string to its  equivalent, and returns a value that indicates whether the conversion succeeded.

    - Parameter s: The IP endpoint to validate.
    - Parameter result: When this method returns, the  version of .
    - Returns: 
         if  can be parsed as an IP endpoint; otherwise, .

    */
    open class func TryParse(s : dotnet.System.String, result : inout Optional<dotnet.System.Net.IPEndPoint>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_result = (result != nil) ? (result!.get_handle()) : nil;
        let __return = System_Net_IPEndPoint_bool__TryParse_0__2__String_outIPEndPoint(&__thrown, s.get_handle(), &_tmp_out_result);
        let __h__tmp2_result = _tmp_out_result;
        let _tmp2_result = (__h__tmp2_result != nil) ? dotnet.System.Net.IPEndPoint(hndl: __h__tmp2_result!) : nil;
            result = _tmp2_result;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.IPAddress get_Address()
// docid: M:System.Net.IPEndPoint.get_Address
    open func get_Address() throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_IPAddress__get_Address_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Address(System.Net.IPAddress)
// docid: M:System.Net.IPEndPoint.set_Address(System.Net.IPAddress)
    open func set_Address(value : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_IPEndPoint_void__set_Address_0__1__IPAddress(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Sockets.AddressFamily get_AddressFamily()
// docid: M:System.Net.IPEndPoint.get_AddressFamily
    open override func get_AddressFamily() throws -> dotnet.System.Net.Sockets.AddressFamily {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_AddressFamily__get_AddressFamily_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.AddressFamily(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Port()
// docid: M:System.Net.IPEndPoint.get_Port
    open func get_Port() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IPEndPoint_i32__get_Port_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Port(System.Int32)
// docid: M:System.Net.IPEndPoint.set_Port(System.Int32)
    open func set_Port(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_IPEndPoint_void__set_Port_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the IP address of the endpoint.

    */
    open var Address : dotnet.System.Net.IPAddress {
        get {
            return try! get_Address();
        }
        set(v) {
            return try! set_Address(value: v);
        }
    }
    /**
    Gets the Internet Protocol (IP) address family.

    */
    open override var AddressFamily : dotnet.System.Net.Sockets.AddressFamily {
        get {
            return try! get_AddressFamily();
        }
    }
    /**
    Gets or sets the port number of the endpoint.

    */
    open var Port : Swift.Int32 {
        get {
            return try! get_Port();
        }
        set(v) {
            return try! set_Port(value: v);
        }
    }
} // IPEndPoint


// type: System.Net.IWebProxy
    /**
    Provides the base interface for implementation of proxy access for the  class.

    */
open class IWebProxy
    :
    SGBridgeGenericValue,
    System_Net_IWebProxy
{
    open class func get_type_handle() -> TypeHandle {
        return System_Net_IWebProxy_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Uri GetProxy(System.Uri)
// docid: M:System.Net.IWebProxy.GetProxy(System.Uri)
    /**
    Returns the URI of a proxy.

    - Parameter destination: A  that specifies the requested Internet resource.
    - Returns: A  instance that contains the URI of the proxy used to contact .

    */
    open func GetProxy(destination : dotnet.System.Uri) throws -> Optional<dotnet.System.Uri> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IWebProxy_Uri__GetProxy_0__1__Uri(&__thrown, self.get_handle(), destination.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Uri(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // bool IsBypassed(System.Uri)
// docid: M:System.Net.IWebProxy.IsBypassed(System.Uri)
    /**
    Indicates that the proxy should not be used for the specified host.

    - Parameter host: The  of the host to check for proxy use.
    - Returns: 
         if the proxy server should not be used for ; otherwise, .

    */
    open func IsBypassed(host : dotnet.System.Uri) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IWebProxy_bool__IsBypassed_0__1__Uri(&__thrown, self.get_handle(), host.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.ICredentials get_Credentials()
// docid: M:System.Net.IWebProxy.get_Credentials
    open func get_Credentials() throws -> Optional<dotnet.System.Net.ICredentials> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_IWebProxy_ICredentials__get_Credentials_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.ICredentials(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Credentials(System.Net.ICredentials)
// docid: M:System.Net.IWebProxy.set_Credentials(System.Net.ICredentials)
    open func set_Credentials(value : Optional<dotnet.System.Net.ICredentials>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_IWebProxy_void__set_Credentials_0__1__ICredentials(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IWebProxy


// type: System.Net.NetworkCredential
    /**
    Provides credentials for password-based authentication schemes such as basic, digest, NTLM, and Kerberos authentication.

    */
open class NetworkCredential
    :
    dotnet.System.Object,
    System_Net_ICredentials,
    System_Net_ICredentialsByHost
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_NetworkCredential_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.NetworkCredential.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_NetworkCredential_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.SecureString)
// docid: M:System.Net.NetworkCredential.#ctor(System.String,System.Security.SecureString)
    /**
    Initializes a new instance of the  class with the specified user name and password.

    - Parameter userName: The user name associated with the credentials.
    - Parameter password: The password for the user name associated with the credentials.
    */
    public init(userName : Optional<dotnet.System.String>, password : Optional<dotnet.System.Security.SecureString>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_NetworkCredential_ctor_0__2__String_SecureString(&__thrown, userName?.get_handle() ?? nil, password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Security.SecureString, System.String)
// docid: M:System.Net.NetworkCredential.#ctor(System.String,System.Security.SecureString,System.String)
    /**
    Initializes a new instance of the  class with the specified user name, password, and domain.

    - Parameter userName: The user name associated with the credentials.
    - Parameter password: The password for the user name associated with the credentials.
    - Parameter domain: The domain associated with these credentials.
    */
    public init(userName : Optional<dotnet.System.String>, password : Optional<dotnet.System.Security.SecureString>, domain : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_NetworkCredential_ctor_0__3__String_SecureString_String(&__thrown, userName?.get_handle() ?? nil, password?.get_handle() ?? nil, domain?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String)
// docid: M:System.Net.NetworkCredential.#ctor(System.String,System.String)
    /**
    Initializes a new instance of the  class with the specified user name and password.

    - Parameter userName: The user name associated with the credentials.
    - Parameter password: The password for the user name associated with the credentials.
    */
    public init(userName : Optional<dotnet.System.String>, password : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_NetworkCredential_ctor_0__2__String_String(&__thrown, userName?.get_handle() ?? nil, password?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.String)
// docid: M:System.Net.NetworkCredential.#ctor(System.String,System.String,System.String)
    /**
    Initializes a new instance of the  class with the specified user name, password, and domain.

    - Parameter userName: The user name associated with the credentials.
    - Parameter password: The password for the user name associated with the credentials.
    - Parameter domain: The domain associated with these credentials.
    */
    public init(userName : Optional<dotnet.System.String>, password : Optional<dotnet.System.String>, domain : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_NetworkCredential_ctor_0__3__String_String_String(&__thrown, userName?.get_handle() ?? nil, password?.get_handle() ?? nil, domain?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Net.NetworkCredential GetCredential(System.String, System.Int32, System.String)
// docid: M:System.Net.NetworkCredential.GetCredential(System.String,System.Int32,System.String)
    /**
    Returns an instance of the  class for the specified host, port, and authentication type.

    - Parameter host: The host computer that authenticates the client.
    - Parameter port: The port on the  that the client communicates with.
    - Parameter authenticationType: The type of authentication requested, as defined in the  property.
    - Returns: A  for the specified host, port, and authentication protocol, or  if there are no credentials available for the specified host, port, and authentication protocol.

    */
    open /* method final */ func GetCredential(host : Optional<dotnet.System.String>, port : Swift.Int32, authenticationType : Optional<dotnet.System.String>) throws -> dotnet.System.Net.NetworkCredential {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkCredential_NetworkCredential__GetCredential_0__3__String_i32_String(&__thrown, self.get_handle(), host?.get_handle() ?? nil, port, authenticationType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.NetworkCredential(hndl : __return);
        }
    }
    // System.Net.NetworkCredential GetCredential(System.Uri, System.String)
// docid: M:System.Net.NetworkCredential.GetCredential(System.Uri,System.String)
    /**
    Returns an instance of the  class for the specified Uniform Resource Identifier (URI) and authentication type.

    - Parameter uri: The URI that the client provides authentication for.
    - Parameter authenticationType: 
    - Returns: A  object.

    */
    open /* method final */ func GetCredential(uri : Optional<dotnet.System.Uri>, authenticationType : Optional<dotnet.System.String>) throws -> dotnet.System.Net.NetworkCredential {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkCredential_NetworkCredential__GetCredential_0__2__Uri_String(&__thrown, self.get_handle(), uri?.get_handle() ?? nil, authenticationType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.NetworkCredential(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Domain()
// docid: M:System.Net.NetworkCredential.get_Domain
    open func get_Domain() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkCredential_String__get_Domain_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Domain(System.String)
// docid: M:System.Net.NetworkCredential.set_Domain(System.String)
    open func set_Domain(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_NetworkCredential_void__set_Domain_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Password()
// docid: M:System.Net.NetworkCredential.get_Password
    open func get_Password() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkCredential_String__get_Password_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Password(System.String)
// docid: M:System.Net.NetworkCredential.set_Password(System.String)
    open func set_Password(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_NetworkCredential_void__set_Password_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.SecureString get_SecurePassword()
// docid: M:System.Net.NetworkCredential.get_SecurePassword
    open func get_SecurePassword() throws -> dotnet.System.Security.SecureString {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkCredential_SecureString__get_SecurePassword_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.SecureString(hndl : __return);
        }
    }
    // [IsSpecialName] void set_SecurePassword(System.Security.SecureString)
// docid: M:System.Net.NetworkCredential.set_SecurePassword(System.Security.SecureString)
    open func set_SecurePassword(value : dotnet.System.Security.SecureString) throws {
        var __thrown : NullableHandle = nil;
        System_Net_NetworkCredential_void__set_SecurePassword_0__1__SecureString(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_UserName()
// docid: M:System.Net.NetworkCredential.get_UserName
    open func get_UserName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkCredential_String__get_UserName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_UserName(System.String)
// docid: M:System.Net.NetworkCredential.set_UserName(System.String)
    open func set_UserName(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_NetworkCredential_void__set_UserName_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the domain or computer name that verifies the credentials.

    */
    open var Domain : dotnet.System.String {
        get {
            return try! get_Domain();
        }
        set(v) {
            return try! set_Domain(value: v);
        }
    }
    /**
    Gets or sets the password for the user name associated with the credentials.

    */
    open var Password : dotnet.System.String {
        get {
            return try! get_Password();
        }
        set(v) {
            return try! set_Password(value: v);
        }
    }
    /**
    Gets or sets the password as a  instance.

    */
    open var SecurePassword : dotnet.System.Security.SecureString {
        get {
            return try! get_SecurePassword();
        }
        set(v) {
            return try! set_SecurePassword(value: v);
        }
    }
    /**
    Gets or sets the user name associated with the credentials.

    */
    open var UserName : dotnet.System.String {
        get {
            return try! get_UserName();
        }
        set(v) {
            return try! set_UserName(value: v);
        }
    }
} // NetworkCredential


// type: System.Net.SocketAddress
    /**
    Stores serialized information from  derived classes.

    */
open class SocketAddress
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_SocketAddress_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Net.Sockets.AddressFamily)
// docid: M:System.Net.SocketAddress.#ctor(System.Net.Sockets.AddressFamily)
    /**
    Creates a new instance of the  class for the given address family.

    - Parameter family: An  enumerated value.
    */
    public init(family : dotnet.System.Net.Sockets.AddressFamily) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_SocketAddress_ctor_0__1__AddressFamily(&__thrown, family.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Sockets.AddressFamily, System.Int32)
// docid: M:System.Net.SocketAddress.#ctor(System.Net.Sockets.AddressFamily,System.Int32)
    /**
    Creates a new instance of the  class using the specified address family and buffer size.

    - Parameter family: An  enumerated value.
    - Parameter size: The number of bytes to allocate for the underlying buffer.
    */
    public init(family : dotnet.System.Net.Sockets.AddressFamily, size : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_SocketAddress_ctor_0__2__AddressFamily_i32(&__thrown, family.get_value(), size);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Net.SocketAddress.Equals(System.Object)
    /**
    Determines whether the specified  is equal to the current .

    - Parameter comparand: The  to compare with the current .
    - Returns: 
         if the specified  is equal to the current ; otherwise, .

    */
    open func Equals(comparand : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_SocketAddress_bool__Equals_0__1__Object(&__thrown, self.get_handle(), comparand?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.SocketAddress.GetHashCode
    /**
    Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.

    - Returns: A hash code for the current .

    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_SocketAddress_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.String ToString()
// docid: M:System.Net.SocketAddress.ToString
    /**
    Returns information about the socket address.

    - Returns: A string that contains information about the .

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_SocketAddress_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Sockets.AddressFamily get_Family()
// docid: M:System.Net.SocketAddress.get_Family
    open func get_Family() throws -> dotnet.System.Net.Sockets.AddressFamily {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_SocketAddress_AddressFamily__get_Family_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.AddressFamily(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Size()
// docid: M:System.Net.SocketAddress.get_Size
    open func get_Size() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_SocketAddress_i32__get_Size_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Byte get_Item(System.Int32)
// docid: M:System.Net.SocketAddress.get_Item(System.Int32)
    open func get_Item(offset : Swift.Int32) throws -> Swift.UInt8 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_SocketAddress_u8__get_Item_0__1__i32(&__thrown, self.get_handle(), offset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Item(System.Int32, System.Byte)
// docid: M:System.Net.SocketAddress.set_Item(System.Int32,System.Byte)
    open func set_Item(offset : Swift.Int32, value : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
        System_Net_SocketAddress_void__set_Item_0__2__i32_u8(&__thrown, self.get_handle(), offset, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the  enumerated value of the current .

    */
    open var Family : dotnet.System.Net.Sockets.AddressFamily {
        get {
            return try! get_Family();
        }
    }
    /**
    Gets the underlying buffer size of the .

    */
    open var Size : Swift.Int32 {
        get {
            return try! get_Size();
        }
    }
} // SocketAddress


// type: System.Net.TransportContext
    /**
    The  class provides additional context about the underlying transport layer.

    */
open class TransportContext
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_TransportContext_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Authentication.ExtendedProtection.ChannelBinding GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)
// docid: M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)
    /**
    Retrieves the requested channel binding.

    - Parameter kind: The type of channel binding to retrieve.
    - Returns: The requested , or  if the channel binding is not supported by the current transport or by the operating system.

    */
    open func GetChannelBinding(kind : dotnet.System.Security.Authentication.ExtendedProtection.ChannelBindingKind) throws -> Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_TransportContext_ChannelBinding__GetChannelBinding_0__1__ChannelBindingKind(&__thrown, self.get_handle(), kind.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // TransportContext


}
// System.Net.Cache
extension System.Net.Cache {
// type: System.Net.Cache.RequestCacheLevel
    /**
    Specifies caching behavior for resources obtained using  and its derived classes.

    */
public struct RequestCacheLevel : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Cache_RequestCacheLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Cache.RequestCacheLevel Default
    /**
    Satisfies a request for a resource either by using the cached copy of the resource or by sending a request for the resource to the server. The action taken is determined by the current cache policy and the age of the content in the cache. This is the cache level that should be used by most applications.

    */
    public static var Default : dotnet.System.Net.Cache.RequestCacheLevel {
        get {
        let __return = dotnet.System.Net.Cache.RequestCacheLevel(val: System_Net_Cache_RequestCacheLevel_get_Default());
            return __return;
        }
    }
    // static field: System.Net.Cache.RequestCacheLevel BypassCache
    /**
    Satisfies a request by using the server. No entries are taken from caches, added to caches, or removed from caches between the client and server. This is the default cache behavior specified in the machine configuration file that ships with the .NET Framework.

    */
    public static var BypassCache : dotnet.System.Net.Cache.RequestCacheLevel {
        get {
        let __return = dotnet.System.Net.Cache.RequestCacheLevel(val: System_Net_Cache_RequestCacheLevel_get_BypassCache());
            return __return;
        }
    }
    // static field: System.Net.Cache.RequestCacheLevel CacheOnly
    /**
    Satisfies a request using the locally cached resource; does not send a request for an item that is not in the cache. When this cache policy level is specified, a  exception is thrown if the item is not in the client cache.

    */
    public static var CacheOnly : dotnet.System.Net.Cache.RequestCacheLevel {
        get {
        let __return = dotnet.System.Net.Cache.RequestCacheLevel(val: System_Net_Cache_RequestCacheLevel_get_CacheOnly());
            return __return;
        }
    }
    // static field: System.Net.Cache.RequestCacheLevel CacheIfAvailable
    /**
    Satisfies a request for a resource from the cache, if the resource is available; otherwise, sends a request for a resource to the server. If the requested item is available in any cache between the client and the server, the request might be satisfied by the intermediate cache.

    */
    public static var CacheIfAvailable : dotnet.System.Net.Cache.RequestCacheLevel {
        get {
        let __return = dotnet.System.Net.Cache.RequestCacheLevel(val: System_Net_Cache_RequestCacheLevel_get_CacheIfAvailable());
            return __return;
        }
    }
    // static field: System.Net.Cache.RequestCacheLevel Revalidate
    /**
    Satisfies a request by using the cached copy of the resource if the timestamp is the same as the timestamp of the resource on the server; otherwise, the resource is downloaded from the server, presented to the caller, and stored in the cache.

    */
    public static var Revalidate : dotnet.System.Net.Cache.RequestCacheLevel {
        get {
        let __return = dotnet.System.Net.Cache.RequestCacheLevel(val: System_Net_Cache_RequestCacheLevel_get_Revalidate());
            return __return;
        }
    }
    // static field: System.Net.Cache.RequestCacheLevel Reload
    /**
    Satisfies a request by using the server. The response might be saved in the cache. In the HTTP caching protocol, this is achieved using the  cache control directive and the no-cache  header.

    */
    public static var Reload : dotnet.System.Net.Cache.RequestCacheLevel {
        get {
        let __return = dotnet.System.Net.Cache.RequestCacheLevel(val: System_Net_Cache_RequestCacheLevel_get_Reload());
            return __return;
        }
    }
    // static field: System.Net.Cache.RequestCacheLevel NoCacheNoStore
    /**
    Never satisfies a request by using resources from the cache and does not cache resources. If the resource is present in the local cache, it is removed. This policy level indicates to intermediate caches that they should remove the resource. In the HTTP caching protocol, this is achieved using the  cache control directive.

    */
    public static var NoCacheNoStore : dotnet.System.Net.Cache.RequestCacheLevel {
        get {
        let __return = dotnet.System.Net.Cache.RequestCacheLevel(val: System_Net_Cache_RequestCacheLevel_get_NoCacheNoStore());
            return __return;
        }
    }
} // RequestCacheLevel


// type: System.Net.Cache.RequestCachePolicy
    /**
    Defines an application's caching requirements for resources obtained by using  objects.

    */
open class RequestCachePolicy
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Cache_RequestCachePolicy_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.Cache.RequestCachePolicy.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Cache_RequestCachePolicy_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Net.Cache.RequestCacheLevel)
// docid: M:System.Net.Cache.RequestCachePolicy.#ctor(System.Net.Cache.RequestCacheLevel)
    /**
    Initializes a new instance of the  class. using the specified cache policy.

    - Parameter level: A  that specifies the cache behavior for resources obtained using  objects.
    */
    public init(level : dotnet.System.Net.Cache.RequestCacheLevel) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Cache_RequestCachePolicy_ctor_0__1__RequestCacheLevel(&__thrown, level.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:System.Net.Cache.RequestCachePolicy.ToString
    /**
    Returns a string representation of this instance.

    - Returns: A  containing the  for this instance.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cache_RequestCachePolicy_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Cache.RequestCacheLevel get_Level()
// docid: M:System.Net.Cache.RequestCachePolicy.get_Level
    open func get_Level() throws -> dotnet.System.Net.Cache.RequestCacheLevel {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Cache_RequestCachePolicy_RequestCacheLevel__get_Level_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Cache.RequestCacheLevel(val: __return);
        }
    }
// TODO COPE (is_weird_cachelevel_case ) [IsSpecialName] System.Net.Cache.RequestCacheLevel get_Level()
} // RequestCachePolicy


}

// System.Net.NetworkInformation
extension System.Net.NetworkInformation {
// type: System.Net.NetworkInformation.IPAddressCollection
    /**
    Stores a set of  types.

    */
open class IPAddressCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_NetworkInformation_IPAddressCollection_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Add(System.Net.IPAddress)
// docid: M:System.Net.NetworkInformation.IPAddressCollection.Add(System.Net.IPAddress)
    /**
    Throws a  because this operation is not supported for this collection.

    - Parameter address: The object to be added to the collection.
    */
    open func Add(address : dotnet.System.Net.IPAddress) throws {
        var __thrown : NullableHandle = nil;
        System_Net_NetworkInformation_IPAddressCollection_void__Add_0__1__IPAddress(&__thrown, self.get_handle(), address.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Clear()
// docid: M:System.Net.NetworkInformation.IPAddressCollection.Clear
    /**
    Throws a  because this operation is not supported for this collection.

    */
    open func Clear() throws {
        var __thrown : NullableHandle = nil;
        System_Net_NetworkInformation_IPAddressCollection_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Contains(System.Net.IPAddress)
// docid: M:System.Net.NetworkInformation.IPAddressCollection.Contains(System.Net.IPAddress)
    /**
    Checks whether the collection contains the specified  object.

    - Parameter address: The  object to be searched in the collection.
    - Returns: 
         if the  object exists in the collection; otherwise, .

    */
    open func Contains(address : dotnet.System.Net.IPAddress) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkInformation_IPAddressCollection_bool__Contains_0__1__IPAddress(&__thrown, self.get_handle(), address.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void CopyTo(System.Net.IPAddress[], System.Int32)
// docid: M:System.Net.NetworkInformation.IPAddressCollection.CopyTo(System.Net.IPAddress[],System.Int32)
    /**
    Copies the elements in this collection to a one-dimensional array of type .

    - Parameter array: A one-dimensional array that receives a copy of the collection.
    - Parameter offset: The zero-based index in  at which the copy begins.
    */
    open func CopyTo(array : dotnet.System_Arr<dotnet.System.Net.IPAddress>, offset : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_NetworkInformation_IPAddressCollection_void__CopyTo_0__2__IPAddressArray_i32(&__thrown, self.get_handle(), array.get_handle(), offset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Collections.Generic.IEnumerator<System.Net.IPAddress> GetEnumerator()
// docid: M:System.Net.NetworkInformation.IPAddressCollection.GetEnumerator
    /**
    Returns an object that can be used to iterate through this collection.

    - Returns: An object that implements the  interface and provides access to the  types in this collection.

    */
    open func GetEnumerator() throws -> dotnet.System.Collections.Generic.IEnumerator_1<dotnet.System.Net.IPAddress> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkInformation_IPAddressCollection_System_Collections_Generic_IEnumerator_System_Net_IPAddress___GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerator_1(hndl : __return);
        }
    }
    // bool Remove(System.Net.IPAddress)
// docid: M:System.Net.NetworkInformation.IPAddressCollection.Remove(System.Net.IPAddress)
    /**
    Throws a  because this operation is not supported for this collection.

    - Parameter address: The object to be removed.
    - Returns: Always throws a .

    */
    open func Remove(address : dotnet.System.Net.IPAddress) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkInformation_IPAddressCollection_bool__Remove_0__1__IPAddress(&__thrown, self.get_handle(), address.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Net.NetworkInformation.IPAddressCollection.get_Count
    open func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkInformation_IPAddressCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadOnly()
// docid: M:System.Net.NetworkInformation.IPAddressCollection.get_IsReadOnly
    open func get_IsReadOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkInformation_IPAddressCollection_bool__get_IsReadOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Net.IPAddress get_Item(System.Int32)
// docid: M:System.Net.NetworkInformation.IPAddressCollection.get_Item(System.Int32)
    open func get_Item(index : Swift.Int32) throws -> dotnet.System.Net.IPAddress {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_NetworkInformation_IPAddressCollection_IPAddress__get_Item_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.IPAddress(hndl : __return);
        }
    }
    /**
    Gets the number of  types in this collection.

    */
    open var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a value that indicates whether access to this collection is read-only.

    */
    open var IsReadOnly : Bool {
        get {
            return try! get_IsReadOnly();
        }
    }
} // IPAddressCollection


}

// System.Net.Security
extension System.Net.Security {
// type: System.Net.Security.AuthenticationLevel
    /**
    Specifies client requirements for authentication and impersonation when using the  class and derived classes to request a resource.

    */
public struct AuthenticationLevel : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Security_AuthenticationLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Security.AuthenticationLevel None
    /**
    No authentication is required for the client and server.

    */
    public static var None : dotnet.System.Net.Security.AuthenticationLevel {
        get {
        let __return = dotnet.System.Net.Security.AuthenticationLevel(val: System_Net_Security_AuthenticationLevel_get_None());
            return __return;
        }
    }
    // static field: System.Net.Security.AuthenticationLevel MutualAuthRequested
    /**
    The client and server should be authenticated. The request does not fail if the server is not authenticated. To determine whether mutual authentication occurred, check the value of the  property.

    */
    public static var MutualAuthRequested : dotnet.System.Net.Security.AuthenticationLevel {
        get {
        let __return = dotnet.System.Net.Security.AuthenticationLevel(val: System_Net_Security_AuthenticationLevel_get_MutualAuthRequested());
            return __return;
        }
    }
    // static field: System.Net.Security.AuthenticationLevel MutualAuthRequired
    /**
    The client and server should be authenticated. If the server is not authenticated, your application will receive an  with a  inner exception that indicates that mutual authentication failed.

    */
    public static var MutualAuthRequired : dotnet.System.Net.Security.AuthenticationLevel {
        get {
        let __return = dotnet.System.Net.Security.AuthenticationLevel(val: System_Net_Security_AuthenticationLevel_get_MutualAuthRequired());
            return __return;
        }
    }
} // AuthenticationLevel


// type: System.Net.Security.SslPolicyErrors
    /**
    Enumerates Secure Socket Layer (SSL) policy errors.

    */
public struct SslPolicyErrors : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslPolicyErrors_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Security.SslPolicyErrors None
    /**
    No SSL policy errors.

    */
    public static var None : dotnet.System.Net.Security.SslPolicyErrors {
        get {
        let __return = dotnet.System.Net.Security.SslPolicyErrors(val: System_Net_Security_SslPolicyErrors_get_None());
            return __return;
        }
    }
    // static field: System.Net.Security.SslPolicyErrors RemoteCertificateNotAvailable
    /**
    Certificate not available.

    */
    public static var RemoteCertificateNotAvailable : dotnet.System.Net.Security.SslPolicyErrors {
        get {
        let __return = dotnet.System.Net.Security.SslPolicyErrors(val: System_Net_Security_SslPolicyErrors_get_RemoteCertificateNotAvailable());
            return __return;
        }
    }
    // static field: System.Net.Security.SslPolicyErrors RemoteCertificateNameMismatch
    /**
    Certificate name mismatch.

    */
    public static var RemoteCertificateNameMismatch : dotnet.System.Net.Security.SslPolicyErrors {
        get {
        let __return = dotnet.System.Net.Security.SslPolicyErrors(val: System_Net_Security_SslPolicyErrors_get_RemoteCertificateNameMismatch());
            return __return;
        }
    }
    // static field: System.Net.Security.SslPolicyErrors RemoteCertificateChainErrors
    /**
    
         has returned a non empty array.

    */
    public static var RemoteCertificateChainErrors : dotnet.System.Net.Security.SslPolicyErrors {
        get {
        let __return = dotnet.System.Net.Security.SslPolicyErrors(val: System_Net_Security_SslPolicyErrors_get_RemoteCertificateChainErrors());
            return __return;
        }
    }
} // SslPolicyErrors


}

// System.Net.Sockets
extension System.Net.Sockets {
// type: System.Net.Sockets.AddressFamily
    /**
    Specifies the addressing scheme that an instance of the  class can use.

    */
public struct AddressFamily : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_AddressFamily_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.AddressFamily Unknown
    /**
    Unknown address family.

    */
    public static var Unknown : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Unknown());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Unspecified
    /**
    Unspecified address family.

    */
    public static var Unspecified : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Unspecified());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Unix
    /**
    Unix local to host address.

    */
    public static var Unix : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Unix());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily InterNetwork
    /**
    Address for IP version 4.

    */
    public static var InterNetwork : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_InterNetwork());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily ImpLink
    /**
    ARPANET IMP address.

    */
    public static var ImpLink : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_ImpLink());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Pup
    /**
    Address for PUP protocols.

    */
    public static var Pup : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Pup());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Chaos
    /**
    Address for MIT CHAOS protocols.

    */
    public static var Chaos : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Chaos());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Ipx
    /**
    IPX or SPX address.

    */
    public static var Ipx : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Ipx());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily NS
    /**
    Address for Xerox NS protocols.

    */
    public static var NS : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_NS());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Iso
    /**
    Address for ISO protocols.

    */
    public static var Iso : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Iso());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Osi
    /**
    Address for OSI protocols.

    */
    public static var Osi : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Osi());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Ecma
    /**
    European Computer Manufacturers Association (ECMA) address.

    */
    public static var Ecma : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Ecma());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily DataKit
    /**
    Address for Datakit protocols.

    */
    public static var DataKit : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_DataKit());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Ccitt
    /**
    Addresses for CCITT protocols, such as X.25.

    */
    public static var Ccitt : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Ccitt());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Sna
    /**
    IBM SNA address.

    */
    public static var Sna : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Sna());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily DecNet
    /**
    DECnet address.

    */
    public static var DecNet : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_DecNet());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily DataLink
    /**
    Direct data-link interface address.

    */
    public static var DataLink : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_DataLink());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Lat
    /**
    LAT address.

    */
    public static var Lat : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Lat());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily HyperChannel
    /**
    NSC Hyperchannel address.

    */
    public static var HyperChannel : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_HyperChannel());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily AppleTalk
    /**
    AppleTalk address.

    */
    public static var AppleTalk : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_AppleTalk());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily NetBios
    /**
    NetBios address.

    */
    public static var NetBios : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_NetBios());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily VoiceView
    /**
    VoiceView address.

    */
    public static var VoiceView : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_VoiceView());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily FireFox
    /**
    FireFox address.

    */
    public static var FireFox : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_FireFox());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Banyan
    /**
    Banyan address.

    */
    public static var Banyan : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Banyan());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Atm
    /**
    Native ATM services address.

    */
    public static var Atm : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Atm());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily InterNetworkV6
    /**
    Address for IP version 6.

    */
    public static var InterNetworkV6 : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_InterNetworkV6());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Cluster
    /**
    Address for Microsoft cluster products.

    */
    public static var Cluster : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Cluster());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Ieee12844
    /**
    IEEE 1284.4 workgroup address.

    */
    public static var Ieee12844 : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Ieee12844());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Irda
    /**
    IrDA address.

    */
    public static var Irda : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Irda());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily NetworkDesigners
    /**
    Address for Network Designers OSI gateway-enabled protocols.

    */
    public static var NetworkDesigners : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_NetworkDesigners());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Max
    /**
    MAX address.

    */
    public static var Max : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Max());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily Packet
    /**
    Low-level Packet address.

    */
    public static var Packet : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_Packet());
            return __return;
        }
    }
    // static field: System.Net.Sockets.AddressFamily ControllerAreaNetwork
    /**
    Controller Area Network address.

    */
    public static var ControllerAreaNetwork : dotnet.System.Net.Sockets.AddressFamily {
        get {
        let __return = dotnet.System.Net.Sockets.AddressFamily(val: System_Net_Sockets_AddressFamily_get_ControllerAreaNetwork());
            return __return;
        }
    }
} // AddressFamily


// type: System.Net.Sockets.SocketError
    /**
    Defines error codes for the  class.

    */
public struct SocketError : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketError_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Sockets.SocketError SocketError
    /**
    An unspecified  error has occurred.

    */
    public static var SocketError : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_SocketError());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError Success
    /**
    The  operation succeeded.

    */
    public static var Success : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_Success());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError OperationAborted
    /**
    The overlapped operation was aborted due to the closure of the .

    */
    public static var OperationAborted : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_OperationAborted());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError IOPending
    /**
    The application has initiated an overlapped operation that cannot be completed immediately.

    */
    public static var IOPending : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_IOPending());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError Interrupted
    /**
    A blocking  call was canceled.

    */
    public static var Interrupted : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_Interrupted());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError AccessDenied
    /**
    An attempt was made to access a  in a way that is forbidden by its access permissions.

    */
    public static var AccessDenied : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_AccessDenied());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError Fault
    /**
    An invalid pointer address was detected by the underlying socket provider.

    */
    public static var Fault : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_Fault());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError InvalidArgument
    /**
    An invalid argument was supplied to a  member.

    */
    public static var InvalidArgument : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_InvalidArgument());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError TooManyOpenSockets
    /**
    There are too many open sockets in the underlying socket provider.

    */
    public static var TooManyOpenSockets : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_TooManyOpenSockets());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError WouldBlock
    /**
    An operation on a nonblocking socket cannot be completed immediately.

    */
    public static var WouldBlock : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_WouldBlock());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError InProgress
    /**
    A blocking operation is in progress.

    */
    public static var InProgress : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_InProgress());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError AlreadyInProgress
    /**
    The nonblocking  already has an operation in progress.

    */
    public static var AlreadyInProgress : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_AlreadyInProgress());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NotSocket
    /**
    A  operation was attempted on a non-socket.

    */
    public static var NotSocket : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NotSocket());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError DestinationAddressRequired
    /**
    A required address was omitted from an operation on a .

    */
    public static var DestinationAddressRequired : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_DestinationAddressRequired());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError MessageSize
    /**
    The datagram is too long.

    */
    public static var MessageSize : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_MessageSize());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ProtocolType
    /**
    The protocol type is incorrect for this .

    */
    public static var ProtocolType : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ProtocolType());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ProtocolOption
    /**
    An unknown, invalid, or unsupported option or level was used with a .

    */
    public static var ProtocolOption : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ProtocolOption());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ProtocolNotSupported
    /**
    The protocol is not implemented or has not been configured.

    */
    public static var ProtocolNotSupported : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ProtocolNotSupported());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError SocketNotSupported
    /**
    The support for the specified socket type does not exist in this address family.

    */
    public static var SocketNotSupported : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_SocketNotSupported());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError OperationNotSupported
    /**
    The address family is not supported by the protocol family.

    */
    public static var OperationNotSupported : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_OperationNotSupported());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ProtocolFamilyNotSupported
    /**
    The protocol family is not implemented or has not been configured.

    */
    public static var ProtocolFamilyNotSupported : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ProtocolFamilyNotSupported());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError AddressFamilyNotSupported
    /**
    The address family specified is not supported. This error is returned if the IPv6 address family was specified and the IPv6 stack is not installed on the local machine. This error is returned if the IPv4 address family was specified and the IPv4 stack is not installed on the local machine.

    */
    public static var AddressFamilyNotSupported : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_AddressFamilyNotSupported());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError AddressAlreadyInUse
    /**
    Only one use of an address is normally permitted.

    */
    public static var AddressAlreadyInUse : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_AddressAlreadyInUse());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError AddressNotAvailable
    /**
    The selected IP address is not valid in this context.

    */
    public static var AddressNotAvailable : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_AddressNotAvailable());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NetworkDown
    /**
    The network is not available.

    */
    public static var NetworkDown : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NetworkDown());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NetworkUnreachable
    /**
    No route to the remote host exists.

    */
    public static var NetworkUnreachable : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NetworkUnreachable());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NetworkReset
    /**
    The application tried to set  on a connection that has already timed out.

    */
    public static var NetworkReset : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NetworkReset());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ConnectionAborted
    /**
    The connection was aborted by .NET or the underlying socket provider.

    */
    public static var ConnectionAborted : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ConnectionAborted());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ConnectionReset
    /**
    The connection was reset by the remote peer.

    */
    public static var ConnectionReset : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ConnectionReset());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NoBufferSpaceAvailable
    /**
    No free buffer space is available for a  operation.

    */
    public static var NoBufferSpaceAvailable : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NoBufferSpaceAvailable());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError IsConnected
    /**
    The  is already connected.

    */
    public static var IsConnected : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_IsConnected());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NotConnected
    /**
    The application tried to send or receive data, and the  is not connected.

    */
    public static var NotConnected : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NotConnected());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError Shutdown
    /**
    A request to send or receive data was disallowed because the  has already been closed.

    */
    public static var Shutdown : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_Shutdown());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError TimedOut
    /**
    The connection attempt timed out, or the connected host has failed to respond.

    */
    public static var TimedOut : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_TimedOut());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ConnectionRefused
    /**
    The remote host is actively refusing a connection.

    */
    public static var ConnectionRefused : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ConnectionRefused());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError HostDown
    /**
    The operation failed because the remote host is down.

    */
    public static var HostDown : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_HostDown());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError HostUnreachable
    /**
    There is no network route to the specified host.

    */
    public static var HostUnreachable : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_HostUnreachable());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError ProcessLimit
    /**
    Too many processes are using the underlying socket provider.

    */
    public static var ProcessLimit : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_ProcessLimit());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError SystemNotReady
    /**
    The network subsystem is unavailable.

    */
    public static var SystemNotReady : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_SystemNotReady());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError VersionNotSupported
    /**
    The version of the underlying socket provider is out of range.

    */
    public static var VersionNotSupported : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_VersionNotSupported());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NotInitialized
    /**
    The underlying socket provider has not been initialized.

    */
    public static var NotInitialized : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NotInitialized());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError Disconnecting
    /**
    A graceful shutdown is in progress.

    */
    public static var Disconnecting : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_Disconnecting());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError TypeNotFound
    /**
    The specified class was not found.

    */
    public static var TypeNotFound : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_TypeNotFound());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError HostNotFound
    /**
    No such host is known. The name is not an official host name or alias.

    */
    public static var HostNotFound : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_HostNotFound());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError TryAgain
    /**
    The name of the host could not be resolved. Try again later.

    */
    public static var TryAgain : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_TryAgain());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NoRecovery
    /**
    The error is unrecoverable or the requested database cannot be located.

    */
    public static var NoRecovery : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NoRecovery());
            return __return;
        }
    }
    // static field: System.Net.Sockets.SocketError NoData
    /**
    The requested name or IP address was not found on the name server.

    */
    public static var NoData : dotnet.System.Net.Sockets.SocketError {
        get {
        let __return = dotnet.System.Net.Sockets.SocketError(val: System_Net_Sockets_SocketError_get_NoData());
            return __return;
        }
    }
} // SocketError


// type: System.Net.Sockets.SocketException
    /**
    The exception that is thrown when a socket error occurs.

    */
open class SocketException
    :
    dotnet.System.ComponentModel.Win32Exception
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Sockets_SocketException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.Sockets.SocketException.#ctor
    /**
    Initializes a new instance of the  class with the last operating system error code.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SocketException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Net.Sockets.SocketException.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with the specified error code.

    - Parameter errorCode: The error code that indicates the error that occurred.
    */
    public init(errorCode : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Sockets_SocketException_ctor_0__1__i32(&__thrown, errorCode);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_ErrorCode()
// docid: M:System.Net.Sockets.SocketException.get_ErrorCode
    open override func get_ErrorCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketException_i32__get_ErrorCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Message()
// docid: M:System.Net.Sockets.SocketException.get_Message
    open override func get_Message() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketException_String__get_Message_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Sockets.SocketError get_SocketErrorCode()
// docid: M:System.Net.Sockets.SocketException.get_SocketErrorCode
    open func get_SocketErrorCode() throws -> dotnet.System.Net.Sockets.SocketError {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Sockets_SocketException_SocketError__get_SocketErrorCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.SocketError(val: __return);
        }
    }
    /**
    Gets the error code that is associated with this exception.

    */
    open override var ErrorCode : Swift.Int32 {
        get {
            return try! get_ErrorCode();
        }
    }
    /**
    Gets the error message that is associated with this exception.

    */
    open override var Message : dotnet.System.String {
        get {
            return try! get_Message();
        }
    }
    /**
    Gets the error code that is associated with this exception.

    */
    open var SocketErrorCode : dotnet.System.Net.Sockets.SocketError {
        get {
            return try! get_SocketErrorCode();
        }
    }
} // SocketException


}


// System.Security
// System.Security.Authentication
extension System.Security.Authentication {
// type: System.Security.Authentication.CipherAlgorithmType
    /**
    Defines the possible cipher algorithms for the  class.

    */
public struct CipherAlgorithmType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_CipherAlgorithmType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Authentication.CipherAlgorithmType None
    /**
    No encryption algorithm is used.

    */
    public static var None : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_None());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Null
    /**
    No encryption is used with a Null cipher algorithm.

    */
    public static var Null : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Null());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Des
    /**
    The Data Encryption Standard (DES) algorithm.

    */
    public static var Des : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Des());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Rc2
    /**
    Rivest's Code 2 (RC2) algorithm.

    */
    public static var Rc2 : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Rc2());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType TripleDes
    /**
    The Triple Data Encryption Standard (3DES) algorithm.

    */
    public static var TripleDes : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_TripleDes());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Aes128
    /**
    The Advanced Encryption Standard (AES) algorithm with a 128 bit key.

    */
    public static var Aes128 : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Aes128());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Aes192
    /**
    The Advanced Encryption Standard (AES) algorithm with a 192 bit key.

    */
    public static var Aes192 : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Aes192());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Aes256
    /**
    The Advanced Encryption Standard (AES) algorithm with a 256 bit key.

    */
    public static var Aes256 : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Aes256());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Aes
    /**
    The Advanced Encryption Standard (AES) algorithm.

    */
    public static var Aes : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Aes());
            return __return;
        }
    }
    // static field: System.Security.Authentication.CipherAlgorithmType Rc4
    /**
    Rivest's Code 4 (RC4) algorithm.

    */
    public static var Rc4 : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.CipherAlgorithmType(val: System_Security_Authentication_CipherAlgorithmType_get_Rc4());
            return __return;
        }
    }
} // CipherAlgorithmType


// type: System.Security.Authentication.ExchangeAlgorithmType
    /**
    Specifies the algorithm used to create keys shared by the client and server.

    */
public struct ExchangeAlgorithmType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_ExchangeAlgorithmType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Authentication.ExchangeAlgorithmType None
    /**
    No key exchange algorithm is used.

    */
    public static var None : dotnet.System.Security.Authentication.ExchangeAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.ExchangeAlgorithmType(val: System_Security_Authentication_ExchangeAlgorithmType_get_None());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExchangeAlgorithmType RsaSign
    /**
    The RSA public-key signature algorithm.

    */
    public static var RsaSign : dotnet.System.Security.Authentication.ExchangeAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.ExchangeAlgorithmType(val: System_Security_Authentication_ExchangeAlgorithmType_get_RsaSign());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExchangeAlgorithmType RsaKeyX
    /**
    The RSA public-key exchange algorithm.

    */
    public static var RsaKeyX : dotnet.System.Security.Authentication.ExchangeAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.ExchangeAlgorithmType(val: System_Security_Authentication_ExchangeAlgorithmType_get_RsaKeyX());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExchangeAlgorithmType DiffieHellman
    /**
    The Diffie Hellman ephemeral key exchange algorithm.

    */
    public static var DiffieHellman : dotnet.System.Security.Authentication.ExchangeAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.ExchangeAlgorithmType(val: System_Security_Authentication_ExchangeAlgorithmType_get_DiffieHellman());
            return __return;
        }
    }
} // ExchangeAlgorithmType


// type: System.Security.Authentication.HashAlgorithmType
    /**
    Specifies the algorithm used for generating message authentication codes (MACs).

    */
public struct HashAlgorithmType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_HashAlgorithmType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Authentication.HashAlgorithmType None
    /**
    No hashing algorithm is used.

    */
    public static var None : dotnet.System.Security.Authentication.HashAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.HashAlgorithmType(val: System_Security_Authentication_HashAlgorithmType_get_None());
            return __return;
        }
    }
    // static field: System.Security.Authentication.HashAlgorithmType Md5
    /**
    
        The Message Digest 5 (MD5) hashing algorithm.
        Due to collision problems with MD5, Microsoft recommends SHA256.
      

    */
    public static var Md5 : dotnet.System.Security.Authentication.HashAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.HashAlgorithmType(val: System_Security_Authentication_HashAlgorithmType_get_Md5());
            return __return;
        }
    }
    // static field: System.Security.Authentication.HashAlgorithmType Sha1
    /**
    
        The Secure Hashing Algorithm (SHA1).
        Due to collision problems with MD5, Microsoft recommends SHA256.
      

    */
    public static var Sha1 : dotnet.System.Security.Authentication.HashAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.HashAlgorithmType(val: System_Security_Authentication_HashAlgorithmType_get_Sha1());
            return __return;
        }
    }
    // static field: System.Security.Authentication.HashAlgorithmType Sha256
    /**
    The Secure Hashing Algorithm 2 (SHA-2), using a 256-bit digest.

    */
    public static var Sha256 : dotnet.System.Security.Authentication.HashAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.HashAlgorithmType(val: System_Security_Authentication_HashAlgorithmType_get_Sha256());
            return __return;
        }
    }
    // static field: System.Security.Authentication.HashAlgorithmType Sha384
    /**
    The Secure Hashing Algorithm 2 (SHA-2), using a 384-bit digest.

    */
    public static var Sha384 : dotnet.System.Security.Authentication.HashAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.HashAlgorithmType(val: System_Security_Authentication_HashAlgorithmType_get_Sha384());
            return __return;
        }
    }
    // static field: System.Security.Authentication.HashAlgorithmType Sha512
    /**
    The Secure Hashing Algorithm 2 (SHA-2), using a 512-bit digest.

    */
    public static var Sha512 : dotnet.System.Security.Authentication.HashAlgorithmType {
        get {
        let __return = dotnet.System.Security.Authentication.HashAlgorithmType(val: System_Security_Authentication_HashAlgorithmType_get_Sha512());
            return __return;
        }
    }
} // HashAlgorithmType


// type: System.Security.Authentication.SslProtocols
    /**
    Defines the possible versions of .

    */
public struct SslProtocols : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_SslProtocols_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Authentication.SslProtocols None
    /**
    Allows the operating system to choose the best protocol to use, and to block protocols that are not secure. Unless your app has a specific reason not to, you should use this field.

    */
    public static var None : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_None());
            return __return;
        }
    }
    // static field: System.Security.Authentication.SslProtocols Ssl2
    /**
    Specifies the SSL 2.0 protocol. SSL 2.0 has been superseded by the TLS protocol and is provided for backward compatibility only.

    */
    public static var Ssl2 : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_Ssl2());
            return __return;
        }
    }
    // static field: System.Security.Authentication.SslProtocols Ssl3
    /**
    Specifies the SSL 3.0 protocol. SSL 3.0 has been superseded by the TLS protocol and is provided for backward compatibility only.

    */
    public static var Ssl3 : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_Ssl3());
            return __return;
        }
    }
    // static field: System.Security.Authentication.SslProtocols Tls
    /**
    Specifies the TLS 1.0 security protocol.  TLS 1.0 is provided for backward compatibility only. The TLS protocol is defined in IETF RFC 2246.

    */
    public static var Tls : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_Tls());
            return __return;
        }
    }
    // static field: System.Security.Authentication.SslProtocols Default
    /**
    Use None instead of Default. Default permits only the Secure Sockets Layer (SSL) 3.0 or Transport Layer Security (TLS) 1.0 protocols to be negotiated, and those options are now considered obsolete. Consequently, Default is not allowed in many organizations. Despite the name of this field,  does not use it as a default except under special circumstances.

    */
    public static var Default : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_Default());
            return __return;
        }
    }
    // static field: System.Security.Authentication.SslProtocols Tls11
    /**
    Specifies the TLS 1.1 security protocol. The TLS protocol is defined in IETF RFC 4346.

    */
    public static var Tls11 : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_Tls11());
            return __return;
        }
    }
    // static field: System.Security.Authentication.SslProtocols Tls12
    /**
    Specifies the TLS 1.2 security protocol. The TLS protocol is defined in IETF RFC 5246.

    */
    public static var Tls12 : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_Tls12());
            return __return;
        }
    }
    // static field: System.Security.Authentication.SslProtocols Tls13
    /**
    Specifies the TLS 1.3 security protocol. The TLS protocol is defined in IETF RFC 8446.

    */
    public static var Tls13 : dotnet.System.Security.Authentication.SslProtocols {
        get {
        let __return = dotnet.System.Security.Authentication.SslProtocols(val: System_Security_Authentication_SslProtocols_get_Tls13());
            return __return;
        }
    }
} // SslProtocols


}
// System.Security.Authentication.ExtendedProtection
extension System.Security.Authentication.ExtendedProtection {
// type: System.Security.Authentication.ExtendedProtection.ChannelBinding
    /**
    The  class encapsulates a pointer to the opaque data used to bind an authenticated transaction to a secure channel.

    */
open class ChannelBinding
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_ExtendedProtection_ChannelBinding_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.Int32 get_Size()
// docid: M:System.Security.Authentication.ExtendedProtection.ChannelBinding.get_Size
    open func get_Size() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ChannelBinding_i32__get_Size_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    The  property gets the size, in bytes, of the channel binding token associated with the  instance.

    */
    open var Size : Swift.Int32 {
        get {
            return try! get_Size();
        }
    }
} // ChannelBinding


// type: System.Security.Authentication.ExtendedProtection.ChannelBindingKind
    /**
    The  enumeration represents the kinds of channel bindings that can be queried from secure channels.

    */
public struct ChannelBindingKind : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_ExtendedProtection_ChannelBindingKind_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Authentication.ExtendedProtection.ChannelBindingKind Unknown
    /**
    An unknown channel binding type.

    */
    public static var Unknown : dotnet.System.Security.Authentication.ExtendedProtection.ChannelBindingKind {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.ChannelBindingKind(val: System_Security_Authentication_ExtendedProtection_ChannelBindingKind_get_Unknown());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExtendedProtection.ChannelBindingKind Unique
    /**
    A channel binding completely unique to a given channel (a TLS session key, for example).

    */
    public static var Unique : dotnet.System.Security.Authentication.ExtendedProtection.ChannelBindingKind {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.ChannelBindingKind(val: System_Security_Authentication_ExtendedProtection_ChannelBindingKind_get_Unique());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExtendedProtection.ChannelBindingKind Endpoint
    /**
    A channel binding unique to a given endpoint (a TLS server certificate, for example).

    */
    public static var Endpoint : dotnet.System.Security.Authentication.ExtendedProtection.ChannelBindingKind {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.ChannelBindingKind(val: System_Security_Authentication_ExtendedProtection_ChannelBindingKind_get_Endpoint());
            return __return;
        }
    }
} // ChannelBindingKind


}




public protocol System_Net_ICredentials
    :
    SGBridgeGetHandle
{
}

public protocol System_Net_ICredentialsByHost
    :
    SGBridgeGetHandle
{
}

public protocol System_Net_IWebProxy
    :
    SGBridgeGetHandle
{
}

