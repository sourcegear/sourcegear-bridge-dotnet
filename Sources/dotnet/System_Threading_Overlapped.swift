// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
// System.Threading
extension System.Threading {
// type: System.Threading.IOCompletionCallback
    /**
    Receives the error code, number of bytes, and overlapped value type when an I/O operation completes on the thread pool.

    */
public final class IOCompletionCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_IOCompletionCallback_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
// TODO COPE (parm pointer other): void Invoke(System.UInt32, System.UInt32, System.Threading.NativeOverlapped*)
// TODO COPE (parm pointer other): System.IAsyncResult BeginInvoke(System.UInt32, System.UInt32, System.Threading.NativeOverlapped*, System.AsyncCallback, System.Object)
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.Threading.IOCompletionCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_IOCompletionCallback_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (parm pointer other): void Invoke(System.UInt32, System.UInt32, System.Threading.NativeOverlapped*)
} // IOCompletionCallback


// type: System.Threading.NativeOverlapped
// boxed value type
    /**
    Provides an explicit layout that is visible from unmanaged code and that will have the same layout as the Win32 OVERLAPPED structure with additional reserved fields at the end.

    */
public final class NativeOverlapped
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_NativeOverlapped_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Threading_NativeOverlapped_implicit_ctor();
            super.init(hndl: h);
    }
} // NativeOverlapped


// type: System.Threading.Overlapped
    /**
    Provides a managed representation of a Win32 OVERLAPPED structure, including methods to transfer information from an  instance to a  structure.

    */
open class Overlapped
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Overlapped_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Threading_Overlapped_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:System.Threading.Overlapped.#ctor
    /**
    Initializes a new, empty instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Overlapped_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Int32, System.Int32, System.IAsyncResult)
// docid: M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)
    /**
    Initializes a new instance of the  class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.

    - Parameter offsetLo: The low word of the file position at which to start the transfer.
    - Parameter offsetHi: The high word of the file position at which to start the transfer.
    - Parameter hEvent: The handle to an event that is signaled when the I/O operation is complete.
    - Parameter ar: An object that implements the  interface and provides status information on the I/O operation.
    */
    public init(offsetLo : Swift.Int32, offsetHi : Swift.Int32, hEvent : Swift.Int32, ar : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Overlapped_ctor_0__4__i32_i32_i32_IAsyncResult(&__thrown, offsetLo, offsetHi, hEvent, ar?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Int32, System.IntPtr, System.IAsyncResult)
// docid: M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)
    /**
    Initializes a new instance of the  class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.

    - Parameter offsetLo: The low word of the file position at which to start the transfer.
    - Parameter offsetHi: The high word of the file position at which to start the transfer.
    - Parameter hEvent: The handle to an event that is signaled when the I/O operation is complete.
    - Parameter ar: An object that implements the  interface and provides status information on the I/O operation.
    */
    public init(offsetLo : Swift.Int32, offsetHi : Swift.Int32, hEvent : dotnet.System.IntPtr, ar : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Overlapped_ctor_0__4__i32_i32_IntPtr_IAsyncResult(&__thrown, offsetLo, offsetHi, hEvent.get_value(), ar?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE (parm pointer other): void Free(System.Threading.NativeOverlapped*)
// TODO COPE (returns pointer other): System.Threading.NativeOverlapped* Pack(System.Threading.IOCompletionCallback)
// TODO COPE (returns pointer other): System.Threading.NativeOverlapped* Pack(System.Threading.IOCompletionCallback, System.Object)
// TODO COPE (parm pointer other): System.Threading.Overlapped Unpack(System.Threading.NativeOverlapped*)
// TODO COPE (returns pointer other): System.Threading.NativeOverlapped* UnsafePack(System.Threading.IOCompletionCallback)
// TODO COPE (returns pointer other): System.Threading.NativeOverlapped* UnsafePack(System.Threading.IOCompletionCallback, System.Object)
    // [IsSpecialName] System.IAsyncResult get_AsyncResult()
// docid: M:System.Threading.Overlapped.get_AsyncResult
    open func get_AsyncResult() throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Overlapped_IAsyncResult__get_AsyncResult_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AsyncResult(System.IAsyncResult)
// docid: M:System.Threading.Overlapped.set_AsyncResult(System.IAsyncResult)
    open func set_AsyncResult(value : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Overlapped_void__set_AsyncResult_0__1__IAsyncResult(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_EventHandle()
// docid: M:System.Threading.Overlapped.get_EventHandle
    open func get_EventHandle() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Overlapped_i32__get_EventHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_EventHandle(System.Int32)
// docid: M:System.Threading.Overlapped.set_EventHandle(System.Int32)
    open func set_EventHandle(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Overlapped_void__set_EventHandle_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IntPtr get_EventHandleIntPtr()
// docid: M:System.Threading.Overlapped.get_EventHandleIntPtr
    open func get_EventHandleIntPtr() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Overlapped_IntPtr__get_EventHandleIntPtr_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] void set_EventHandleIntPtr(System.IntPtr)
// docid: M:System.Threading.Overlapped.set_EventHandleIntPtr(System.IntPtr)
    open func set_EventHandleIntPtr(value : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Overlapped_void__set_EventHandleIntPtr_0__1__IntPtr(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_OffsetHigh()
// docid: M:System.Threading.Overlapped.get_OffsetHigh
    open func get_OffsetHigh() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Overlapped_i32__get_OffsetHigh_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_OffsetHigh(System.Int32)
// docid: M:System.Threading.Overlapped.set_OffsetHigh(System.Int32)
    open func set_OffsetHigh(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Overlapped_void__set_OffsetHigh_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_OffsetLow()
// docid: M:System.Threading.Overlapped.get_OffsetLow
    open func get_OffsetLow() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Overlapped_i32__get_OffsetLow_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_OffsetLow(System.Int32)
// docid: M:System.Threading.Overlapped.set_OffsetLow(System.Int32)
    open func set_OffsetLow(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Overlapped_void__set_OffsetLow_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the object that provides status information on the I/O operation.

    */
    open var AsyncResult : Optional<dotnet.System.IAsyncResult> {
        get {
            return try! get_AsyncResult();
        }
        set(v) {
            return try! set_AsyncResult(value: v!);
        }
    }
    /**
    Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.

    */
    open var EventHandle : Swift.Int32 {
        get {
            return try! get_EventHandle();
        }
        set(v) {
            return try! set_EventHandle(value: v);
        }
    }
    /**
    Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.

    */
    open var EventHandleIntPtr : dotnet.System.IntPtr {
        get {
            return try! get_EventHandleIntPtr();
        }
        set(v) {
            return try! set_EventHandleIntPtr(value: v);
        }
    }
    /**
    Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.

    */
    open var OffsetHigh : Swift.Int32 {
        get {
            return try! get_OffsetHigh();
        }
        set(v) {
            return try! set_OffsetHigh(value: v);
        }
    }
    /**
    Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.

    */
    open var OffsetLow : Swift.Int32 {
        get {
            return try! get_OffsetLow();
        }
        set(v) {
            return try! set_OffsetLow(value: v);
        }
    }
} // Overlapped


// type: System.Threading.PreAllocatedOverlapped
    /**
    Represents pre-allocated state for native overlapped I/O operations.

    */
public final class PreAllocatedOverlapped
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_PreAllocatedOverlapped_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Threading_PreAllocatedOverlapped_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.Threading.IOCompletionCallback, System.Object, System.Object)
// docid: M:System.Threading.PreAllocatedOverlapped.#ctor(System.Threading.IOCompletionCallback,System.Object,System.Object)
    /**
    Initializes a new instance of the  class and specifies a delegate to invoke when each asynchronous I/O operation is complete, a user-provided object that provides context, and managed objects that serve as buffers.

    - Parameter callback: A delegate that represents the callback method to invoke when each asynchronous I/O operation completes.
    - Parameter state: A user-supplied object that distinguishes the  instance produced from this object from other  instances. Its value can be .
    - Parameter pinData: An object or array of objects that represent the input or output buffer for the operations. Each object represents a buffer, such as an array of bytes. Its value can be .
    */
    public init(callback : dotnet.System.Threading.IOCompletionCallback, state : Optional<dotnet.System.Object>, pinData : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_PreAllocatedOverlapped_ctor_0__3__IOCompletionCallback_Object_Object(&__thrown, callback.get_handle(), state?.get_handle() ?? nil, pinData?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:System.Threading.PreAllocatedOverlapped.Dispose
    /**
    Frees the resources associated with this  instance.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_PreAllocatedOverlapped_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.PreAllocatedOverlapped UnsafeCreate(System.Threading.IOCompletionCallback, System.Object, System.Object)
// docid: M:System.Threading.PreAllocatedOverlapped.UnsafeCreate(System.Threading.IOCompletionCallback,System.Object,System.Object)
    /**
    Initializes a new instance of the  class, specifying a delegate that is invoked when each asynchronous I/O operation is complete, a user-provided object providing context, and managed objects that serve as buffers.

    - Parameter callback: An  delegate that represents the callback method invoked when each asynchronous I/O operation completes.
    - Parameter state: A user-provided object that distinguishes  instance produced from this object from other  instances. Can be .
    - Parameter pinData: An object or array of objects representing the input or output buffer for the operations. Each object represents a buffer, for example an array of bytes.  Can be .
    - Returns: The new  instance.

    */
    public class func UnsafeCreate(callback : dotnet.System.Threading.IOCompletionCallback, state : Optional<dotnet.System.Object>, pinData : Optional<dotnet.System.Object>) throws -> dotnet.System.Threading.PreAllocatedOverlapped {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_PreAllocatedOverlapped_PreAllocatedOverlapped__UnsafeCreate_0__3__IOCompletionCallback_Object_Object(&__thrown, callback.get_handle(), state?.get_handle() ?? nil, pinData?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.PreAllocatedOverlapped(hndl : __return);
        }
    }
} // PreAllocatedOverlapped


// type: System.Threading.ThreadPoolBoundHandle
    /**
    Represents an I/O handle that is bound to the system thread pool and enables low-level components to receive notifications for asynchronous I/O operations.

    */
public final class ThreadPoolBoundHandle
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_ThreadPoolBoundHandle_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = System_Threading_ThreadPoolBoundHandle_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
// TODO COPE (returns pointer other): System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.IOCompletionCallback, System.Object, System.Object)
// TODO COPE (returns pointer other): System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.PreAllocatedOverlapped)
    // System.Threading.ThreadPoolBoundHandle BindHandle(System.Runtime.InteropServices.SafeHandle)
// docid: M:System.Threading.ThreadPoolBoundHandle.BindHandle(System.Runtime.InteropServices.SafeHandle)
    /**
    Returns a  for the specified handle, which is bound to the system thread pool.

    - Parameter handle: An object that holds the operating system handle. The handle must have been opened for overlapped I/O in unmanaged code.
    - Returns: A  for , which is bound to the system thread pool.

    */
    public class func BindHandle(handle : dotnet.System.Runtime.InteropServices.SafeHandle) throws -> dotnet.System.Threading.ThreadPoolBoundHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPoolBoundHandle_ThreadPoolBoundHandle__BindHandle_0__1__SafeHandle(&__thrown, handle.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.ThreadPoolBoundHandle(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Threading.ThreadPoolBoundHandle.Dispose
    /**
    Releases all unmanaged resources used by the  instance.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ThreadPoolBoundHandle_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (parm pointer other): void FreeNativeOverlapped(System.Threading.NativeOverlapped*)
// TODO COPE (parm pointer other): System.Object GetNativeOverlappedState(System.Threading.NativeOverlapped*)
// TODO COPE (returns pointer other): System.Threading.NativeOverlapped* UnsafeAllocateNativeOverlapped(System.Threading.IOCompletionCallback, System.Object, System.Object)
    // [IsSpecialName] System.Runtime.InteropServices.SafeHandle get_Handle()
// docid: M:System.Threading.ThreadPoolBoundHandle.get_Handle
    public func get_Handle() throws -> dotnet.System.Runtime.InteropServices.SafeHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPoolBoundHandle_SafeHandle__get_Handle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Runtime.InteropServices.SafeHandle(hndl : __return);
        }
    }
    /**
    Gets the bound operating system handle.

    */
    public var Handle : dotnet.System.Runtime.InteropServices.SafeHandle {
        get {
            return try! get_Handle();
        }
    }
} // ThreadPoolBoundHandle


}


