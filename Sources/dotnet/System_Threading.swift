// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;

// System
// System.Threading
extension System.Threading {
// type: System.Threading.AbandonedMutexException
    /**
    The exception that is thrown when one thread acquires a  object that another thread has abandoned by exiting without releasing it.

    */
open class AbandonedMutexException
    :
    dotnet.System.SystemException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_AbandonedMutexException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.AbandonedMutexException.#ctor
    /**
    Initializes a new instance of the  class with default values.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AbandonedMutexException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Threading.WaitHandle)
// docid: M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)
    /**
    Initializes a new instance of the  class with a specified index for the abandoned mutex, if applicable, and a  object that represents the mutex.

    - Parameter location: The index of the abandoned mutex in the array of wait handles if the exception is thrown for the  method, or -1 if the exception is thrown for the  or  methods.
    - Parameter handle: A  object that represents the abandoned mutex.
    */
    public init(location : Swift.Int32, handle : Optional<dotnet.System.Threading.WaitHandle>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AbandonedMutexException_ctor_0__2__i32_WaitHandle(&__thrown, location, handle?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Threading.AbandonedMutexException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified error message.

    - Parameter message: An error message that explains the reason for the exception.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AbandonedMutexException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and inner exception.

    - Parameter message: An error message that explains the reason for the exception.
    - Parameter inner: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public init(message : Optional<dotnet.System.String>, inner : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AbandonedMutexException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, inner?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception, System.Int32, System.Threading.WaitHandle)
// docid: M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)
    /**
    Initializes a new instance of the  class with a specified error message, the inner exception, the index for the abandoned mutex, if applicable, and a  object that represents the mutex.

    - Parameter message: An error message that explains the reason for the exception.
    - Parameter inner: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    - Parameter location: The index of the abandoned mutex in the array of wait handles if the exception is thrown for the  method, or -1 if the exception is thrown for the  or  methods.
    - Parameter handle: A  object that represents the abandoned mutex.
    */
    public init(message : Optional<dotnet.System.String>, inner : Optional<dotnet.System.Exception>, location : Swift.Int32, handle : Optional<dotnet.System.Threading.WaitHandle>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AbandonedMutexException_ctor_0__4__String_Exception_i32_WaitHandle(&__thrown, message?.get_handle() ?? nil, inner?.get_handle() ?? nil, location, handle?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32, System.Threading.WaitHandle)
// docid: M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)
    /**
    Initializes a new instance of the  class with a specified error message, the index of the abandoned mutex, if applicable, and the abandoned mutex.

    - Parameter message: An error message that explains the reason for the exception.
    - Parameter location: The index of the abandoned mutex in the array of wait handles if the exception is thrown for the  method, or -1 if the exception is thrown for the  or  methods.
    - Parameter handle: A  object that represents the abandoned mutex.
    */
    public init(message : Optional<dotnet.System.String>, location : Swift.Int32, handle : Optional<dotnet.System.Threading.WaitHandle>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AbandonedMutexException_ctor_0__3__String_i32_WaitHandle(&__thrown, message?.get_handle() ?? nil, location, handle?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Threading.Mutex get_Mutex()
// docid: M:System.Threading.AbandonedMutexException.get_Mutex
    open func get_Mutex() throws -> Optional<dotnet.System.Threading.Mutex> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AbandonedMutexException_Mutex__get_Mutex_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Mutex(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_MutexIndex()
// docid: M:System.Threading.AbandonedMutexException.get_MutexIndex
    open func get_MutexIndex() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AbandonedMutexException_i32__get_MutexIndex_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the abandoned mutex that caused the exception, if known.

    */
    open var Mutex : Optional<dotnet.System.Threading.Mutex> {
        get {
            return try! get_Mutex();
        }
    }
    /**
    Gets the index of the abandoned mutex that caused the exception, if known.

    */
    open var MutexIndex : Swift.Int32 {
        get {
            return try! get_MutexIndex();
        }
    }
} // AbandonedMutexException


// type: System.Threading.AsyncFlowControl
// boxed value type
    /**
    Provides the functionality to restore the migration, or flow, of the execution context between threads.

    */
public final class AsyncFlowControl
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_AsyncFlowControl_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Threading_AsyncFlowControl_implicit_ctor();
            super.init(hndl: h);
    }
    // void Dispose()
// docid: M:System.Threading.AsyncFlowControl.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_AsyncFlowControl_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Threading.AsyncFlowControl.Equals(System.Object)
    /**
    Determines whether the specified object is equal to the current  structure.

    - Parameter obj: An object to compare with the current structure.
    - Returns: 
         if  is an  structure and is equal to the current  structure; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncFlowControl_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Threading.AsyncFlowControl)
// docid: M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)
    /**
    Determines whether the specified  structure is equal to the current  structure.

    - Parameter obj: An  structure to compare with the current structure.
    - Returns: 
         if  is equal to the current  structure; otherwise, .

    */
    public func Equals(obj : dotnet.System.Threading.AsyncFlowControl) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncFlowControl_bool__Equals_0__1__AsyncFlowControl(&__thrown, self.get_handle(), obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Threading.AsyncFlowControl.GetHashCode
    /**
    Gets a hash code for the current  structure.

    - Returns: A hash code for the current  structure.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncFlowControl_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Threading.AsyncFlowControl, System.Threading.AsyncFlowControl)
// docid: M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)
    /**
    Compares two  structures to determine whether they are equal.

    - Parameter a: An  structure.
    - Parameter b: An  structure.
    - Returns: 
         if the two structures are equal; otherwise, .

    */
    public class func op_Equality(a : dotnet.System.Threading.AsyncFlowControl, b : dotnet.System.Threading.AsyncFlowControl) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncFlowControl_bool__op_Equality_0__2__AsyncFlowControl_AsyncFlowControl(&__thrown, a.get_handle(), b.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Threading.AsyncFlowControl, System.Threading.AsyncFlowControl)
// docid: M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)
    /**
    Compares two  structures to determine whether they are not equal.

    - Parameter a: An  structure.
    - Parameter b: An  structure.
    - Returns: 
         if the structures are not equal; otherwise, .

    */
    public class func op_Inequality(a : dotnet.System.Threading.AsyncFlowControl, b : dotnet.System.Threading.AsyncFlowControl) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncFlowControl_bool__op_Inequality_0__2__AsyncFlowControl_AsyncFlowControl(&__thrown, a.get_handle(), b.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Undo()
// docid: M:System.Threading.AsyncFlowControl.Undo
    /**
    Restores the flow of the execution context between threads.

    */
    public func Undo() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_AsyncFlowControl_void__Undo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // AsyncFlowControl


// type: System.Threading.AsyncLocalValueChangedArgs`1
// boxed value type
    /**
    The class that provides data change information to  instances that register for change notifications.

    */
public final class AsyncLocalValueChangedArgs_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_AsyncLocalValueChangedArgs_1_get_type_handle(T.get_type_handle());
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the data's current value.

    */
    public var CurrentValue : T {
        get {
            return try! get_CurrentValue();
        }
    }
    /**
    Gets the data's previous value.

    */
    public var PreviousValue : T {
        get {
            return try! get_PreviousValue();
        }
    }
    /**
    Returns a value that indicates whether the value changes because of a change of execution context.

    */
    public var ThreadContextChanged : Bool {
        get {
            return try! get_ThreadContextChanged();
        }
    }
    public override init() {
        let h = System_Threading_AsyncLocalValueChangedArgs_1_implicit_ctor(T.get_type_handle());
            super.init(hndl: h);
    }
    // [IsSpecialName] T get_CurrentValue()
// docid: M:System.Threading.AsyncLocalValueChangedArgs`1.get_CurrentValue
    public func get_CurrentValue() throws -> T {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncLocalValueChangedArgs_1_T__get_CurrentValue_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return T(gval: __return);
        }
    }
    // [IsSpecialName] T get_PreviousValue()
// docid: M:System.Threading.AsyncLocalValueChangedArgs`1.get_PreviousValue
    public func get_PreviousValue() throws -> T {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncLocalValueChangedArgs_1_T__get_PreviousValue_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return T(gval: __return);
        }
    }
    // [IsSpecialName] bool get_ThreadContextChanged()
// docid: M:System.Threading.AsyncLocalValueChangedArgs`1.get_ThreadContextChanged
    public func get_ThreadContextChanged() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncLocalValueChangedArgs_1_bool__get_ThreadContextChanged_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // AsyncLocalValueChangedArgs_1


// type: System.Threading.AsyncLocal`1
    /**
    Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.

    */
public final class AsyncLocal_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_AsyncLocal_1_get_type_handle(T.get_type_handle());
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.AsyncLocal`1.#ctor
    /**
    Instantiates an  instance that does not receive change notifications.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AsyncLocal_1_ctor_0__0(T.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Action<System.Threading.AsyncLocalValueChangedArgs<T>>)
// docid: M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})
    /**
    Instantiates an  local instance that receives change notifications.

    - Parameter valueChangedHandler: The delegate that is called whenever the current value changes on any thread.
    */
    public init(valueChangedHandler : Optional<dotnet.System.Action_1<dotnet.System.Threading.AsyncLocalValueChangedArgs_1<T>>>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AsyncLocal_1_ctor_0__1__System_Action_System_Threading_System_Threading_AsyncLocalValueChangedArgs_T__(T.get_type_handle(), &__thrown, (valueChangedHandler?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] T get_Value()
// docid: M:System.Threading.AsyncLocal`1.get_Value
    public func get_Value() throws -> T {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_AsyncLocal_1_T__get_Value_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return T(gval: __return);
        }
    }
    // [IsSpecialName] void set_Value(T)
// docid: M:System.Threading.AsyncLocal`1.set_Value(`0)
    public func set_Value(value : T) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_AsyncLocal_1_void__set_Value_0__1__T(T.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the value of the ambient data.

    */
    public var Value : T {
        get {
            return try! get_Value();
        }
        set(v) {
            return try! set_Value(value: v);
        }
    }
} // AsyncLocal_1


// type: System.Threading.AutoResetEvent
    /**
    Represents a thread synchronization event that, when signaled, resets automatically after releasing a single waiting thread. This class cannot be inherited.

    */
public final class AutoResetEvent
    :
    dotnet.System.Threading.EventWaitHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_AutoResetEvent_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(bool)
// docid: M:System.Threading.AutoResetEvent.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class with a Boolean value indicating whether to set the initial state to signaled.

    - Parameter initialState: 
         to set the initial state to signaled;  to set the initial state to non-signaled.
    */
    public init(initialState : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_AutoResetEvent_ctor_0__1__bool(&__thrown, Swift.Int32(initialState ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // AutoResetEvent


// type: System.Threading.Barrier
    /**
    Enables multiple tasks to cooperatively work on an algorithm in parallel through multiple phases.

    */
open class Barrier
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Barrier_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32)
// docid: M:System.Threading.Barrier.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class.

    - Parameter participantCount: The number of participating threads.
    */
    public init(participantCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Barrier_ctor_0__1__i32(&__thrown, participantCount);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Action<System.Threading.Barrier>)
// docid: M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})
    /**
    Initializes a new instance of the  class.

    - Parameter participantCount: The number of participating threads.
    - Parameter postPhaseAction: The  to be executed after each phase. null (Nothing in Visual Basic) may be passed to indicate no action is taken.
    */
    public init(participantCount : Swift.Int32, postPhaseAction : Optional<dotnet.System.Action_1<dotnet.System.Threading.Barrier>>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Barrier_ctor_0__2__i32_System_Action_System_Threading_Barrier_(&__thrown, participantCount, (postPhaseAction?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Int64 AddParticipant()
// docid: M:System.Threading.Barrier.AddParticipant
    /**
    Notifies the  that there will be an additional participant.

    - Returns: The phase number of the barrier in which the new participants will first participate.

    */
    open func AddParticipant() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_i64__AddParticipant_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 AddParticipants(System.Int32)
// docid: M:System.Threading.Barrier.AddParticipants(System.Int32)
    /**
    Notifies the  that there will be additional participants.

    - Parameter participantCount: The number of additional participants to add to the barrier.
    - Returns: The phase number of the barrier in which the new participants will first participate.

    */
    open func AddParticipants(participantCount : Swift.Int32) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_i64__AddParticipants_0__1__i32(&__thrown, self.get_handle(), participantCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void Dispose()
// docid: M:System.Threading.Barrier.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Barrier_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RemoveParticipant()
// docid: M:System.Threading.Barrier.RemoveParticipant
    /**
    Notifies the  that there will be one less participant.

    */
    open func RemoveParticipant() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Barrier_void__RemoveParticipant_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RemoveParticipants(System.Int32)
// docid: M:System.Threading.Barrier.RemoveParticipants(System.Int32)
    /**
    Notifies the  that there will be fewer participants.

    - Parameter participantCount: The number of additional participants to remove from the barrier.
    */
    open func RemoveParticipants(participantCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Barrier_void__RemoveParticipants_0__1__i32(&__thrown, self.get_handle(), participantCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SignalAndWait()
// docid: M:System.Threading.Barrier.SignalAndWait
    /**
    Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well.

    */
    open func SignalAndWait() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Barrier_void__SignalAndWait_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool SignalAndWait(System.Int32)
// docid: M:System.Threading.Barrier.SignalAndWait(System.Int32)
    /**
    Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or (-1) to wait indefinitely.
    - Returns: 
         if all participants reached the barrier within the specified time; otherwise .

    */
    open func SignalAndWait(millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_bool__SignalAndWait_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool SignalAndWait(System.Int32, System.Threading.CancellationToken)
// docid: M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)
    /**
    Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a 32-bit signed integer to measure the timeout, while observing a cancellation token.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or (-1) to wait indefinitely.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if all participants reached the barrier within the specified time; otherwise, .

    */
    open func SignalAndWait(millisecondsTimeout : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_bool__SignalAndWait_0__2__i32_CancellationToken(&__thrown, self.get_handle(), millisecondsTimeout, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void SignalAndWait(System.Threading.CancellationToken)
// docid: M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)
    /**
    Signals that a participant has reached the barrier and waits for all other participants to reach the barrier, while observing a cancellation token.

    - Parameter cancellationToken: The  to observe.
    */
    open func SignalAndWait(cancellationToken : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Barrier_void__SignalAndWait_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool SignalAndWait(System.TimeSpan)
// docid: M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)
    /**
    Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a  object to measure the time interval.

    - Parameter timeout: A  that represents the number of milliseconds to wait, or a  that represents -1 milliseconds to wait indefinitely.
    - Returns: 
         if all other participants reached the barrier; otherwise, .

    */
    open func SignalAndWait(timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_bool__SignalAndWait_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool SignalAndWait(System.TimeSpan, System.Threading.CancellationToken)
// docid: M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)
    /**
    Signals that a participant has reached the barrier and waits for all other participants to reach the barrier as well, using a  object to measure the time interval, while observing a cancellation token.

    - Parameter timeout: A  that represents the number of milliseconds to wait, or a  that represents -1 milliseconds to wait indefinitely.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if all other participants reached the barrier; otherwise, .

    */
    open func SignalAndWait(timeout : dotnet.System.TimeSpan, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_bool__SignalAndWait_0__2__TimeSpan_CancellationToken(&__thrown, self.get_handle(), timeout.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_CurrentPhaseNumber()
// docid: M:System.Threading.Barrier.get_CurrentPhaseNumber
    open func get_CurrentPhaseNumber() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_i64__get_CurrentPhaseNumber_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_ParticipantCount()
// docid: M:System.Threading.Barrier.get_ParticipantCount
    open func get_ParticipantCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_i32__get_ParticipantCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_ParticipantsRemaining()
// docid: M:System.Threading.Barrier.get_ParticipantsRemaining
    open func get_ParticipantsRemaining() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Barrier_i32__get_ParticipantsRemaining_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the number of the barrier's current phase.

    */
    open var CurrentPhaseNumber : Swift.Int64 {
        get {
            return try! get_CurrentPhaseNumber();
        }
    }
    /**
    Gets the total number of participants in the barrier.

    */
    open var ParticipantCount : Swift.Int32 {
        get {
            return try! get_ParticipantCount();
        }
    }
    /**
    Gets the number of participants in the barrier that haven't yet signaled in the current phase.

    */
    open var ParticipantsRemaining : Swift.Int32 {
        get {
            return try! get_ParticipantsRemaining();
        }
    }
} // Barrier


// type: System.Threading.BarrierPostPhaseException
    /**
    The exception that is thrown when the post-phase action of a  fails.

    */
open class BarrierPostPhaseException
    :
    dotnet.System.Exception
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_BarrierPostPhaseException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.BarrierPostPhaseException.#ctor
    /**
    Initializes a new instance of the  class with a system-supplied message that describes the error.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_BarrierPostPhaseException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Exception)
// docid: M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)
    /**
    Initializes a new instance of the  class with the specified inner exception.

    - Parameter innerException: The exception that is the cause of the current exception.
    */
    public init(innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_BarrierPostPhaseException_ctor_0__1__Exception(&__thrown, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Threading.BarrierPostPhaseException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified message that describes the error.

    - Parameter message: The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_BarrierPostPhaseException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.
    - Parameter innerException: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_BarrierPostPhaseException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // BarrierPostPhaseException


// type: System.Threading.ContextCallback
    /**
    Represents a method to be called within a new context.

    */
public final class ContextCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_ContextCallback_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke(System.Object)
// docid: M:System.Threading.ContextCallback.Invoke(System.Object)
    public func Invoke(state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ContextCallback_void__Invoke_0__1__Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.AsyncCallback, System.Object)
// docid: M:System.Threading.ContextCallback.BeginInvoke(System.Object,System.AsyncCallback,System.Object)
    public func BeginInvoke(state : Optional<dotnet.System.Object>, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ContextCallback_IAsyncResult__BeginInvoke_0__3__Object_AsyncCallback_Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil, callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.Threading.ContextCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ContextCallback_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public convenience init(_ __closure_Invoke : @escaping (Optional<dotnet.System.Object>) throws -> Void) throws
    {
        let __interlude_Invoke : (UnsafeMutablePointer<NullableHandle>, NullableHandle) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle) -> Void in
            do
            {
                thrown.pointee = nil;
                try __closure_Invoke((state != nil) ? (dotnet.System.Object(hndl: state!)) : nil);
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        func __cb_Invoke(pdata_interlude : UnsafeRawPointer, thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle) -> Void
        {
            let f_interlude = Unmanaged<AnyObject>.fromOpaque(pdata_interlude).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NullableHandle) -> Void;
            f_interlude(thrown, state);
        }
        let __pdata_Invoke = UnsafeRawPointer(Unmanaged.passRetained(__interlude_Invoke as AnyObject).toOpaque());

        var __thrown : NullableHandle = nil;
        let h = System_Threading_ContextCallback_create(
            &__thrown,
            __cb_Invoke,
            __pdata_Invoke,
            nil
            );
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h);
        }
    }
    // void Invoke(System.Object)
// docid: M:System.Threading.ContextCallback.Invoke(System.Object)
    public func callAsFunction(state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ContextCallback_void__Invoke_0__1__Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ContextCallback


// type: System.Threading.CountdownEvent
    /**
    Represents a synchronization primitive that is signaled when its count reaches zero.

    */
open class CountdownEvent
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_CountdownEvent_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32)
// docid: M:System.Threading.CountdownEvent.#ctor(System.Int32)
    /**
    Initializes a new instance of  class with the specified count.

    - Parameter initialCount: The number of signals initially required to set the .
    */
    public init(initialCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_CountdownEvent_ctor_0__1__i32(&__thrown, initialCount);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AddCount()
// docid: M:System.Threading.CountdownEvent.AddCount
    /**
    Increments the 's current count by one.

    */
    open func AddCount() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_CountdownEvent_void__AddCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddCount(System.Int32)
// docid: M:System.Threading.CountdownEvent.AddCount(System.Int32)
    /**
    Increments the 's current count by a specified value.

    - Parameter signalCount: The value by which to increase .
    */
    open func AddCount(signalCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_CountdownEvent_void__AddCount_0__1__i32(&__thrown, self.get_handle(), signalCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Dispose()
// docid: M:System.Threading.CountdownEvent.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_CountdownEvent_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Reset()
// docid: M:System.Threading.CountdownEvent.Reset
    /**
    Resets the  to the value of .

    */
    open func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_CountdownEvent_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Reset(System.Int32)
// docid: M:System.Threading.CountdownEvent.Reset(System.Int32)
    /**
    Resets the  property to a specified value.

    - Parameter count: The number of signals required to set the .
    */
    open func Reset(count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_CountdownEvent_void__Reset_0__1__i32(&__thrown, self.get_handle(), count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Signal()
// docid: M:System.Threading.CountdownEvent.Signal
    /**
    Registers a signal with the , decrementing the value of .

    - Returns: 
         if the signal caused the count to reach zero and the event was set; otherwise, .

    */
    open func Signal() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__Signal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Signal(System.Int32)
// docid: M:System.Threading.CountdownEvent.Signal(System.Int32)
    /**
    Registers multiple signals with the , decrementing the value of  by the specified amount.

    - Parameter signalCount: The number of signals to register.
    - Returns: 
         if the signals caused the count to reach zero and the event was set; otherwise, .

    */
    open func Signal(signalCount : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__Signal_0__1__i32(&__thrown, self.get_handle(), signalCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryAddCount()
// docid: M:System.Threading.CountdownEvent.TryAddCount
    /**
    Attempts to increment  by one.

    - Returns: 
         if the increment succeeded; otherwise, false. If  is already at zero, this method will return .

    */
    open func TryAddCount() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__TryAddCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryAddCount(System.Int32)
// docid: M:System.Threading.CountdownEvent.TryAddCount(System.Int32)
    /**
    Attempts to increment  by a specified value.

    - Parameter signalCount: The value by which to increase .
    - Returns: 
         if the increment succeeded; otherwise, false. If  is already at zero this will return .

    */
    open func TryAddCount(signalCount : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__TryAddCount_0__1__i32(&__thrown, self.get_handle(), signalCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Wait()
// docid: M:System.Threading.CountdownEvent.Wait
    /**
    Blocks the current thread until the  is set.

    */
    open func Wait() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_CountdownEvent_void__Wait_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Wait(System.Int32)
// docid: M:System.Threading.CountdownEvent.Wait(System.Int32)
    /**
    Blocks the current thread until the  is set, using a 32-bit signed integer to measure the timeout.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or (-1) to wait indefinitely.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__Wait_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.Int32, System.Threading.CancellationToken)
// docid: M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)
    /**
    Blocks the current thread until the  is set, using a 32-bit signed integer to measure the timeout, while observing a .

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or (-1) to wait indefinitely.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(millisecondsTimeout : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__Wait_0__2__i32_CancellationToken(&__thrown, self.get_handle(), millisecondsTimeout, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Wait(System.Threading.CancellationToken)
// docid: M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)
    /**
    Blocks the current thread until the  is set, while observing a .

    - Parameter cancellationToken: The  to observe.
    */
    open func Wait(cancellationToken : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_CountdownEvent_void__Wait_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Wait(System.TimeSpan)
// docid: M:System.Threading.CountdownEvent.Wait(System.TimeSpan)
    /**
    Blocks the current thread until the  is set, using a  to measure the timeout.

    - Parameter timeout: A  that represents the number of milliseconds to wait, or a  that represents -1 milliseconds to wait indefinitely.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__Wait_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.TimeSpan, System.Threading.CancellationToken)
// docid: M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)
    /**
    Blocks the current thread until the  is set, using a  to measure the timeout, while observing a .

    - Parameter timeout: A  that represents the number of milliseconds to wait, or a  that represents -1 milliseconds to wait indefinitely.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(timeout : dotnet.System.TimeSpan, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__Wait_0__2__TimeSpan_CancellationToken(&__thrown, self.get_handle(), timeout.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_CurrentCount()
// docid: M:System.Threading.CountdownEvent.get_CurrentCount
    open func get_CurrentCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_i32__get_CurrentCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_InitialCount()
// docid: M:System.Threading.CountdownEvent.get_InitialCount
    open func get_InitialCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_i32__get_InitialCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsSet()
// docid: M:System.Threading.CountdownEvent.get_IsSet
    open func get_IsSet() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_bool__get_IsSet_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Threading.WaitHandle get_WaitHandle()
// docid: M:System.Threading.CountdownEvent.get_WaitHandle
    open func get_WaitHandle() throws -> dotnet.System.Threading.WaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_CountdownEvent_WaitHandle__get_WaitHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.WaitHandle(hndl : __return);
        }
    }
    /**
    Gets the number of remaining signals required to set the event.

    */
    open var CurrentCount : Swift.Int32 {
        get {
            return try! get_CurrentCount();
        }
    }
    /**
    Gets the numbers of signals initially required to set the event.

    */
    open var InitialCount : Swift.Int32 {
        get {
            return try! get_InitialCount();
        }
    }
    /**
    Indicates whether the  object's current count has reached zero.

    */
    open var IsSet : Bool {
        get {
            return try! get_IsSet();
        }
    }
    /**
    Gets a  that is used to wait for the event to be set.

    */
    open var WaitHandle : dotnet.System.Threading.WaitHandle {
        get {
            return try! get_WaitHandle();
        }
    }
} // CountdownEvent


// type: System.Threading.EventResetMode
    /**
    Indicates whether an  is reset automatically or manually after receiving a signal.

    */
public struct EventResetMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Threading_EventResetMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Threading.EventResetMode AutoReset
    /**
    When signaled, the  resets automatically after releasing a single thread. If no threads are waiting, the  remains signaled until a thread blocks, and resets after releasing the thread.

    */
    public static var AutoReset : dotnet.System.Threading.EventResetMode {
        get {
        let __return = dotnet.System.Threading.EventResetMode(val: System_Threading_EventResetMode_get_AutoReset());
            return __return;
        }
    }
    // static field: System.Threading.EventResetMode ManualReset
    /**
    When signaled, the  releases all waiting threads and remains signaled until it is manually reset.

    */
    public static var ManualReset : dotnet.System.Threading.EventResetMode {
        get {
        let __return = dotnet.System.Threading.EventResetMode(val: System_Threading_EventResetMode_get_ManualReset());
            return __return;
        }
    }
} // EventResetMode


// type: System.Threading.EventWaitHandle
    /**
    Represents a thread synchronization event.

    */
open class EventWaitHandle
    :
    dotnet.System.Threading.WaitHandle
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_EventWaitHandle_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(bool, System.Threading.EventResetMode)
// docid: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)
    /**
    Initializes a new instance of the  class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.

    - Parameter initialState: 
         to set the initial state to signaled;  to set it to nonsignaled.
    - Parameter mode: One of the  values that determines whether the event resets automatically or manually.
    */
    public init(initialState : Bool, mode : dotnet.System.Threading.EventResetMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_EventWaitHandle_ctor_0__2__bool_EventResetMode(&__thrown, Swift.Int32(initialState ? 1 : 0), mode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool, System.Threading.EventResetMode, System.String)
// docid: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)
    /**
    Initializes a new instance of the  class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.

    - Parameter initialState: 
         to set the initial state to signaled if the named event is created as a result of this call;  to set it to nonsignaled.
    - Parameter mode: One of the  values that determines whether the event resets automatically or manually.
    - Parameter name: The name, if the synchronization object is to be shared with other processes; otherwise,  or an empty string. The name is case-sensitive.
    */
    public init(initialState : Bool, mode : dotnet.System.Threading.EventResetMode, name : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_EventWaitHandle_ctor_0__3__bool_EventResetMode_String(&__thrown, Swift.Int32(initialState ? 1 : 0), mode.get_value(), name?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool, System.Threading.EventResetMode, System.String, ref bool)
// docid: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)
    /**
    Initializes a new instance of the  class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.

    - Parameter initialState: 
         to set the initial state to signaled if the named event is created as a result of this call;  to set it to nonsignaled.
    - Parameter mode: One of the  values that determines whether the event resets automatically or manually.
    - Parameter name: The name, if the synchronization object is to be shared with other processes; otherwise,  or an empty string. The name is case-sensitive.
    - Parameter createdNew: When this method returns, contains  if a local event was created (that is, if  is  or an empty string) or if the specified named system event was created;  if the specified named system event already existed. This parameter is passed uninitialized.
    */
    public init(initialState : Bool, mode : dotnet.System.Threading.EventResetMode, name : Optional<dotnet.System.String>, createdNew : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_out_createdNew = Swift.Int32(createdNew ? 1 : 0);
        let h = System_Threading_EventWaitHandle_ctor_0__4__bool_EventResetMode_String_outbool(&__thrown, Swift.Int32(initialState ? 1 : 0), mode.get_value(), name?.get_handle() ?? nil, &_tmp_out_createdNew);
        let _tmp2_createdNew = (_tmp_out_createdNew) != 0;
            createdNew = _tmp2_createdNew;
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.EventWaitHandle OpenExisting(System.String)
// docid: M:System.Threading.EventWaitHandle.OpenExisting(System.String)
    /**
    Opens the specified named synchronization event, if it already exists.

    - Parameter name: The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive.
    - Returns: An  object that represents the named system event.

    */
    open class func OpenExisting(name : dotnet.System.String) throws -> dotnet.System.Threading.EventWaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_EventWaitHandle_EventWaitHandle__OpenExisting_0__1__String(&__thrown, name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.EventWaitHandle(hndl : __return);
        }
    }
    // bool Reset()
// docid: M:System.Threading.EventWaitHandle.Reset
    /**
    Sets the state of the event to nonsignaled, causing threads to block.

    - Returns: 
         if the operation succeeds; otherwise, .

    */
    open func Reset() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_EventWaitHandle_bool__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Set()
// docid: M:System.Threading.EventWaitHandle.Set
    /**
    Sets the state of the event to signaled, allowing one or more waiting threads to proceed.

    - Returns: 
         if the operation succeeds; otherwise, .

    */
    open func Set() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_EventWaitHandle_bool__Set_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryOpenExisting(System.String, ref System.Threading.EventWaitHandle)
// docid: M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)
    /**
    Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.

    - Parameter name: The name of the synchronization object to be opened and shared with other processes. The name is case-sensitive.
    - Parameter result: When this method returns, contains a  object that represents the named synchronization event if the call succeeded, or  if the call failed. This parameter is treated as uninitialized.
    - Returns: 
         if the named synchronization event was opened successfully; otherwise, . In some cases,  may be returned for invalid names.

    */
    open class func TryOpenExisting(name : dotnet.System.String, result : inout Optional<dotnet.System.Threading.EventWaitHandle>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_result = (result != nil) ? (result!.get_handle()) : nil;
        let __return = System_Threading_EventWaitHandle_bool__TryOpenExisting_0__2__String_outEventWaitHandle(&__thrown, name.get_handle(), &_tmp_out_result);
        let __h__tmp2_result = _tmp_out_result;
        let _tmp2_result = (__h__tmp2_result != nil) ? dotnet.System.Threading.EventWaitHandle(hndl: __h__tmp2_result!) : nil;
            result = _tmp2_result;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // EventWaitHandle


// type: System.Threading.ExecutionContext
    /**
    Manages the execution context for the current thread. This class cannot be inherited.

    */
public final class ExecutionContext
    :
    dotnet.System.Object,
    System_IDisposable,
    System_Runtime_Serialization_ISerializable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_ExecutionContext_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.ExecutionContext Capture()
// docid: M:System.Threading.ExecutionContext.Capture
    /**
    Captures the execution context from the current thread.

    - Returns: An  object representing the execution context for the current thread.

    */
    public class func Capture() throws -> Optional<dotnet.System.Threading.ExecutionContext> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ExecutionContext_ExecutionContext__Capture_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.ExecutionContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.ExecutionContext CreateCopy()
// docid: M:System.Threading.ExecutionContext.CreateCopy
    /**
    Creates a copy of the current execution context.

    - Returns: An  object representing the current execution context.

    */
    public func CreateCopy() throws -> dotnet.System.Threading.ExecutionContext {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ExecutionContext_ExecutionContext__CreateCopy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.ExecutionContext(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Threading.ExecutionContext.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ExecutionContext_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
// docid: M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    /**
    Sets the specified  object with the logical context information needed to recreate an instance of the current execution context.

    - Parameter info: The  object to be populated with serialization information.
    - Parameter context: The  structure representing the destination context of the serialization.
    */
    public func GetObjectData(info : dotnet.System.Runtime.Serialization.SerializationInfo, context : dotnet.System.Runtime.Serialization.StreamingContext) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ExecutionContext_void__GetObjectData_0__2__SerializationInfo_StreamingContext(&__thrown, self.get_handle(), info.get_handle(), context.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool IsFlowSuppressed()
// docid: M:System.Threading.ExecutionContext.IsFlowSuppressed
    /**
    Indicates whether the flow of the execution context is currently suppressed.

    - Returns: 
         if the flow is suppressed; otherwise, .

    */
    public class func IsFlowSuppressed() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ExecutionContext_bool__IsFlowSuppressed_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Restore(System.Threading.ExecutionContext)
// docid: M:System.Threading.ExecutionContext.Restore(System.Threading.ExecutionContext)
    /**
    Restores a captured execution context on to the current thread.

    - Parameter executionContext: The ExecutionContext to set.
    */
    public class func Restore(executionContext : dotnet.System.Threading.ExecutionContext) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ExecutionContext_void__Restore_0__1__ExecutionContext(&__thrown, executionContext.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RestoreFlow()
// docid: M:System.Threading.ExecutionContext.RestoreFlow
    /**
    Restores the flow of the execution context across asynchronous threads.

    */
    public class func RestoreFlow() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ExecutionContext_void__RestoreFlow_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)
// docid: M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)
    /**
    Runs a method in a specified execution context on the current thread.

    - Parameter executionContext: The  to set.
    - Parameter callback: A  delegate that represents the method to be run in the provided execution context.
    - Parameter state: The object to pass to the callback method.
    */
    public class func Run(executionContext : dotnet.System.Threading.ExecutionContext, callback : dotnet.System.Threading.ContextCallback, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ExecutionContext_void__Run_0__3__ExecutionContext_ContextCallback_Object(&__thrown, executionContext.get_handle(), callback.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public class func Run(executionContext : dotnet.System.Threading.ExecutionContext, callback : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws {
        let del_callback = try dotnet.System.Threading.ContextCallback(callback);
        return try Run(executionContext: executionContext, callback: del_callback, state: state);
    }
    // System.Threading.AsyncFlowControl SuppressFlow()
// docid: M:System.Threading.ExecutionContext.SuppressFlow
    /**
    Suppresses the flow of the execution context across asynchronous threads.

    - Returns: An  structure for restoring the flow.

    */
    public class func SuppressFlow() throws -> dotnet.System.Threading.AsyncFlowControl {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ExecutionContext_AsyncFlowControl__SuppressFlow_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.AsyncFlowControl(hndl : __return);
        }
    }
} // ExecutionContext


// type: System.Threading.HostExecutionContext
    /**
    Encapsulates and propagates the host execution context across threads.

    */
open class HostExecutionContext
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_HostExecutionContext_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.HostExecutionContext.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_HostExecutionContext_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Object)
// docid: M:System.Threading.HostExecutionContext.#ctor(System.Object)
    /**
    Initializes a new instance of the  class using the specified state.

    - Parameter state: An object representing the host execution context state.
    */
    public init(state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_HostExecutionContext_ctor_0__1__Object(&__thrown, state?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.HostExecutionContext CreateCopy()
// docid: M:System.Threading.HostExecutionContext.CreateCopy
    /**
    Creates a copy of the current host execution context.

    - Returns: A  object representing the host context for the current thread.

    */
    open func CreateCopy() throws -> dotnet.System.Threading.HostExecutionContext {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_HostExecutionContext_HostExecutionContext__CreateCopy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.HostExecutionContext(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Threading.HostExecutionContext.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_HostExecutionContext_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Dispose(bool)
// docid: M:System.Threading.HostExecutionContext.Dispose(System.Boolean)
    /**
    When overridden in a derived class, releases the unmanaged resources used by the , and optionally releases the managed resources.

    - Parameter disposing: 
         to release both managed and unmanaged resources;  to release only unmanaged resources.
    */
    open func Dispose(disposing : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_HostExecutionContext_void__Dispose_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(disposing ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // HostExecutionContext


// type: System.Threading.HostExecutionContextManager
    /**
    Provides the functionality that allows a common language runtime host to participate in the flow, or migration, of the execution context.

    */
open class HostExecutionContextManager
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_HostExecutionContextManager_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.HostExecutionContextManager.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_HostExecutionContextManager_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.HostExecutionContext Capture()
// docid: M:System.Threading.HostExecutionContextManager.Capture
    /**
    Captures the host execution context from the current thread.

    - Returns: A  object representing the host execution context of the current thread.

    */
    open func Capture() throws -> Optional<dotnet.System.Threading.HostExecutionContext> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_HostExecutionContextManager_HostExecutionContext__Capture_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.HostExecutionContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Revert(System.Object)
// docid: M:System.Threading.HostExecutionContextManager.Revert(System.Object)
    /**
    Restores the host execution context to its prior state.

    - Parameter previousState: The previous context state to revert to.
    */
    open func Revert(previousState : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_HostExecutionContextManager_void__Revert_0__1__Object(&__thrown, self.get_handle(), previousState.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Object SetHostExecutionContext(System.Threading.HostExecutionContext)
// docid: M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)
    /**
    Sets the current host execution context to the specified host execution context.

    - Parameter hostExecutionContext: The  to be set.
    - Returns: An object for restoring the  to its previous state.

    */
    open func SetHostExecutionContext(hostExecutionContext : dotnet.System.Threading.HostExecutionContext) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_HostExecutionContextManager_Object__SetHostExecutionContext_0__1__HostExecutionContext(&__thrown, self.get_handle(), hostExecutionContext.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
} // HostExecutionContextManager


// type: System.Threading.Interlocked
public struct Interlocked {
    // System.Int32 Add(ref System.Int32, System.Int32)
// docid: M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)
    /**
    Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.

    - Parameter location1: A variable containing the first value to be added. The sum of the two values is stored in .
    - Parameter value: The value to be added to the integer at .
    - Returns: The new value that was stored at  by this operation.

    */
    public static func Add(location1 : inout Swift.Int32, value : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i32__Add_0__2__refi32_i32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Add(ref System.Int64, System.Int64)
// docid: M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)
    /**
    Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.

    - Parameter location1: A variable containing the first value to be added. The sum of the two values is stored in .
    - Parameter value: The value to be added to the integer at .
    - Returns: The new value that was stored at  by this operation.

    */
    public static func Add(location1 : inout Swift.Int64, value : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i64__Add_0__2__refi64_i64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 Add(ref System.UInt32, System.UInt32)
// docid: M:System.Threading.Interlocked.Add(System.UInt32@,System.UInt32)
    /**
    Adds two 32-bit unsigned integers and replaces the first integer with the sum, as an atomic operation.

    - Parameter location1: A variable containing the first value to be added. The sum of the two values is stored in .
    - Parameter value: The value to be added to the integer at .
    - Returns: The new value that was stored at  by this operation.

    */
    public static func Add(location1 : inout Swift.UInt32, value : Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u32__Add_0__2__refu32_u32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 Add(ref System.UInt64, System.UInt64)
// docid: M:System.Threading.Interlocked.Add(System.UInt64@,System.UInt64)
    /**
    Adds two 64-bit unsigned integers and replaces the first integer with the sum, as an atomic operation.

    - Parameter location1: A variable containing the first value to be added. The sum of the two values is stored in .
    - Parameter value: The value to be added to the integer at .
    - Returns: The new value that was stored at  by this operation.

    */
    public static func Add(location1 : inout Swift.UInt64, value : Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u64__Add_0__2__refu64_u64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 And(ref System.Int32, System.Int32)
// docid: M:System.Threading.Interlocked.And(System.Int32@,System.Int32)
    /**
    Bitwise "ands" two 32-bit signed integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func And(location1 : inout Swift.Int32, value : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i32__And_0__2__refi32_i32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 And(ref System.Int64, System.Int64)
// docid: M:System.Threading.Interlocked.And(System.Int64@,System.Int64)
    /**
    Bitwise "ands" two 64-bit signed integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func And(location1 : inout Swift.Int64, value : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i64__And_0__2__refi64_i64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 And(ref System.UInt32, System.UInt32)
// docid: M:System.Threading.Interlocked.And(System.UInt32@,System.UInt32)
    /**
    Bitwise "ands" two 32-bit unsigned integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func And(location1 : inout Swift.UInt32, value : Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u32__And_0__2__refu32_u32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 And(ref System.UInt64, System.UInt64)
// docid: M:System.Threading.Interlocked.And(System.UInt64@,System.UInt64)
    /**
    Bitwise "ands" two 64-bit unsigned integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func And(location1 : inout Swift.UInt64, value : Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u64__And_0__2__refu64_u64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Double CompareExchange(ref System.Double, System.Double, System.Double)
// docid: M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)
    /**
    Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.

    - Parameter location1: The destination, whose value is compared with  and possibly replaced.
    - Parameter value: The value that replaces the destination value if the comparison results in equality.
    - Parameter comparand: The value that is compared to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout Swift.Double, value : Swift.Double, comparand : Swift.Double) throws -> Swift.Double {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_f64__CompareExchange_0__3__reff64_f64_f64(&__thrown, &_tmp_ref_location1, value, comparand);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 CompareExchange(ref System.Int32, System.Int32, System.Int32)
// docid: M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)
    /**
    Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.

    - Parameter location1: The destination, whose value is compared with  and possibly replaced.
    - Parameter value: The value that replaces the destination value if the comparison results in equality.
    - Parameter comparand: The value that is compared to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout Swift.Int32, value : Swift.Int32, comparand : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i32__CompareExchange_0__3__refi32_i32_i32(&__thrown, &_tmp_ref_location1, value, comparand);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 CompareExchange(ref System.Int64, System.Int64, System.Int64)
// docid: M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)
    /**
    Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.

    - Parameter location1: The destination, whose value is compared with  and possibly replaced.
    - Parameter value: The value that replaces the destination value if the comparison results in equality.
    - Parameter comparand: The value that is compared to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout Swift.Int64, value : Swift.Int64, comparand : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i64__CompareExchange_0__3__refi64_i64_i64(&__thrown, &_tmp_ref_location1, value, comparand);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.IntPtr CompareExchange(ref System.IntPtr, System.IntPtr, System.IntPtr)
// docid: M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)
    /**
    Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.

    - Parameter location1: The destination , whose value is compared with the value of  and possibly replaced by .
    - Parameter value: The  that replaces the destination value if the comparison results in equality.
    - Parameter comparand: The  that is compared to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout dotnet.System.IntPtr, value : dotnet.System.IntPtr, comparand : dotnet.System.IntPtr) throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1.get_value();
        let __return = System_Threading_Interlocked_IntPtr__CompareExchange_0__3__refIntPtr_IntPtr_IntPtr(&__thrown, &_tmp_ref_location1, value.get_value(), comparand.get_value());
        let _tmp2_location1 = dotnet.System.IntPtr(val: _tmp_ref_location1);
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // System.Object CompareExchange(ref System.Object, System.Object, System.Object)
// docid: M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)
    /**
    Compares two objects for reference equality and, if they are equal, replaces the first object.

    - Parameter location1: The destination object that is compared by reference with  and possibly replaced.
    - Parameter value: The object that replaces the destination object if the reference comparison results in equality.
    - Parameter comparand: The object that is compared by reference to the object at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout Optional<dotnet.System.Object>, value : Optional<dotnet.System.Object>, comparand : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = (location1 != nil) ? (location1!.get_handle()) : nil;
        let __return = System_Threading_Interlocked_Object__CompareExchange_0__3__refObject_Object_Object(&__thrown, &_tmp_ref_location1, value?.get_handle() ?? nil, comparand?.get_handle() ?? nil);
        let __h__tmp2_location1 = _tmp_ref_location1;
        let _tmp2_location1 = (__h__tmp2_location1 != nil) ? dotnet.System.Object(hndl: __h__tmp2_location1!) : nil;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Single CompareExchange(ref System.Single, System.Single, System.Single)
// docid: M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)
    /**
    Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.

    - Parameter location1: The destination, whose value is compared with  and possibly replaced.
    - Parameter value: The value that replaces the destination value if the comparison results in equality.
    - Parameter comparand: The value that is compared to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout Swift.Float, value : Swift.Float, comparand : Swift.Float) throws -> Swift.Float {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_f32__CompareExchange_0__3__reff32_f32_f32(&__thrown, &_tmp_ref_location1, value, comparand);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 CompareExchange(ref System.UInt32, System.UInt32, System.UInt32)
// docid: M:System.Threading.Interlocked.CompareExchange(System.UInt32@,System.UInt32,System.UInt32)
    /**
    Compares two 32-bit unsigned integers for equality and, if they are equal, replaces the first value.

    - Parameter location1: The destination, whose value is compared with  and possibly replaced.
    - Parameter value: The value that replaces the destination value if the comparison results in equality.
    - Parameter comparand: The value that is compared to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout Swift.UInt32, value : Swift.UInt32, comparand : Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u32__CompareExchange_0__3__refu32_u32_u32(&__thrown, &_tmp_ref_location1, value, comparand);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 CompareExchange(ref System.UInt64, System.UInt64, System.UInt64)
// docid: M:System.Threading.Interlocked.CompareExchange(System.UInt64@,System.UInt64,System.UInt64)
    /**
    Compares two 64-bit unsigned integers for equality and, if they are equal, replaces the first value.

    - Parameter location1: The destination, whose value is compared with  and possibly replaced.
    - Parameter value: The value that replaces the destination value if the comparison results in equality.
    - Parameter comparand: The value that is compared to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange(location1 : inout Swift.UInt64, value : Swift.UInt64, comparand : Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u64__CompareExchange_0__3__refu64_u64_u64(&__thrown, &_tmp_ref_location1, value, comparand);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // T CompareExchange<T>(ref T, T, T)
// docid: M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)
    /**
    Compares two instances of the specified reference type  for reference equality and, if they are equal, replaces the first one.

    - Parameter location1: The destination, whose value is compared by reference with  and possibly replaced. This is a reference parameter ( in C#,  in Visual Basic).
    - Parameter value: The value that replaces the destination value if the comparison by reference results in equality.
    - Parameter comparand: The value that is compared by reference to the value at .
    - Returns: The original value in .

    */
    public static func CompareExchange<UT : SGBridgeGenericValue>(location1 : inout UT, value : UT, comparand : UT) throws -> UT {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1.to_gval();
        let __return = System_Threading_Interlocked_UT__CompareExchange_1__3__refUT_UT_UT(UT.get_type_handle(), &__thrown, &_tmp_ref_location1, value.to_gval(), comparand.to_gval());
            let _tmp2_location1 = UT(gval: _tmp_ref_location1);
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UT(gval: __return);
        }
    }
    // System.Int32 Decrement(ref System.Int32)
// docid: M:System.Threading.Interlocked.Decrement(System.Int32@)
    /**
    Decrements a specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be decremented.
    - Returns: The decremented value.

    */
    public static func Decrement(location : inout Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_i32__Decrement_0__1__refi32(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Decrement(ref System.Int64)
// docid: M:System.Threading.Interlocked.Decrement(System.Int64@)
    /**
    Decrements the specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be decremented.
    - Returns: The decremented value.

    */
    public static func Decrement(location : inout Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_i64__Decrement_0__1__refi64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 Decrement(ref System.UInt32)
// docid: M:System.Threading.Interlocked.Decrement(System.UInt32@)
    /**
    Decrements a specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be decremented.
    - Returns: The decremented value.

    */
    public static func Decrement(location : inout Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_u32__Decrement_0__1__refu32(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 Decrement(ref System.UInt64)
// docid: M:System.Threading.Interlocked.Decrement(System.UInt64@)
    /**
    Decrements a specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be decremented.
    - Returns: The decremented value.

    */
    public static func Decrement(location : inout Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_u64__Decrement_0__1__refu64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Double Exchange(ref System.Double, System.Double)
// docid: M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)
    /**
    Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout Swift.Double, value : Swift.Double) throws -> Swift.Double {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_f64__Exchange_0__2__reff64_f64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Exchange(ref System.Int32, System.Int32)
// docid: M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)
    /**
    Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout Swift.Int32, value : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i32__Exchange_0__2__refi32_i32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Exchange(ref System.Int64, System.Int64)
// docid: M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)
    /**
    Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout Swift.Int64, value : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i64__Exchange_0__2__refi64_i64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.IntPtr Exchange(ref System.IntPtr, System.IntPtr)
// docid: M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)
    /**
    Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout dotnet.System.IntPtr, value : dotnet.System.IntPtr) throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1.get_value();
        let __return = System_Threading_Interlocked_IntPtr__Exchange_0__2__refIntPtr_IntPtr(&__thrown, &_tmp_ref_location1, value.get_value());
        let _tmp2_location1 = dotnet.System.IntPtr(val: _tmp_ref_location1);
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // System.Object Exchange(ref System.Object, System.Object)
// docid: M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)
    /**
    Sets an object to a specified value and returns a reference to the original object, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout Optional<dotnet.System.Object>, value : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = (location1 != nil) ? (location1!.get_handle()) : nil;
        let __return = System_Threading_Interlocked_Object__Exchange_0__2__refObject_Object(&__thrown, &_tmp_ref_location1, value?.get_handle() ?? nil);
        let __h__tmp2_location1 = _tmp_ref_location1;
        let _tmp2_location1 = (__h__tmp2_location1 != nil) ? dotnet.System.Object(hndl: __h__tmp2_location1!) : nil;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Single Exchange(ref System.Single, System.Single)
// docid: M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)
    /**
    Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout Swift.Float, value : Swift.Float) throws -> Swift.Float {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_f32__Exchange_0__2__reff32_f32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 Exchange(ref System.UInt32, System.UInt32)
// docid: M:System.Threading.Interlocked.Exchange(System.UInt32@,System.UInt32)
    /**
    Sets a 32-bit unsigned integer to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout Swift.UInt32, value : Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u32__Exchange_0__2__refu32_u32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 Exchange(ref System.UInt64, System.UInt64)
// docid: M:System.Threading.Interlocked.Exchange(System.UInt64@,System.UInt64)
    /**
    Sets a 64-bit unsigned integer to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value.
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange(location1 : inout Swift.UInt64, value : Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u64__Exchange_0__2__refu64_u64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // T Exchange<T>(ref T, T)
// docid: M:System.Threading.Interlocked.Exchange``1(``0@,``0)
    /**
    Sets a variable of the specified type  to a specified value and returns the original value, as an atomic operation.

    - Parameter location1: The variable to set to the specified value. This is a reference parameter ( in C#,  in Visual Basic).
    - Parameter value: The value to which the  parameter is set.
    - Returns: The original value of .

    */
    public static func Exchange<UT : SGBridgeGenericValue>(location1 : inout UT, value : UT) throws -> UT {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1.to_gval();
        let __return = System_Threading_Interlocked_UT__Exchange_1__2__refUT_UT(UT.get_type_handle(), &__thrown, &_tmp_ref_location1, value.to_gval());
            let _tmp2_location1 = UT(gval: _tmp_ref_location1);
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UT(gval: __return);
        }
    }
    // System.Int32 Increment(ref System.Int32)
// docid: M:System.Threading.Interlocked.Increment(System.Int32@)
    /**
    Increments a specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be incremented.
    - Returns: The incremented value.

    */
    public static func Increment(location : inout Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_i32__Increment_0__1__refi32(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Increment(ref System.Int64)
// docid: M:System.Threading.Interlocked.Increment(System.Int64@)
    /**
    Increments a specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be incremented.
    - Returns: The incremented value.

    */
    public static func Increment(location : inout Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_i64__Increment_0__1__refi64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 Increment(ref System.UInt32)
// docid: M:System.Threading.Interlocked.Increment(System.UInt32@)
    /**
    Increments a specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be incremented.
    - Returns: The incremented value.

    */
    public static func Increment(location : inout Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_u32__Increment_0__1__refu32(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 Increment(ref System.UInt64)
// docid: M:System.Threading.Interlocked.Increment(System.UInt64@)
    /**
    Increments a specified variable and stores the result, as an atomic operation.

    - Parameter location: The variable whose value is to be incremented.
    - Returns: The incremented value.

    */
    public static func Increment(location : inout Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_u64__Increment_0__1__refu64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void MemoryBarrier()
// docid: M:System.Threading.Interlocked.MemoryBarrier
    /**
    Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to  execute after memory accesses that follow the call to .

    */
    public static func MemoryBarrier() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Interlocked_void__MemoryBarrier_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void MemoryBarrierProcessWide()
// docid: M:System.Threading.Interlocked.MemoryBarrierProcessWide
    /**
    Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.

    */
    public static func MemoryBarrierProcessWide() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Interlocked_void__MemoryBarrierProcessWide_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 Or(ref System.Int32, System.Int32)
// docid: M:System.Threading.Interlocked.Or(System.Int32@,System.Int32)
    /**
    Bitwise "ors" two 32-bit signed integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func Or(location1 : inout Swift.Int32, value : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i32__Or_0__2__refi32_i32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Or(ref System.Int64, System.Int64)
// docid: M:System.Threading.Interlocked.Or(System.Int64@,System.Int64)
    /**
    Bitwise "ors" two 64-bit signed integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func Or(location1 : inout Swift.Int64, value : Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_i64__Or_0__2__refi64_i64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 Or(ref System.UInt32, System.UInt32)
// docid: M:System.Threading.Interlocked.Or(System.UInt32@,System.UInt32)
    /**
    Bitwise "ors" two 32-bit unsigned integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func Or(location1 : inout Swift.UInt32, value : Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u32__Or_0__2__refu32_u32(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 Or(ref System.UInt64, System.UInt64)
// docid: M:System.Threading.Interlocked.Or(System.UInt64@,System.UInt64)
    /**
    Bitwise "ors" two 64-bit unsigned integers and replaces the first integer with the result, as an atomic operation.

    - Parameter location1: A variable containing the first value to be combined. The result is stored in .
    - Parameter value: The value to be combined with the integer at .
    - Returns: The original value in .

    */
    public static func Or(location1 : inout Swift.UInt64, value : Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location1 = location1;
        let __return = System_Threading_Interlocked_u64__Or_0__2__refu64_u64(&__thrown, &_tmp_ref_location1, value);
        let _tmp2_location1 = _tmp_ref_location1;
            location1 = _tmp2_location1;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Read(ref System.Int64)
// docid: M:System.Threading.Interlocked.Read(System.Int64@)
    /**
    Returns a 64-bit value, loaded as an atomic operation.

    - Parameter location: The 64-bit value to be loaded.
    - Returns: The loaded value.

    */
    public static func Read(location : inout Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_i64__Read_0__1__refi64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 Read(ref System.UInt64)
// docid: M:System.Threading.Interlocked.Read(System.UInt64@)
    /**
    Returns a 64-bit unsigned value, loaded as an atomic operation.

    - Parameter location: The 64-bit value to be loaded.
    - Returns: The loaded value.

    */
    public static func Read(location : inout Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Interlocked_u64__Read_0__1__refu64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // Interlocked


// type: System.Threading.LazyInitializer
public struct LazyInitializer {
// TODO COPE (write_all_methods) (unused generic param) T EnsureInitialized<T>(ref T)
// TODO COPE (write_all_methods) (unused generic param) T EnsureInitialized<T>(ref T, ref bool, ref System.Object)
    // T EnsureInitialized<T>(ref T, ref bool, ref System.Object, System.Func<T>)
// docid: M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})
    /**
    Initializes a target reference or value type by using a specified function if it hasn't already been initialized.

    - Parameter target: A reference or value of type T to initialize if it hasn't already been initialized.
    - Parameter initialized: A reference to a Boolean value that determines whether the target has already been initialized.
    - Parameter syncLock: A reference to an object used as the mutually exclusive lock for initializing . If  is , a new object will be instantiated.
    - Parameter valueFactory: The function that is called to initialize the reference or value.
    - Returns: The initialized object.

    */
    public static func EnsureInitialized<UT : SGBridgeGenericValue>(target : inout UT, initialized : inout Bool, syncLock : inout Optional<dotnet.System.Object>, valueFactory : dotnet.System.Func_1<UT>) throws -> UT {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_target = target.to_gval();
            var _tmp_ref_initialized = Swift.Int32(initialized ? 1 : 0);
            var _tmp_ref_syncLock = (syncLock != nil) ? (syncLock!.get_handle()) : nil;
        let __return = System_Threading_LazyInitializer_UT__EnsureInitialized_1__4__refUT_refbool_refObject_System_Func_UT_(UT.get_type_handle(), &__thrown, &_tmp_ref_target, &_tmp_ref_initialized, &_tmp_ref_syncLock, valueFactory.get_handle());
            let _tmp2_target = UT(gval: _tmp_ref_target);
            target = _tmp2_target;
        let _tmp2_initialized = (_tmp_ref_initialized) != 0;
            initialized = _tmp2_initialized;
        let __h__tmp2_syncLock = _tmp_ref_syncLock;
        let _tmp2_syncLock = (__h__tmp2_syncLock != nil) ? dotnet.System.Object(hndl: __h__tmp2_syncLock!) : nil;
            syncLock = _tmp2_syncLock;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UT(gval: __return);
        }
    }
    // delegate closure overload
    public static func EnsureInitialized<UT : SGBridgeGenericValue>(target : inout UT, initialized : inout Bool, syncLock : inout Optional<dotnet.System.Object>, valueFactory : @escaping () throws -> UT) throws -> UT {
        let del_valueFactory = try dotnet.System.Func_1<UT>(valueFactory);
        return try EnsureInitialized(target: &target, initialized: &initialized, syncLock: &syncLock, valueFactory: del_valueFactory);
    }
    // T EnsureInitialized<T>(ref T, System.Func<T>)
// docid: M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})
    /**
    Initializes a target reference type by using a specified function if it hasn't already been initialized.

    - Parameter target: The reference to initialize if it hasn't already been initialized.
    - Parameter valueFactory: The function that is called to initialize the reference.
    - Returns: The initialized object.

    */
    public static func EnsureInitialized<UT : SGBridgeGenericValue>(target : inout UT, valueFactory : dotnet.System.Func_1<UT>) throws -> UT {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_target = target.to_gval();
        let __return = System_Threading_LazyInitializer_UT__EnsureInitialized_1__2__refUT_System_Func_UT_(UT.get_type_handle(), &__thrown, &_tmp_ref_target, valueFactory.get_handle());
            let _tmp2_target = UT(gval: _tmp_ref_target);
            target = _tmp2_target;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UT(gval: __return);
        }
    }
    // delegate closure overload
    public static func EnsureInitialized<UT : SGBridgeGenericValue>(target : inout UT, valueFactory : @escaping () throws -> UT) throws -> UT {
        let del_valueFactory = try dotnet.System.Func_1<UT>(valueFactory);
        return try EnsureInitialized(target: &target, valueFactory: del_valueFactory);
    }
    // T EnsureInitialized<T>(ref T, ref System.Object, System.Func<T>)
// docid: M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})
    /**
    Initializes a target reference type with a specified function if it has not already been initialized.

    - Parameter target: A reference to initialize if it has not already been initialized. If it is , it is considered not initialized; otherwise, it's considered initialized.
    - Parameter syncLock: A reference to an object used as the mutually exclusive lock for initializing
            . If  is , a new object will be instantiated.
    - Parameter valueFactory: The method to invoke to initialize .
    - Returns: The initialized object.

    */
    public static func EnsureInitialized<UT : SGBridgeGenericValue>(target : inout UT, syncLock : inout Optional<dotnet.System.Object>, valueFactory : dotnet.System.Func_1<UT>) throws -> UT {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_target = target.to_gval();
            var _tmp_ref_syncLock = (syncLock != nil) ? (syncLock!.get_handle()) : nil;
        let __return = System_Threading_LazyInitializer_UT__EnsureInitialized_1__3__refUT_refObject_System_Func_UT_(UT.get_type_handle(), &__thrown, &_tmp_ref_target, &_tmp_ref_syncLock, valueFactory.get_handle());
            let _tmp2_target = UT(gval: _tmp_ref_target);
            target = _tmp2_target;
        let __h__tmp2_syncLock = _tmp_ref_syncLock;
        let _tmp2_syncLock = (__h__tmp2_syncLock != nil) ? dotnet.System.Object(hndl: __h__tmp2_syncLock!) : nil;
            syncLock = _tmp2_syncLock;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UT(gval: __return);
        }
    }
    // delegate closure overload
    public static func EnsureInitialized<UT : SGBridgeGenericValue>(target : inout UT, syncLock : inout Optional<dotnet.System.Object>, valueFactory : @escaping () throws -> UT) throws -> UT {
        let del_valueFactory = try dotnet.System.Func_1<UT>(valueFactory);
        return try EnsureInitialized(target: &target, syncLock: &syncLock, valueFactory: del_valueFactory);
    }
} // LazyInitializer


// type: System.Threading.LockCookie
// boxed value type
    /**
    Defines the lock that implements single-writer/multiple-reader semantics. This is a value type.

    */
public final class LockCookie
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_LockCookie_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Threading_LockCookie_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Object)
// docid: M:System.Threading.LockCookie.Equals(System.Object)
    /**
    Indicates whether a specified object is a  and is equal to the current instance.

    - Parameter obj: The object to compare to the current instance.
    - Returns: 
         if the value of  is equal to the value of the current instance; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_LockCookie_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Threading.LockCookie)
// docid: M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)
    /**
    Indicates whether the current instance is equal to the specified .

    - Parameter obj: The  to compare to the current instance.
    - Returns: 
         if  is equal to the value of the current instance; otherwise, .

    */
    public func Equals(obj : dotnet.System.Threading.LockCookie) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_LockCookie_bool__Equals_0__1__LockCookie(&__thrown, self.get_handle(), obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Threading.LockCookie.GetHashCode
    /**
    Returns the hash code for this instance.

    - Returns: A 32-bit signed integer hash code.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_LockCookie_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Threading.LockCookie, System.Threading.LockCookie)
// docid: M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)
    /**
    Indicates whether two  structures are equal.

    - Parameter a: The  to compare to .
    - Parameter b: The  to compare to .
    - Returns: 
         if  is equal to ; otherwise, .

    */
    public class func op_Equality(a : dotnet.System.Threading.LockCookie, b : dotnet.System.Threading.LockCookie) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_LockCookie_bool__op_Equality_0__2__LockCookie_LockCookie(&__thrown, a.get_handle(), b.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Threading.LockCookie, System.Threading.LockCookie)
// docid: M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)
    /**
    Indicates whether two  structures are not equal.

    - Parameter a: The  to compare to .
    - Parameter b: The  to compare to .
    - Returns: 
         if  is not equal to ; otherwise, .

    */
    public class func op_Inequality(a : dotnet.System.Threading.LockCookie, b : dotnet.System.Threading.LockCookie) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_LockCookie_bool__op_Inequality_0__2__LockCookie_LockCookie(&__thrown, a.get_handle(), b.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // LockCookie


// type: System.Threading.LockRecursionException
    /**
    The exception that is thrown when recursive entry into a lock is not compatible with the recursion policy for the lock.

    */
open class LockRecursionException
    :
    dotnet.System.Exception
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_LockRecursionException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.LockRecursionException.#ctor
    /**
    Initializes a new instance of the  class with a system-supplied message that describes the error.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_LockRecursionException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Threading.LockRecursionException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified message that describes the error.

    - Parameter message: The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_LockRecursionException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: The message that describes the exception. The caller of this constructor must make sure that this string has been localized for the current system culture.
    - Parameter innerException: The exception that caused the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_LockRecursionException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // LockRecursionException


// type: System.Threading.LockRecursionPolicy
    /**
    Specifies whether a lock can be entered multiple times by the same thread.

    */
public struct LockRecursionPolicy : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Threading_LockRecursionPolicy_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Threading.LockRecursionPolicy NoRecursion
    /**
    If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.

    */
    public static var NoRecursion : dotnet.System.Threading.LockRecursionPolicy {
        get {
        let __return = dotnet.System.Threading.LockRecursionPolicy(val: System_Threading_LockRecursionPolicy_get_NoRecursion());
            return __return;
        }
    }
    // static field: System.Threading.LockRecursionPolicy SupportsRecursion
    /**
    A thread can enter a lock recursively. Some classes may restrict this capability.

    */
    public static var SupportsRecursion : dotnet.System.Threading.LockRecursionPolicy {
        get {
        let __return = dotnet.System.Threading.LockRecursionPolicy(val: System_Threading_LockRecursionPolicy_get_SupportsRecursion());
            return __return;
        }
    }
} // LockRecursionPolicy


// type: System.Threading.ManualResetEvent
    /**
    Represents a thread synchronization event that, when signaled, must be reset manually. This class cannot be inherited.

    */
public final class ManualResetEvent
    :
    dotnet.System.Threading.EventWaitHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_ManualResetEvent_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(bool)
// docid: M:System.Threading.ManualResetEvent.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class with a Boolean value indicating whether to set the initial state to signaled.

    - Parameter initialState: 
         to set the initial state signaled;  to set the initial state to nonsignaled.
    */
    public init(initialState : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ManualResetEvent_ctor_0__1__bool(&__thrown, Swift.Int32(initialState ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ManualResetEvent


// type: System.Threading.ManualResetEventSlim
    /**
    Represents a thread synchronization event that, when signaled, must be reset manually. This class is a lightweight alternative to .

    */
open class ManualResetEventSlim
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_ManualResetEventSlim_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.ManualResetEventSlim.#ctor
    /**
    Initializes a new instance of the  class with an initial state of nonsignaled.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ManualResetEventSlim_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class with a Boolean value indicating whether to set the initial state to signaled.

    - Parameter initialState: true to set the initial state signaled; false to set the initial state to nonsignaled.
    */
    public init(initialState : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ManualResetEventSlim_ctor_0__1__bool(&__thrown, Swift.Int32(initialState ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool, System.Int32)
// docid: M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)
    /**
    Initializes a new instance of the  class with a Boolean value indicating whether to set the initial state to signaled and a specified spin count.

    - Parameter initialState: true to set the initial state to signaled; false to set the initial state to nonsignaled.
    - Parameter spinCount: The number of spin waits that will occur before falling back to a kernel-based wait operation.
    */
    public init(initialState : Bool, spinCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ManualResetEventSlim_ctor_0__2__bool_i32(&__thrown, Swift.Int32(initialState ? 1 : 0), spinCount);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:System.Threading.ManualResetEventSlim.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ManualResetEventSlim_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Reset()
// docid: M:System.Threading.ManualResetEventSlim.Reset
    /**
    Sets the state of the event to nonsignaled, which causes threads to block.

    */
    open func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ManualResetEventSlim_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Set()
// docid: M:System.Threading.ManualResetEventSlim.Set
    /**
    Sets the state of the event to signaled, which allows one or more threads waiting on the event to proceed.

    */
    open func Set() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ManualResetEventSlim_void__Set_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Wait()
// docid: M:System.Threading.ManualResetEventSlim.Wait
    /**
    Blocks the current thread until the current  is set.

    */
    open func Wait() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ManualResetEventSlim_void__Wait_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Wait(System.Int32)
// docid: M:System.Threading.ManualResetEventSlim.Wait(System.Int32)
    /**
    Blocks the current thread until the current  is set, using a 32-bit signed integer to measure the time interval.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or (-1) to wait indefinitely.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ManualResetEventSlim_bool__Wait_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.Int32, System.Threading.CancellationToken)
// docid: M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)
    /**
    Blocks the current thread until the current  is set, using a 32-bit signed integer to measure the time interval, while observing a .

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or (-1) to wait indefinitely.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(millisecondsTimeout : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ManualResetEventSlim_bool__Wait_0__2__i32_CancellationToken(&__thrown, self.get_handle(), millisecondsTimeout, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Wait(System.Threading.CancellationToken)
// docid: M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)
    /**
    Blocks the current thread until the current  receives a signal, while observing a .

    - Parameter cancellationToken: The  to observe.
    */
    open func Wait(cancellationToken : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ManualResetEventSlim_void__Wait_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Wait(System.TimeSpan)
// docid: M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)
    /**
    Blocks the current thread until the current  is set, using a  to measure the time interval.

    - Parameter timeout: A  that represents the number of milliseconds to wait, or a  that represents -1 milliseconds to wait indefinitely.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ManualResetEventSlim_bool__Wait_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.TimeSpan, System.Threading.CancellationToken)
// docid: M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)
    /**
    Blocks the current thread until the current  is set, using a  to measure the time interval, while observing a .

    - Parameter timeout: A  that represents the number of milliseconds to wait, or a  that represents -1 milliseconds to wait indefinitely.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if the  was set; otherwise, .

    */
    open func Wait(timeout : dotnet.System.TimeSpan, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ManualResetEventSlim_bool__Wait_0__2__TimeSpan_CancellationToken(&__thrown, self.get_handle(), timeout.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSet()
// docid: M:System.Threading.ManualResetEventSlim.get_IsSet
    open func get_IsSet() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ManualResetEventSlim_bool__get_IsSet_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_SpinCount()
// docid: M:System.Threading.ManualResetEventSlim.get_SpinCount
    open func get_SpinCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ManualResetEventSlim_i32__get_SpinCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Threading.WaitHandle get_WaitHandle()
// docid: M:System.Threading.ManualResetEventSlim.get_WaitHandle
    open func get_WaitHandle() throws -> dotnet.System.Threading.WaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ManualResetEventSlim_WaitHandle__get_WaitHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.WaitHandle(hndl : __return);
        }
    }
    /**
    Gets whether the event is set.

    */
    open var IsSet : Bool {
        get {
            return try! get_IsSet();
        }
    }
    /**
    Gets the number of spin waits that will occur before falling back to a kernel-based wait operation.

    */
    open var SpinCount : Swift.Int32 {
        get {
            return try! get_SpinCount();
        }
    }
    /**
    Gets the underlying  object for this .

    */
    open var WaitHandle : dotnet.System.Threading.WaitHandle {
        get {
            return try! get_WaitHandle();
        }
    }
} // ManualResetEventSlim


// type: System.Threading.Monitor
public struct Monitor {
    // void Enter(System.Object)
// docid: M:System.Threading.Monitor.Enter(System.Object)
    /**
    Acquires an exclusive lock on the specified object.

    - Parameter obj: The object on which to acquire the monitor lock.
    */
    public static func Enter(obj : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Monitor_void__Enter_0__1__Object(&__thrown, obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Enter(System.Object, ref bool)
// docid: M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)
    /**
    Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.

    - Parameter obj: The object on which to wait.
    - Parameter lockTaken: The result of the attempt to acquire the lock, passed by reference. The input must be . The output is  if the lock is acquired; otherwise, the output is . The output is set even if an exception occurs during the attempt to acquire the lock.  
  
 Note   If no exception occurs, the output of this method is always .
    */
    public static func Enter(obj : dotnet.System.Object, lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_Monitor_void__Enter_0__2__Object_refbool(&__thrown, obj.get_handle(), &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Exit(System.Object)
// docid: M:System.Threading.Monitor.Exit(System.Object)
    /**
    Releases an exclusive lock on the specified object.

    - Parameter obj: The object on which to release the lock.
    */
    public static func Exit(obj : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Monitor_void__Exit_0__1__Object(&__thrown, obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool IsEntered(System.Object)
// docid: M:System.Threading.Monitor.IsEntered(System.Object)
    /**
    Determines whether the current thread holds the lock on the specified object.

    - Parameter obj: The object to test.
    - Returns: 
         if the current thread holds the lock on ; otherwise, .

    */
    public static func IsEntered(obj : dotnet.System.Object) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__IsEntered_0__1__Object(&__thrown, obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Pulse(System.Object)
// docid: M:System.Threading.Monitor.Pulse(System.Object)
    /**
    Notifies a thread in the waiting queue of a change in the locked object's state.

    - Parameter obj: The object a thread is waiting for.
    */
    public static func Pulse(obj : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Monitor_void__Pulse_0__1__Object(&__thrown, obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void PulseAll(System.Object)
// docid: M:System.Threading.Monitor.PulseAll(System.Object)
    /**
    Notifies all waiting threads of a change in the object's state.

    - Parameter obj: The object that sends the pulse.
    */
    public static func PulseAll(obj : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Monitor_void__PulseAll_0__1__Object(&__thrown, obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryEnter(System.Object)
// docid: M:System.Threading.Monitor.TryEnter(System.Object)
    /**
    Attempts to acquire an exclusive lock on the specified object.

    - Parameter obj: The object on which to acquire the lock.
    - Returns: 
         if the current thread acquires the lock; otherwise, .

    */
    public static func TryEnter(obj : dotnet.System.Object) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__TryEnter_0__1__Object(&__thrown, obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void TryEnter(System.Object, ref bool)
// docid: M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)
    /**
    Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.

    - Parameter obj: The object on which to acquire the lock.
    - Parameter lockTaken: The result of the attempt to acquire the lock, passed by reference. The input must be . The output is  if the lock is acquired; otherwise, the output is . The output is set even if an exception occurs during the attempt to acquire the lock.
    */
    public static func TryEnter(obj : dotnet.System.Object, lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_Monitor_void__TryEnter_0__2__Object_refbool(&__thrown, obj.get_handle(), &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryEnter(System.Object, System.Int32)
// docid: M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)
    /**
    Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.

    - Parameter obj: The object on which to acquire the lock.
    - Parameter millisecondsTimeout: The number of milliseconds to wait for the lock.
    - Returns: 
         if the current thread acquires the lock; otherwise, .

    */
    public static func TryEnter(obj : dotnet.System.Object, millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__TryEnter_0__2__Object_i32(&__thrown, obj.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void TryEnter(System.Object, System.Int32, ref bool)
// docid: M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)
    /**
    Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.

    - Parameter obj: The object on which to acquire the lock.
    - Parameter millisecondsTimeout: The number of milliseconds to wait for the lock.
    - Parameter lockTaken: The result of the attempt to acquire the lock, passed by reference. The input must be . The output is  if the lock is acquired; otherwise, the output is . The output is set even if an exception occurs during the attempt to acquire the lock.
    */
    public static func TryEnter(obj : dotnet.System.Object, millisecondsTimeout : Swift.Int32, lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_Monitor_void__TryEnter_0__3__Object_i32_refbool(&__thrown, obj.get_handle(), millisecondsTimeout, &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryEnter(System.Object, System.TimeSpan)
// docid: M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)
    /**
    Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.

    - Parameter obj: The object on which to acquire the lock.
    - Parameter timeout: A  representing the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.
    - Returns: 
         if the current thread acquires the lock; otherwise, .

    */
    public static func TryEnter(obj : dotnet.System.Object, timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__TryEnter_0__2__Object_TimeSpan(&__thrown, obj.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void TryEnter(System.Object, System.TimeSpan, ref bool)
// docid: M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)
    /**
    Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.

    - Parameter obj: The object on which to acquire the lock.
    - Parameter timeout: The amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait.
    - Parameter lockTaken: The result of the attempt to acquire the lock, passed by reference. The input must be . The output is  if the lock is acquired; otherwise, the output is . The output is set even if an exception occurs during the attempt to acquire the lock.
    */
    public static func TryEnter(obj : dotnet.System.Object, timeout : dotnet.System.TimeSpan, lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_Monitor_void__TryEnter_0__3__Object_TimeSpan_refbool(&__thrown, obj.get_handle(), timeout.get_handle(), &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Wait(System.Object)
// docid: M:System.Threading.Monitor.Wait(System.Object)
    /**
    Releases the lock on an object and blocks the current thread until it reacquires the lock.

    - Parameter obj: The object on which to wait.
    - Returns: 
         if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.

    */
    public static func Wait(obj : dotnet.System.Object) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__Wait_0__1__Object(&__thrown, obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.Object, System.Int32)
// docid: M:System.Threading.Monitor.Wait(System.Object,System.Int32)
    /**
    Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.

    - Parameter obj: The object on which to wait.
    - Parameter millisecondsTimeout: The number of milliseconds to wait before the thread enters the ready queue.
    - Returns: 
         if the lock was reacquired before the specified time elapsed;  if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.

    */
    public static func Wait(obj : dotnet.System.Object, millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__Wait_0__2__Object_i32(&__thrown, obj.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.Object, System.Int32, bool)
// docid: M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)
    /**
    Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.

    - Parameter obj: The object on which to wait.
    - Parameter millisecondsTimeout: The number of milliseconds to wait before the thread enters the ready queue.
    - Parameter exitContext: 
         to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, .
    - Returns: 
         if the lock was reacquired before the specified time elapsed;  if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.

    */
    public static func Wait(obj : dotnet.System.Object, millisecondsTimeout : Swift.Int32, exitContext : Bool) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__Wait_0__3__Object_i32_bool(&__thrown, obj.get_handle(), millisecondsTimeout, Swift.Int32(exitContext ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.Object, System.TimeSpan)
// docid: M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)
    /**
    Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.

    - Parameter obj: The object on which to wait.
    - Parameter timeout: A  representing the amount of time to wait before the thread enters the ready queue.
    - Returns: 
         if the lock was reacquired before the specified time elapsed;  if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.

    */
    public static func Wait(obj : dotnet.System.Object, timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__Wait_0__2__Object_TimeSpan(&__thrown, obj.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.Object, System.TimeSpan, bool)
// docid: M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)
    /**
    Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.

    - Parameter obj: The object on which to wait.
    - Parameter timeout: A  representing the amount of time to wait before the thread enters the ready queue.
    - Parameter exitContext: 
         to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, .
    - Returns: 
         if the lock was reacquired before the specified time elapsed;  if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.

    */
    public static func Wait(obj : dotnet.System.Object, timeout : dotnet.System.TimeSpan, exitContext : Bool) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_bool__Wait_0__3__Object_TimeSpan_bool(&__thrown, obj.get_handle(), timeout.get_handle(), Swift.Int32(exitContext ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_LockContentionCount()
// docid: M:System.Threading.Monitor.get_LockContentionCount
    public static func get_LockContentionCount() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Monitor_i64__get_LockContentionCount_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the number of times there was contention when trying to take the monitor's lock.

    */
    public static var LockContentionCount : Swift.Int64 {
        get {
            return try! get_LockContentionCount();
        }
    }
} // Monitor


// type: System.Threading.Mutex
    /**
    A synchronization primitive that can also be used for interprocess synchronization.

    */
public final class Mutex
    :
    dotnet.System.Threading.WaitHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_Mutex_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.Mutex.#ctor
    /**
    Initializes a new instance of the  class with default properties.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Mutex_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:System.Threading.Mutex.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.

    - Parameter initiallyOwned: 
         to give the calling thread initial ownership of the mutex; otherwise, .
    */
    public init(initiallyOwned : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Mutex_ctor_0__1__bool(&__thrown, Swift.Int32(initiallyOwned ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool, System.String)
// docid: M:System.Threading.Mutex.#ctor(System.Boolean,System.String)
    /**
    Initializes a new instance of the  class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.

    - Parameter initiallyOwned: 
         to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, .
    - Parameter name: The name, if the synchronization object is to be shared with other processes; otherwise,  or an empty string. The name is case-sensitive.
    */
    public init(initiallyOwned : Bool, name : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Mutex_ctor_0__2__bool_String(&__thrown, Swift.Int32(initiallyOwned ? 1 : 0), name?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool, System.String, ref bool)
// docid: M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)
    /**
    Initializes a new instance of the  class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.

    - Parameter initiallyOwned: 
         to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, .
    - Parameter name: The name, if the synchronization object is to be shared with other processes; otherwise,  or an empty string. The name is case-sensitive.
    - Parameter createdNew: When this method returns, contains a Boolean that is  if a local mutex was created (that is, if  is  or an empty string) or if the specified named system mutex was created;  if the specified named system mutex already existed. This parameter is passed uninitialized.
    */
    public init(initiallyOwned : Bool, name : Optional<dotnet.System.String>, createdNew : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_out_createdNew = Swift.Int32(createdNew ? 1 : 0);
        let h = System_Threading_Mutex_ctor_0__3__bool_String_outbool(&__thrown, Swift.Int32(initiallyOwned ? 1 : 0), name?.get_handle() ?? nil, &_tmp_out_createdNew);
        let _tmp2_createdNew = (_tmp_out_createdNew) != 0;
            createdNew = _tmp2_createdNew;
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Mutex OpenExisting(System.String)
// docid: M:System.Threading.Mutex.OpenExisting(System.String)
    /**
    Opens the specified named mutex, if it already exists.

    - Parameter name: The name of the synchronization object to be shared with other processes. The name is case-sensitive.
    - Returns: An object that represents the named system mutex.

    */
    public class func OpenExisting(name : dotnet.System.String) throws -> dotnet.System.Threading.Mutex {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Mutex_Mutex__OpenExisting_0__1__String(&__thrown, name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Mutex(hndl : __return);
        }
    }
    // void ReleaseMutex()
// docid: M:System.Threading.Mutex.ReleaseMutex
    /**
    Releases the  once.

    */
    public func ReleaseMutex() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Mutex_void__ReleaseMutex_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryOpenExisting(System.String, ref System.Threading.Mutex)
// docid: M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)
    /**
    Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.

    - Parameter name: The name of the synchronization object to be shared with other processes. The name is case-sensitive.
    - Parameter result: When this method returns, contains a  object that represents the named mutex if the call succeeded, or  if the call failed. This parameter is treated as uninitialized.
    - Returns: 
         if the named mutex was opened successfully; otherwise, . In some cases,  may be returned for invalid names.

    */
    public class func TryOpenExisting(name : dotnet.System.String, result : inout Optional<dotnet.System.Threading.Mutex>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_result = (result != nil) ? (result!.get_handle()) : nil;
        let __return = System_Threading_Mutex_bool__TryOpenExisting_0__2__String_outMutex(&__thrown, name.get_handle(), &_tmp_out_result);
        let __h__tmp2_result = _tmp_out_result;
        let _tmp2_result = (__h__tmp2_result != nil) ? dotnet.System.Threading.Mutex(hndl: __h__tmp2_result!) : nil;
            result = _tmp2_result;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // Mutex


// type: System.Threading.ReaderWriterLock
    /**
    Defines a lock that supports single writers and multiple readers.

    */
public final class ReaderWriterLock
    :
    dotnet.System.Runtime.ConstrainedExecution.CriticalFinalizerObject
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_ReaderWriterLock_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.ReaderWriterLock.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ReaderWriterLock_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AcquireReaderLock(System.Int32)
// docid: M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
    /**
    Acquires a reader lock, using an  value for the time-out.

    - Parameter millisecondsTimeout: The time-out in milliseconds.
    */
    public func AcquireReaderLock(millisecondsTimeout : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLock_void__AcquireReaderLock_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AcquireReaderLock(System.TimeSpan)
// docid: M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
    /**
    Acquires a reader lock, using a  value for the time-out.

    - Parameter timeout: A  specifying the time-out period.
    */
    public func AcquireReaderLock(timeout : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLock_void__AcquireReaderLock_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AcquireWriterLock(System.Int32)
// docid: M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
    /**
    Acquires the writer lock, using an  value for the time-out.

    - Parameter millisecondsTimeout: The time-out in milliseconds.
    */
    public func AcquireWriterLock(millisecondsTimeout : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLock_void__AcquireWriterLock_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AcquireWriterLock(System.TimeSpan)
// docid: M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
    /**
    Acquires the writer lock, using a  value for the time-out.

    - Parameter timeout: The  specifying the time-out period.
    */
    public func AcquireWriterLock(timeout : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLock_void__AcquireWriterLock_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool AnyWritersSince(System.Int32)
// docid: M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
    /**
    Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.

    - Parameter seqNum: The sequence number.
    - Returns: 
         if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, .

    */
    public func AnyWritersSince(seqNum : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLock_bool__AnyWritersSince_0__1__i32(&__thrown, self.get_handle(), seqNum);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void DowngradeFromWriterLock(ref System.Threading.LockCookie)
// docid: M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
    /**
    Restores the lock status of the thread to what it was before  was called.

    - Parameter lockCookie: A  returned by .
    */
    public func DowngradeFromWriterLock(lockCookie : inout Optional<dotnet.System.Threading.LockCookie>) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockCookie = (lockCookie != nil) ? (lockCookie!.get_handle()) : nil;
        System_Threading_ReaderWriterLock_void__DowngradeFromWriterLock_0__1__refLockCookie(&__thrown, self.get_handle(), &_tmp_ref_lockCookie);
        let __h__tmp2_lockCookie = _tmp_ref_lockCookie;
        let _tmp2_lockCookie = (__h__tmp2_lockCookie != nil) ? dotnet.System.Threading.LockCookie(hndl: __h__tmp2_lockCookie!) : nil;
            lockCookie = _tmp2_lockCookie;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.LockCookie ReleaseLock()
// docid: M:System.Threading.ReaderWriterLock.ReleaseLock
    /**
    Releases the lock, regardless of the number of times the thread acquired the lock.

    - Returns: A  value representing the released lock.

    */
    public func ReleaseLock() throws -> dotnet.System.Threading.LockCookie {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLock_LockCookie__ReleaseLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.LockCookie(hndl : __return);
        }
    }
    // void ReleaseReaderLock()
// docid: M:System.Threading.ReaderWriterLock.ReleaseReaderLock
    /**
    Decrements the lock count.

    */
    public func ReleaseReaderLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLock_void__ReleaseReaderLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ReleaseWriterLock()
// docid: M:System.Threading.ReaderWriterLock.ReleaseWriterLock
    /**
    Decrements the lock count on the writer lock.

    */
    public func ReleaseWriterLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLock_void__ReleaseWriterLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RestoreLock(ref System.Threading.LockCookie)
// docid: M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
    /**
    Restores the lock status of the thread to what it was before calling .

    - Parameter lockCookie: A  returned by .
    */
    public func RestoreLock(lockCookie : inout Optional<dotnet.System.Threading.LockCookie>) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockCookie = (lockCookie != nil) ? (lockCookie!.get_handle()) : nil;
        System_Threading_ReaderWriterLock_void__RestoreLock_0__1__refLockCookie(&__thrown, self.get_handle(), &_tmp_ref_lockCookie);
        let __h__tmp2_lockCookie = _tmp_ref_lockCookie;
        let _tmp2_lockCookie = (__h__tmp2_lockCookie != nil) ? dotnet.System.Threading.LockCookie(hndl: __h__tmp2_lockCookie!) : nil;
            lockCookie = _tmp2_lockCookie;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.LockCookie UpgradeToWriterLock(System.Int32)
// docid: M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
    /**
    Upgrades a reader lock to the writer lock, using an  value for the time-out.

    - Parameter millisecondsTimeout: The time-out in milliseconds.
    - Returns: A  value.

    */
    public func UpgradeToWriterLock(millisecondsTimeout : Swift.Int32) throws -> dotnet.System.Threading.LockCookie {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLock_LockCookie__UpgradeToWriterLock_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.LockCookie(hndl : __return);
        }
    }
    // System.Threading.LockCookie UpgradeToWriterLock(System.TimeSpan)
// docid: M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
    /**
    Upgrades a reader lock to the writer lock, using a  value for the time-out.

    - Parameter timeout: The  specifying the time-out period.
    - Returns: A  value.

    */
    public func UpgradeToWriterLock(timeout : dotnet.System.TimeSpan) throws -> dotnet.System.Threading.LockCookie {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLock_LockCookie__UpgradeToWriterLock_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.LockCookie(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsReaderLockHeld()
// docid: M:System.Threading.ReaderWriterLock.get_IsReaderLockHeld
    public func get_IsReaderLockHeld() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLock_bool__get_IsReaderLockHeld_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsWriterLockHeld()
// docid: M:System.Threading.ReaderWriterLock.get_IsWriterLockHeld
    public func get_IsWriterLockHeld() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLock_bool__get_IsWriterLockHeld_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_WriterSeqNum()
// docid: M:System.Threading.ReaderWriterLock.get_WriterSeqNum
    public func get_WriterSeqNum() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLock_i32__get_WriterSeqNum_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets a value indicating whether the current thread holds a reader lock.

    */
    public var IsReaderLockHeld : Bool {
        get {
            return try! get_IsReaderLockHeld();
        }
    }
    /**
    Gets a value indicating whether the current thread holds the writer lock.

    */
    public var IsWriterLockHeld : Bool {
        get {
            return try! get_IsWriterLockHeld();
        }
    }
    /**
    Gets the current sequence number.

    */
    public var WriterSeqNum : Swift.Int32 {
        get {
            return try! get_WriterSeqNum();
        }
    }
} // ReaderWriterLock


// type: System.Threading.ReaderWriterLockSlim
    /**
    Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.

    */
open class ReaderWriterLockSlim
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_ReaderWriterLockSlim_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.ReaderWriterLockSlim.#ctor
    /**
    Initializes a new instance of the  class with default property values.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ReaderWriterLockSlim_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Threading.LockRecursionPolicy)
// docid: M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)
    /**
    Initializes a new instance of the  class, specifying the lock recursion policy.

    - Parameter recursionPolicy: One of the enumeration values that specifies the lock recursion policy.
    */
    public init(recursionPolicy : dotnet.System.Threading.LockRecursionPolicy) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ReaderWriterLockSlim_ctor_0__1__LockRecursionPolicy(&__thrown, recursionPolicy.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:System.Threading.ReaderWriterLockSlim.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLockSlim_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EnterReadLock()
// docid: M:System.Threading.ReaderWriterLockSlim.EnterReadLock
    /**
    Tries to enter the lock in read mode.

    */
    open func EnterReadLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLockSlim_void__EnterReadLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EnterUpgradeableReadLock()
// docid: M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock
    /**
    Tries to enter the lock in upgradeable mode.

    */
    open func EnterUpgradeableReadLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLockSlim_void__EnterUpgradeableReadLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EnterWriteLock()
// docid: M:System.Threading.ReaderWriterLockSlim.EnterWriteLock
    /**
    Tries to enter the lock in write mode.

    */
    open func EnterWriteLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLockSlim_void__EnterWriteLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ExitReadLock()
// docid: M:System.Threading.ReaderWriterLockSlim.ExitReadLock
    /**
    Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).

    */
    open func ExitReadLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLockSlim_void__ExitReadLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ExitUpgradeableReadLock()
// docid: M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock
    /**
    Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).

    */
    open func ExitUpgradeableReadLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLockSlim_void__ExitUpgradeableReadLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ExitWriteLock()
// docid: M:System.Threading.ReaderWriterLockSlim.ExitWriteLock
    /**
    Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).

    */
    open func ExitWriteLock() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ReaderWriterLockSlim_void__ExitWriteLock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryEnterReadLock(System.Int32)
// docid: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)
    /**
    Tries to enter the lock in read mode, with an optional integer time-out.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or -1 () to wait indefinitely.
    - Returns: 
         if the calling thread entered read mode, otherwise, .

    */
    open func TryEnterReadLock(millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__TryEnterReadLock_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryEnterReadLock(System.TimeSpan)
// docid: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)
    /**
    Tries to enter the lock in read mode, with an optional time-out.

    - Parameter timeout: The interval to wait, or -1 milliseconds to wait indefinitely.
    - Returns: 
         if the calling thread entered read mode, otherwise, .

    */
    open func TryEnterReadLock(timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__TryEnterReadLock_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryEnterUpgradeableReadLock(System.Int32)
// docid: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)
    /**
    Tries to enter the lock in upgradeable mode, with an optional time-out.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or -1 () to wait indefinitely.
    - Returns: 
         if the calling thread entered upgradeable mode, otherwise, .

    */
    open func TryEnterUpgradeableReadLock(millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__TryEnterUpgradeableReadLock_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryEnterUpgradeableReadLock(System.TimeSpan)
// docid: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)
    /**
    Tries to enter the lock in upgradeable mode, with an optional time-out.

    - Parameter timeout: The interval to wait, or -1 milliseconds to wait indefinitely.
    - Returns: 
         if the calling thread entered upgradeable mode, otherwise, .

    */
    open func TryEnterUpgradeableReadLock(timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__TryEnterUpgradeableReadLock_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryEnterWriteLock(System.Int32)
// docid: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)
    /**
    Tries to enter the lock in write mode, with an optional time-out.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or -1 () to wait indefinitely.
    - Returns: 
         if the calling thread entered write mode, otherwise, .

    */
    open func TryEnterWriteLock(millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__TryEnterWriteLock_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryEnterWriteLock(System.TimeSpan)
// docid: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)
    /**
    Tries to enter the lock in write mode, with an optional time-out.

    - Parameter timeout: The interval to wait, or -1 milliseconds to wait indefinitely.
    - Returns: 
         if the calling thread entered write mode, otherwise, .

    */
    open func TryEnterWriteLock(timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__TryEnterWriteLock_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_CurrentReadCount()
// docid: M:System.Threading.ReaderWriterLockSlim.get_CurrentReadCount
    open func get_CurrentReadCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_i32__get_CurrentReadCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadLockHeld()
// docid: M:System.Threading.ReaderWriterLockSlim.get_IsReadLockHeld
    open func get_IsReadLockHeld() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__get_IsReadLockHeld_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsUpgradeableReadLockHeld()
// docid: M:System.Threading.ReaderWriterLockSlim.get_IsUpgradeableReadLockHeld
    open func get_IsUpgradeableReadLockHeld() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__get_IsUpgradeableReadLockHeld_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsWriteLockHeld()
// docid: M:System.Threading.ReaderWriterLockSlim.get_IsWriteLockHeld
    open func get_IsWriteLockHeld() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_bool__get_IsWriteLockHeld_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Threading.LockRecursionPolicy get_RecursionPolicy()
// docid: M:System.Threading.ReaderWriterLockSlim.get_RecursionPolicy
    open func get_RecursionPolicy() throws -> dotnet.System.Threading.LockRecursionPolicy {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_LockRecursionPolicy__get_RecursionPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.LockRecursionPolicy(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_RecursiveReadCount()
// docid: M:System.Threading.ReaderWriterLockSlim.get_RecursiveReadCount
    open func get_RecursiveReadCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_i32__get_RecursiveReadCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_RecursiveUpgradeCount()
// docid: M:System.Threading.ReaderWriterLockSlim.get_RecursiveUpgradeCount
    open func get_RecursiveUpgradeCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_i32__get_RecursiveUpgradeCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_RecursiveWriteCount()
// docid: M:System.Threading.ReaderWriterLockSlim.get_RecursiveWriteCount
    open func get_RecursiveWriteCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_i32__get_RecursiveWriteCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_WaitingReadCount()
// docid: M:System.Threading.ReaderWriterLockSlim.get_WaitingReadCount
    open func get_WaitingReadCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_i32__get_WaitingReadCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_WaitingUpgradeCount()
// docid: M:System.Threading.ReaderWriterLockSlim.get_WaitingUpgradeCount
    open func get_WaitingUpgradeCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_i32__get_WaitingUpgradeCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_WaitingWriteCount()
// docid: M:System.Threading.ReaderWriterLockSlim.get_WaitingWriteCount
    open func get_WaitingWriteCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ReaderWriterLockSlim_i32__get_WaitingWriteCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the total number of unique threads that have entered the lock in read mode.

    */
    open var CurrentReadCount : Swift.Int32 {
        get {
            return try! get_CurrentReadCount();
        }
    }
    /**
    Gets a value that indicates whether the current thread has entered the lock in read mode.

    */
    open var IsReadLockHeld : Bool {
        get {
            return try! get_IsReadLockHeld();
        }
    }
    /**
    Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.

    */
    open var IsUpgradeableReadLockHeld : Bool {
        get {
            return try! get_IsUpgradeableReadLockHeld();
        }
    }
    /**
    Gets a value that indicates whether the current thread has entered the lock in write mode.

    */
    open var IsWriteLockHeld : Bool {
        get {
            return try! get_IsWriteLockHeld();
        }
    }
    /**
    Gets a value that indicates the recursion policy for the current  object.

    */
    open var RecursionPolicy : dotnet.System.Threading.LockRecursionPolicy {
        get {
            return try! get_RecursionPolicy();
        }
    }
    /**
    Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.

    */
    open var RecursiveReadCount : Swift.Int32 {
        get {
            return try! get_RecursiveReadCount();
        }
    }
    /**
    Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.

    */
    open var RecursiveUpgradeCount : Swift.Int32 {
        get {
            return try! get_RecursiveUpgradeCount();
        }
    }
    /**
    Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.

    */
    open var RecursiveWriteCount : Swift.Int32 {
        get {
            return try! get_RecursiveWriteCount();
        }
    }
    /**
    Gets the total number of threads that are waiting to enter the lock in read mode.

    */
    open var WaitingReadCount : Swift.Int32 {
        get {
            return try! get_WaitingReadCount();
        }
    }
    /**
    Gets the total number of threads that are waiting to enter the lock in upgradeable mode.

    */
    open var WaitingUpgradeCount : Swift.Int32 {
        get {
            return try! get_WaitingUpgradeCount();
        }
    }
    /**
    Gets the total number of threads that are waiting to enter the lock in write mode.

    */
    open var WaitingWriteCount : Swift.Int32 {
        get {
            return try! get_WaitingWriteCount();
        }
    }
} // ReaderWriterLockSlim


// type: System.Threading.Semaphore
    /**
    Limits the number of threads that can access a resource or pool of resources concurrently.

    */
public final class Semaphore
    :
    dotnet.System.Threading.WaitHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_Semaphore_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32, System.Int32)
// docid: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class, specifying the initial number of entries and the maximum number of concurrent entries.

    - Parameter initialCount: The initial number of requests for the semaphore that can be granted concurrently.
    - Parameter maximumCount: The maximum number of requests for the semaphore that can be granted concurrently.
    */
    public init(initialCount : Swift.Int32, maximumCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Semaphore_ctor_0__2__i32_i32(&__thrown, initialCount, maximumCount);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Int32, System.String)
// docid: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)
    /**
    Initializes a new instance of the  class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.

    - Parameter initialCount: The initial number of requests for the semaphore that can be granted concurrently.
    - Parameter maximumCount: The maximum number of requests for the semaphore that can be granted concurrently.
    - Parameter name: The name, if the synchronization object is to be shared with other processes; otherwise,  or an empty string. The name is case-sensitive.
    */
    public init(initialCount : Swift.Int32, maximumCount : Swift.Int32, name : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Semaphore_ctor_0__3__i32_i32_String(&__thrown, initialCount, maximumCount, name?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Int32, System.String, ref bool)
// docid: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)
    /**
    Initializes a new instance of the  class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.

    - Parameter initialCount: The initial number of requests for the semaphore that can be satisfied concurrently.
    - Parameter maximumCount: The maximum number of requests for the semaphore that can be satisfied concurrently.
    - Parameter name: The name, if the synchronization object is to be shared with other processes; otherwise,  or an empty string. The name is case-sensitive.
    - Parameter createdNew: When this method returns, contains  if a local semaphore was created (that is, if  is  or an empty string) or if the specified named system semaphore was created;  if the specified named system semaphore already existed. This parameter is passed uninitialized.
    */
    public init(initialCount : Swift.Int32, maximumCount : Swift.Int32, name : Optional<dotnet.System.String>, createdNew : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_out_createdNew = Swift.Int32(createdNew ? 1 : 0);
        let h = System_Threading_Semaphore_ctor_0__4__i32_i32_String_outbool(&__thrown, initialCount, maximumCount, name?.get_handle() ?? nil, &_tmp_out_createdNew);
        let _tmp2_createdNew = (_tmp_out_createdNew) != 0;
            createdNew = _tmp2_createdNew;
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Semaphore OpenExisting(System.String)
// docid: M:System.Threading.Semaphore.OpenExisting(System.String)
    /**
    Opens the specified named semaphore, if it already exists.

    - Parameter name: The name of the synchronization object to be shared with other processes. The name is case-sensitive.
    - Returns: An object that represents the named system semaphore.

    */
    public class func OpenExisting(name : dotnet.System.String) throws -> dotnet.System.Threading.Semaphore {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Semaphore_Semaphore__OpenExisting_0__1__String(&__thrown, name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Semaphore(hndl : __return);
        }
    }
    // System.Int32 Release()
// docid: M:System.Threading.Semaphore.Release
    /**
    Exits the semaphore and returns the previous count.

    - Returns: The count on the semaphore before the  method was called.

    */
    public func Release() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Semaphore_i32__Release_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Release(System.Int32)
// docid: M:System.Threading.Semaphore.Release(System.Int32)
    /**
    Exits the semaphore a specified number of times and returns the previous count.

    - Parameter releaseCount: The number of times to exit the semaphore.
    - Returns: The count on the semaphore before the  method was called.

    */
    public func Release(releaseCount : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Semaphore_i32__Release_0__1__i32(&__thrown, self.get_handle(), releaseCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // bool TryOpenExisting(System.String, ref System.Threading.Semaphore)
// docid: M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)
    /**
    Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.

    - Parameter name: The name of the synchronization object to be shared with other processes. The name is case-sensitive.
    - Parameter result: When this method returns, contains a  object that represents the named semaphore if the call succeeded, or  if the call failed. This parameter is treated as uninitialized.
    - Returns: 
         if the named semaphore was opened successfully; otherwise, . In some cases,  may be returned for invalid names.

    */
    public class func TryOpenExisting(name : dotnet.System.String, result : inout Optional<dotnet.System.Threading.Semaphore>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_result = (result != nil) ? (result!.get_handle()) : nil;
        let __return = System_Threading_Semaphore_bool__TryOpenExisting_0__2__String_outSemaphore(&__thrown, name.get_handle(), &_tmp_out_result);
        let __h__tmp2_result = _tmp_out_result;
        let _tmp2_result = (__h__tmp2_result != nil) ? dotnet.System.Threading.Semaphore(hndl: __h__tmp2_result!) : nil;
            result = _tmp2_result;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // Semaphore


// type: System.Threading.SemaphoreFullException
    /**
    The exception that is thrown when the  method is called on a semaphore whose count is already at the maximum.

    */
open class SemaphoreFullException
    :
    dotnet.System.SystemException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_SemaphoreFullException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.SemaphoreFullException.#ctor
    /**
    Initializes a new instance of the  class with default values.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SemaphoreFullException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Threading.SemaphoreFullException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified error message.

    - Parameter message: The error message that explains the reason for the exception.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SemaphoreFullException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: The error message that explains the reason for the exception.
    - Parameter innerException: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SemaphoreFullException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SemaphoreFullException


// type: System.Threading.SemaphoreSlim
    /**
    Represents a lightweight alternative to  that limits the number of threads that can access a resource or pool of resources concurrently.

    */
open class SemaphoreSlim
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_SemaphoreSlim_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32)
// docid: M:System.Threading.SemaphoreSlim.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class, specifying the initial number of requests that can be granted concurrently.

    - Parameter initialCount: The initial number of requests for the semaphore that can be granted concurrently.
    */
    public init(initialCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SemaphoreSlim_ctor_0__1__i32(&__thrown, initialCount);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Int32)
// docid: M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class, specifying the initial and maximum number of requests that can be granted concurrently.

    - Parameter initialCount: The initial number of requests for the semaphore that can be granted concurrently.
    - Parameter maxCount: The maximum number of requests for the semaphore that can be granted concurrently.
    */
    public init(initialCount : Swift.Int32, maxCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SemaphoreSlim_ctor_0__2__i32_i32(&__thrown, initialCount, maxCount);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:System.Threading.SemaphoreSlim.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SemaphoreSlim_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 Release()
// docid: M:System.Threading.SemaphoreSlim.Release
    /**
    Releases the  object once.

    - Returns: The previous count of the .

    */
    open func Release() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_i32__Release_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Release(System.Int32)
// docid: M:System.Threading.SemaphoreSlim.Release(System.Int32)
    /**
    Releases the  object a specified number of times.

    - Parameter releaseCount: The number of times to exit the semaphore.
    - Returns: The previous count of the .

    */
    open func Release(releaseCount : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_i32__Release_0__1__i32(&__thrown, self.get_handle(), releaseCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void Wait()
// docid: M:System.Threading.SemaphoreSlim.Wait
    /**
    Blocks the current thread until it can enter the .

    */
    open func Wait() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SemaphoreSlim_void__Wait_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Wait(System.Int32)
// docid: M:System.Threading.SemaphoreSlim.Wait(System.Int32)
    /**
    Blocks the current thread until it can enter the , using a 32-bit signed integer that specifies the timeout.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.
    - Returns: 
         if the current thread successfully entered the ; otherwise, .

    */
    open func Wait(millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_bool__Wait_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.Int32, System.Threading.CancellationToken)
// docid: M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)
    /**
    Blocks the current thread until it can enter the , using a 32-bit signed integer that specifies the timeout, while observing a .

    - Parameter millisecondsTimeout: The number of milliseconds to wait, (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if the current thread successfully entered the ; otherwise, .

    */
    open func Wait(millisecondsTimeout : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_bool__Wait_0__2__i32_CancellationToken(&__thrown, self.get_handle(), millisecondsTimeout, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Wait(System.Threading.CancellationToken)
// docid: M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)
    /**
    Blocks the current thread until it can enter the , while observing a .

    - Parameter cancellationToken: The  token to observe.
    */
    open func Wait(cancellationToken : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SemaphoreSlim_void__Wait_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Wait(System.TimeSpan)
// docid: M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)
    /**
    Blocks the current thread until it can enter the , using a  to specify the timeout.

    - Parameter timeout: A  that represents the number of milliseconds to wait, a  that represents -1 milliseconds to wait indefinitely, or a  that represents 0 milliseconds to test the wait handle and return immediately.
    - Returns: 
         if the current thread successfully entered the ; otherwise, .

    */
    open func Wait(timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_bool__Wait_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Wait(System.TimeSpan, System.Threading.CancellationToken)
// docid: M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)
    /**
    Blocks the current thread until it can enter the , using a  that specifies the timeout, while observing a .

    - Parameter timeout: A  that represents the number of milliseconds to wait, a  that represents -1 milliseconds to wait indefinitely, or a  that represents 0 milliseconds to test the wait handle and return immediately.
    - Parameter cancellationToken: The  to observe.
    - Returns: 
         if the current thread successfully entered the ; otherwise, .

    */
    open func Wait(timeout : dotnet.System.TimeSpan, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_bool__Wait_0__2__TimeSpan_CancellationToken(&__thrown, self.get_handle(), timeout.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Threading.Tasks.Task WaitAsync()
// docid: M:System.Threading.SemaphoreSlim.WaitAsync
    /**
    Asynchronously waits to enter the .

    - Returns: A task that will complete when the semaphore has been entered.

    */
    open func WaitAsync() async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_Task__WaitAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.Task<bool> WaitAsync(System.Int32)
// docid: M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)
    /**
    Asynchronously waits to enter the , using a 32-bit signed integer to measure the time interval.

    - Parameter millisecondsTimeout: The number of milliseconds to wait,  (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.
    - Returns: A task that will complete with a result of  if the current thread successfully entered the , otherwise with a result of .

    */
    open func WaitAsync(millisecondsTimeout : Swift.Int32) async throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_System_Threading_Tasks_Task_bool___WaitAsync_0__1__i32(&__thrown, self.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.Task<bool> WaitAsync(System.Int32, System.Threading.CancellationToken)
// docid: M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously waits to enter the , using a 32-bit signed integer to measure the time interval, while observing a .

    - Parameter millisecondsTimeout: The number of milliseconds to wait,  (-1) to wait indefinitely, or zero to test the state of the wait handle and return immediately.
    - Parameter cancellationToken: The  to observe.
    - Returns: A task that will complete with a result of  if the current thread successfully entered the , otherwise with a result of .

    */
    open func WaitAsync(millisecondsTimeout : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) async throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_System_Threading_Tasks_Task_bool___WaitAsync_0__2__i32_CancellationToken(&__thrown, self.get_handle(), millisecondsTimeout, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.Task WaitAsync(System.Threading.CancellationToken)
// docid: M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)
    /**
    Asynchronously waits to enter the , while observing a .

    - Parameter cancellationToken: The  token to observe.
    - Returns: A task that will complete when the semaphore has been entered.

    */
    open func WaitAsync(cancellationToken : dotnet.System.Threading.CancellationToken) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_Task__WaitAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.Task<bool> WaitAsync(System.TimeSpan)
// docid: M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)
    /**
    Asynchronously waits to enter the , using a  to measure the time interval.

    - Parameter timeout: A  that represents the number of milliseconds to wait, a  that represents -1 milliseconds to wait indefinitely, or a  that represents 0 milliseconds to test the wait handle and return immediately.
    - Returns: A task that will complete with a result of  if the current thread successfully entered the , otherwise with a result of .

    */
    open func WaitAsync(timeout : dotnet.System.TimeSpan) async throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_System_Threading_Tasks_Task_bool___WaitAsync_0__1__TimeSpan(&__thrown, self.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.Task<bool> WaitAsync(System.TimeSpan, System.Threading.CancellationToken)
// docid: M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)
    /**
    Asynchronously waits to enter the , using a  to measure the time interval, while observing a .

    - Parameter timeout: A  that represents the number of milliseconds to wait, a  that represents -1 milliseconds to wait indefinitely, or a  that represents 0 milliseconds to test the wait handle and return immediately.
    - Parameter cancellationToken: The  token to observe.
    - Returns: A task that will complete with a result of  if the current thread successfully entered the , otherwise with a result of .

    */
    open func WaitAsync(timeout : dotnet.System.TimeSpan, cancellationToken : dotnet.System.Threading.CancellationToken) async throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_System_Threading_Tasks_Task_bool___WaitAsync_0__2__TimeSpan_CancellationToken(&__thrown, self.get_handle(), timeout.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task_1(hndl: __return).ToAsync();
        }
    }
    // [IsSpecialName] System.Threading.WaitHandle get_AvailableWaitHandle()
// docid: M:System.Threading.SemaphoreSlim.get_AvailableWaitHandle
    open func get_AvailableWaitHandle() throws -> dotnet.System.Threading.WaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_WaitHandle__get_AvailableWaitHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.WaitHandle(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_CurrentCount()
// docid: M:System.Threading.SemaphoreSlim.get_CurrentCount
    open func get_CurrentCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SemaphoreSlim_i32__get_CurrentCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Returns a  that can be used to wait on the semaphore.

    */
    open var AvailableWaitHandle : dotnet.System.Threading.WaitHandle {
        get {
            return try! get_AvailableWaitHandle();
        }
    }
    /**
    Gets the number of remaining threads that can enter the  object.

    */
    open var CurrentCount : Swift.Int32 {
        get {
            return try! get_CurrentCount();
        }
    }
} // SemaphoreSlim


// type: System.Threading.SendOrPostCallback
    /**
    Represents a method to be called when a message is to be dispatched to a synchronization context.

    */
public final class SendOrPostCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_SendOrPostCallback_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke(System.Object)
// docid: M:System.Threading.SendOrPostCallback.Invoke(System.Object)
    public func Invoke(state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SendOrPostCallback_void__Invoke_0__1__Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.AsyncCallback, System.Object)
// docid: M:System.Threading.SendOrPostCallback.BeginInvoke(System.Object,System.AsyncCallback,System.Object)
    public func BeginInvoke(state : Optional<dotnet.System.Object>, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SendOrPostCallback_IAsyncResult__BeginInvoke_0__3__Object_AsyncCallback_Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil, callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.Threading.SendOrPostCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SendOrPostCallback_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public convenience init(_ __closure_Invoke : @escaping (Optional<dotnet.System.Object>) throws -> Void) throws
    {
        let __interlude_Invoke : (UnsafeMutablePointer<NullableHandle>, NullableHandle) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle) -> Void in
            do
            {
                thrown.pointee = nil;
                try __closure_Invoke((state != nil) ? (dotnet.System.Object(hndl: state!)) : nil);
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        func __cb_Invoke(pdata_interlude : UnsafeRawPointer, thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle) -> Void
        {
            let f_interlude = Unmanaged<AnyObject>.fromOpaque(pdata_interlude).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NullableHandle) -> Void;
            f_interlude(thrown, state);
        }
        let __pdata_Invoke = UnsafeRawPointer(Unmanaged.passRetained(__interlude_Invoke as AnyObject).toOpaque());

        var __thrown : NullableHandle = nil;
        let h = System_Threading_SendOrPostCallback_create(
            &__thrown,
            __cb_Invoke,
            __pdata_Invoke,
            nil
            );
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h);
        }
    }
    // void Invoke(System.Object)
// docid: M:System.Threading.SendOrPostCallback.Invoke(System.Object)
    public func callAsFunction(state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SendOrPostCallback_void__Invoke_0__1__Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SendOrPostCallback


// type: System.Threading.SpinLock
// boxed value type
    /**
    Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.

    */
public final class SpinLock
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_SpinLock_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets whether the lock is currently held by any thread.

    */
    public var IsHeld : Bool {
        get {
            return try! get_IsHeld();
        }
    }
    /**
    Gets whether the lock is held by the current thread.

    */
    public var IsHeldByCurrentThread : Bool {
        get {
            return try! get_IsHeldByCurrentThread();
        }
    }
    /**
    Gets whether thread ownership tracking is enabled for this instance.

    */
    public var IsThreadOwnerTrackingEnabled : Bool {
        get {
            return try! get_IsThreadOwnerTrackingEnabled();
        }
    }
    // .ctor(bool)
// docid: M:System.Threading.SpinLock.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  structure with the option to track thread IDs to improve debugging.

    - Parameter enableThreadOwnerTracking: Whether to capture and use thread IDs for debugging purposes.
    */
    public init(enableThreadOwnerTracking : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SpinLock_ctor_0__1__bool(&__thrown, Swift.Int32(enableThreadOwnerTracking ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Threading_SpinLock_implicit_ctor();
            super.init(hndl: h);
    }
    // void Enter(ref bool)
// docid: M:System.Threading.SpinLock.Enter(System.Boolean@)
    /**
    Acquires the lock in a reliable manner, such that even if an exception occurs within the method call,  can be examined reliably to determine whether the lock was acquired.

    - Parameter lockTaken: True if the lock is acquired; otherwise, false.  must be initialized to false prior to calling this method.
    */
    public func Enter(lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_SpinLock_void__Enter_0__1__refbool(&__thrown, self.get_handle(), &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Exit()
// docid: M:System.Threading.SpinLock.Exit
    /**
    Releases the lock.

    */
    public func Exit() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SpinLock_void__Exit_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Exit(bool)
// docid: M:System.Threading.SpinLock.Exit(System.Boolean)
    /**
    Releases the lock.

    - Parameter useMemoryBarrier: A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.
    */
    public func Exit(useMemoryBarrier : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SpinLock_void__Exit_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(useMemoryBarrier ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryEnter(ref bool)
// docid: M:System.Threading.SpinLock.TryEnter(System.Boolean@)
    /**
    Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call,  can be examined reliably to determine whether the lock was acquired.

    - Parameter lockTaken: True if the lock is acquired; otherwise, false.  must be initialized to false prior to calling this method.
    */
    public func TryEnter(lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_SpinLock_void__TryEnter_0__1__refbool(&__thrown, self.get_handle(), &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryEnter(System.Int32, ref bool)
// docid: M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)
    /**
    Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call,  can be examined reliably to determine whether the lock was acquired.

    - Parameter millisecondsTimeout: The number of milliseconds to wait, or  (-1) to wait indefinitely.
    - Parameter lockTaken: True if the lock is acquired; otherwise, false.  must be initialized to false prior to calling this method.
    */
    public func TryEnter(millisecondsTimeout : Swift.Int32, lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_SpinLock_void__TryEnter_0__2__i32_refbool(&__thrown, self.get_handle(), millisecondsTimeout, &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryEnter(System.TimeSpan, ref bool)
// docid: M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)
    /**
    Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call,  can be examined reliably to determine whether the lock was acquired.

    - Parameter timeout: A  that represents the number of milliseconds to wait, or a  that represents -1 milliseconds to wait indefinitely.
    - Parameter lockTaken: True if the lock is acquired; otherwise, false.  must be initialized to false prior to calling this method.
    */
    public func TryEnter(timeout : dotnet.System.TimeSpan, lockTaken : inout Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_lockTaken = Swift.Int32(lockTaken ? 1 : 0);
        System_Threading_SpinLock_void__TryEnter_0__2__TimeSpan_refbool(&__thrown, self.get_handle(), timeout.get_handle(), &_tmp_ref_lockTaken);
        let _tmp2_lockTaken = (_tmp_ref_lockTaken) != 0;
            lockTaken = _tmp2_lockTaken;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_IsHeld()
// docid: M:System.Threading.SpinLock.get_IsHeld
    public func get_IsHeld() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SpinLock_bool__get_IsHeld_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsHeldByCurrentThread()
// docid: M:System.Threading.SpinLock.get_IsHeldByCurrentThread
    public func get_IsHeldByCurrentThread() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SpinLock_bool__get_IsHeldByCurrentThread_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsThreadOwnerTrackingEnabled()
// docid: M:System.Threading.SpinLock.get_IsThreadOwnerTrackingEnabled
    public func get_IsThreadOwnerTrackingEnabled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SpinLock_bool__get_IsThreadOwnerTrackingEnabled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // SpinLock


// type: System.Threading.SpinWait
// boxed value type
    /**
    Provides support for spin-based waiting.

    */
public final class SpinWait
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_SpinWait_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the number of times  has been called on this instance.

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets whether the next call to  will yield the processor, triggering a forced context switch.

    */
    public var NextSpinWillYield : Bool {
        get {
            return try! get_NextSpinWillYield();
        }
    }
    public override init() {
        let h = System_Threading_SpinWait_implicit_ctor();
            super.init(hndl: h);
    }
    // void Reset()
// docid: M:System.Threading.SpinWait.Reset
    /**
    Resets the spin counter.

    */
    public func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SpinWait_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SpinOnce()
// docid: M:System.Threading.SpinWait.SpinOnce
    /**
    Performs a single spin.

    */
    public func SpinOnce() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SpinWait_void__SpinOnce_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SpinOnce(System.Int32)
// docid: M:System.Threading.SpinWait.SpinOnce(System.Int32)
    /**
    Performs a single spin and calls  after a minimum spin count.

    - Parameter sleep1Threshold: A minimum spin count after which  may be used. A value of -1 disables the use of .
    */
    public func SpinOnce(sleep1Threshold : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SpinWait_void__SpinOnce_0__1__i32(&__thrown, self.get_handle(), sleep1Threshold);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SpinUntil(System.Func<bool>)
// docid: M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})
    /**
    Spins until the specified condition is satisfied.

    - Parameter condition: A delegate to be executed over and over until it returns true.
    */
    public class func SpinUntil(condition : dotnet.System.Func_1<Bool>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SpinWait_void__SpinUntil_0__1__System_Func_bool_(&__thrown, condition.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public class func SpinUntil(condition : @escaping () throws -> Bool) throws {
        let del_condition = try dotnet.System.Func_1<Swift.Bool>(condition);
        return try SpinUntil(condition: del_condition);
    }
    // bool SpinUntil(System.Func<bool>, System.Int32)
// docid: M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)
    /**
    Spins until the specified condition is satisfied or until the specified timeout is expired.

    - Parameter condition: A delegate to be executed over and over until it returns true.
    - Parameter millisecondsTimeout: The number of milliseconds to wait, or  (-1) to wait indefinitely.
    - Returns: 
         if the condition is satisfied within the timeout; otherwise, false.

    */
    public class func SpinUntil(condition : dotnet.System.Func_1<Bool>, millisecondsTimeout : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SpinWait_bool__SpinUntil_0__2__System_Func_bool__i32(&__thrown, condition.get_handle(), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public class func SpinUntil(condition : @escaping () throws -> Bool, millisecondsTimeout : Swift.Int32) throws -> Bool {
        let del_condition = try dotnet.System.Func_1<Swift.Bool>(condition);
        return try SpinUntil(condition: del_condition, millisecondsTimeout: millisecondsTimeout);
    }
    // bool SpinUntil(System.Func<bool>, System.TimeSpan)
// docid: M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)
    /**
    Spins until the specified condition is satisfied or until the specified timeout is expired.

    - Parameter condition: A delegate to be executed over and over until it returns true.
    - Parameter timeout: A  that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.
    - Returns: 
         if the condition is satisfied within the timeout; otherwise, false.

    */
    public class func SpinUntil(condition : dotnet.System.Func_1<Bool>, timeout : dotnet.System.TimeSpan) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SpinWait_bool__SpinUntil_0__2__System_Func_bool__TimeSpan(&__thrown, condition.get_handle(), timeout.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public class func SpinUntil(condition : @escaping () throws -> Bool, timeout : dotnet.System.TimeSpan) throws -> Bool {
        let del_condition = try dotnet.System.Func_1<Swift.Bool>(condition);
        return try SpinUntil(condition: del_condition, timeout: timeout);
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Threading.SpinWait.get_Count
    public func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SpinWait_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_NextSpinWillYield()
// docid: M:System.Threading.SpinWait.get_NextSpinWillYield
    public func get_NextSpinWillYield() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SpinWait_bool__get_NextSpinWillYield_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // SpinWait


// type: System.Threading.SynchronizationContext
    /**
    Provides the basic functionality for propagating a synchronization context in various synchronization models.

    */
open class SynchronizationContext
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_SynchronizationContext_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.SynchronizationContext.#ctor
    /**
    Creates a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SynchronizationContext_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.SynchronizationContext CreateCopy()
// docid: M:System.Threading.SynchronizationContext.CreateCopy
    /**
    When overridden in a derived class, creates a copy of the synchronization context.

    - Returns: A new  object.

    */
    open func CreateCopy() throws -> dotnet.System.Threading.SynchronizationContext {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SynchronizationContext_SynchronizationContext__CreateCopy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.SynchronizationContext(hndl : __return);
        }
    }
    // bool IsWaitNotificationRequired()
// docid: M:System.Threading.SynchronizationContext.IsWaitNotificationRequired
    /**
    Determines if wait notification is required.

    - Returns: 
         if wait notification is required; otherwise, .

    */
    open func IsWaitNotificationRequired() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SynchronizationContext_bool__IsWaitNotificationRequired_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void OperationCompleted()
// docid: M:System.Threading.SynchronizationContext.OperationCompleted
    /**
    When overridden in a derived class, responds to the notification that an operation has completed.

    */
    open func OperationCompleted() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SynchronizationContext_void__OperationCompleted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void OperationStarted()
// docid: M:System.Threading.SynchronizationContext.OperationStarted
    /**
    When overridden in a derived class, responds to the notification that an operation has started.

    */
    open func OperationStarted() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SynchronizationContext_void__OperationStarted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Post(System.Threading.SendOrPostCallback, System.Object)
// docid: M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)
    /**
    When overridden in a derived class, dispatches an asynchronous message to a synchronization context.

    - Parameter d: The  delegate to call.
    - Parameter state: The object passed to the delegate.
    */
    open func Post(d : dotnet.System.Threading.SendOrPostCallback, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SynchronizationContext_void__Post_0__2__SendOrPostCallback_Object(&__thrown, self.get_handle(), d.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Post(d : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws {
        let del_d = try dotnet.System.Threading.SendOrPostCallback(d);
        return try Post(d: del_d, state: state);
    }
    // void Send(System.Threading.SendOrPostCallback, System.Object)
// docid: M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)
    /**
    When overridden in a derived class, dispatches a synchronous message to a synchronization context.

    - Parameter d: The  delegate to call.
    - Parameter state: The object passed to the delegate.
    */
    open func Send(d : dotnet.System.Threading.SendOrPostCallback, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SynchronizationContext_void__Send_0__2__SendOrPostCallback_Object(&__thrown, self.get_handle(), d.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Send(d : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws {
        let del_d = try dotnet.System.Threading.SendOrPostCallback(d);
        return try Send(d: del_d, state: state);
    }
    // void SetSynchronizationContext(System.Threading.SynchronizationContext)
// docid: M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)
    /**
    Sets the current synchronization context.

    - Parameter syncContext: The  object to be set.
    */
    open class func SetSynchronizationContext(syncContext : Optional<dotnet.System.Threading.SynchronizationContext>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_SynchronizationContext_void__SetSynchronizationContext_0__1__SynchronizationContext(&__thrown, syncContext?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 Wait(System.IntPtr[], bool, System.Int32)
// docid: M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)
    /**
    Waits for any or all the elements in the specified array to receive a signal.

    - Parameter waitHandles: An array of type  that contains the native operating system handles.
    - Parameter waitAll: 
         to wait for all handles;  to wait for any handle.
    - Parameter millisecondsTimeout: The number of milliseconds to wait, or  (-1) to wait indefinitely.
    - Returns: The array index of the object that satisfied the wait.

    */
    open func Wait(waitHandles : dotnet.System_Arr<dotnet.System.IntPtr>, waitAll : Bool, millisecondsTimeout : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SynchronizationContext_i32__Wait_0__3__IntPtrArray_bool_i32(&__thrown, self.get_handle(), waitHandles.get_handle(), Swift.Int32(waitAll ? 1 : 0), millisecondsTimeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Threading.SynchronizationContext get_Current()
// docid: M:System.Threading.SynchronizationContext.get_Current
    open class func get_Current() throws -> Optional<dotnet.System.Threading.SynchronizationContext> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_SynchronizationContext_SynchronizationContext__get_Current_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.SynchronizationContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the synchronization context for the current thread.

    */
    public static var Current : Optional<dotnet.System.Threading.SynchronizationContext> {
        get {
            return try! get_Current();
        }
    }
} // SynchronizationContext


// type: System.Threading.SynchronizationLockException
    /**
    The exception that is thrown when a method requires the caller to own the lock on a given Monitor, and the method is invoked by a caller that does not own that lock.

    */
open class SynchronizationLockException
    :
    dotnet.System.SystemException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_SynchronizationLockException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.SynchronizationLockException.#ctor
    /**
    Initializes a new instance of the  class with default properties.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SynchronizationLockException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Threading.SynchronizationLockException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified error message.

    - Parameter message: The error message that explains the reason for the exception.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SynchronizationLockException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: The error message that explains the reason for the exception.
    - Parameter innerException: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_SynchronizationLockException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SynchronizationLockException


// type: System.Threading.ThreadLocal`1
    /**
    Provides thread-local storage of data.

    */
open class ThreadLocal_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_ThreadLocal_1_get_type_handle(T.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.ThreadLocal`1.#ctor
    /**
    Initializes the  instance.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ThreadLocal_1_ctor_0__0(T.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)
    /**
    Initializes the  instance and specifies whether all values are accessible from any thread.

    - Parameter trackAllValues: 
         to track all values set on the instance and expose them through the  property;  otherwise. When set to , a value stored from a given thread will be available through  even after that thread has exited.
    */
    public init(trackAllValues : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ThreadLocal_1_ctor_0__1__bool(T.get_type_handle(), &__thrown, Swift.Int32(trackAllValues ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Func<T>)
// docid: M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})
    /**
    Initializes the  instance with the specified  function.

    - Parameter valueFactory: The   invoked to produce a lazily-initialized value when an attempt is made to retrieve  without it having been previously initialized.
    */
    public init(valueFactory : dotnet.System.Func_1<T>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ThreadLocal_1_ctor_0__1__System_Func_T_(T.get_type_handle(), &__thrown, valueFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Func<T>, bool)
// docid: M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)
    /**
    Initializes the  instance with the specified  function and a flag that indicates whether all values are accessible from any thread.

    - Parameter valueFactory: The  invoked to produce a lazily-initialized value when an attempt is made to retrieve  without it having been previously initialized.
    - Parameter trackAllValues: 
         to track all values set on the instance and expose them through the  property;  otherwise. When set to , a value stored from a given thread will be available through  even after that thread has exited.
    */
    public init(valueFactory : dotnet.System.Func_1<T>, trackAllValues : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_ThreadLocal_1_ctor_0__2__System_Func_T__bool(T.get_type_handle(), &__thrown, valueFactory.get_handle(), Swift.Int32(trackAllValues ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:System.Threading.ThreadLocal`1.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ThreadLocal_1_void__Dispose_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String ToString()
// docid: M:System.Threading.ThreadLocal`1.ToString
    /**
    Creates and returns a string representation of this instance for the current thread.

    - Returns: The result of calling  on the .

    */
    open override func ToString() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadLocal_1_String__ToString_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_IsValueCreated()
// docid: M:System.Threading.ThreadLocal`1.get_IsValueCreated
    open func get_IsValueCreated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadLocal_1_bool__get_IsValueCreated_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] T get_Value()
// docid: M:System.Threading.ThreadLocal`1.get_Value
    open func get_Value() throws -> T {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadLocal_1_T__get_Value_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return T(gval: __return);
        }
    }
    // [IsSpecialName] void set_Value(T)
// docid: M:System.Threading.ThreadLocal`1.set_Value(`0)
    open func set_Value(value : T) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_ThreadLocal_1_void__set_Value_0__1__T(T.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<T> get_Values()
// docid: M:System.Threading.ThreadLocal`1.get_Values
    open func get_Values() throws -> dotnet.System.Collections.Generic.IList_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadLocal_1_System_Collections_Generic_IList_T___get_Values_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IList_1(hndl : __return);
        }
    }
    /**
    Gets whether  is initialized on the current thread.

    */
    open var IsValueCreated : Bool {
        get {
            return try! get_IsValueCreated();
        }
    }
    /**
    Gets or sets the value of this instance for the current thread.

    */
    open var Value : T {
        get {
            return try! get_Value();
        }
        set(v) {
            return try! set_Value(value: v);
        }
    }
    /**
    Gets a list containing the values stored by all threads that have accessed this instance.

    */
    open var Values : dotnet.System.Collections.Generic.IList_1<T> {
        get {
            return try! get_Values();
        }
    }
} // ThreadLocal_1


// type: System.Threading.Volatile
public struct Volatile {
    // bool Read(ref bool)
// docid: M:System.Threading.Volatile.Read(System.Boolean@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Bool) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = Swift.Int32(location ? 1 : 0);
        let __return = System_Threading_Volatile_bool__Read_0__1__refbool(&__thrown, &_tmp_ref_location);
        let _tmp2_location = (_tmp_ref_location) != 0;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Byte Read(ref System.Byte)
// docid: M:System.Threading.Volatile.Read(System.Byte@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.UInt8) throws -> Swift.UInt8 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_u8__Read_0__1__refu8(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Double Read(ref System.Double)
// docid: M:System.Threading.Volatile.Read(System.Double@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.Double) throws -> Swift.Double {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_f64__Read_0__1__reff64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int16 Read(ref System.Int16)
// docid: M:System.Threading.Volatile.Read(System.Int16@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.Int16) throws -> Swift.Int16 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_i16__Read_0__1__refi16(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 Read(ref System.Int32)
// docid: M:System.Threading.Volatile.Read(System.Int32@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_i32__Read_0__1__refi32(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Read(ref System.Int64)
// docid: M:System.Threading.Volatile.Read(System.Int64@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.Int64) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_i64__Read_0__1__refi64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.IntPtr Read(ref System.IntPtr)
// docid: M:System.Threading.Volatile.Read(System.IntPtr@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout dotnet.System.IntPtr) throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location.get_value();
        let __return = System_Threading_Volatile_IntPtr__Read_0__1__refIntPtr(&__thrown, &_tmp_ref_location);
        let _tmp2_location = dotnet.System.IntPtr(val: _tmp_ref_location);
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // System.SByte Read(ref System.SByte)
// docid: M:System.Threading.Volatile.Read(System.SByte@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.Int8) throws -> Swift.Int8 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_i8__Read_0__1__refi8(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Single Read(ref System.Single)
// docid: M:System.Threading.Volatile.Read(System.Single@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.Float) throws -> Swift.Float {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_f32__Read_0__1__reff32(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt16 Read(ref System.UInt16)
// docid: M:System.Threading.Volatile.Read(System.UInt16@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.UInt16) throws -> Swift.UInt16 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_u16__Read_0__1__refu16(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt32 Read(ref System.UInt32)
// docid: M:System.Threading.Volatile.Read(System.UInt32@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.UInt32) throws -> Swift.UInt32 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_u32__Read_0__1__refu32(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UInt64 Read(ref System.UInt64)
// docid: M:System.Threading.Volatile.Read(System.UInt64@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout Swift.UInt64) throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        let __return = System_Threading_Volatile_u64__Read_0__1__refu64(&__thrown, &_tmp_ref_location);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.UIntPtr Read(ref System.UIntPtr)
// docid: M:System.Threading.Volatile.Read(System.UIntPtr@)
    /**
    Reads the value of the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears after this method in the code, the processor cannot move it before this method.

    - Parameter location: The field to read.
    - Returns: The value that was read.

    */
    public static func Read(location : inout dotnet.System.UIntPtr) throws -> dotnet.System.UIntPtr {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location.get_handle();
        let __return = System_Threading_Volatile_UIntPtr__Read_0__1__refUIntPtr(&__thrown, &_tmp_ref_location);
        let _tmp2_location = dotnet.System.UIntPtr(hndl: _tmp_ref_location);
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.UIntPtr(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) T Read<T>(ref T)
    // void Write(ref bool, bool)
// docid: M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Bool, value : Bool) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = Swift.Int32(location ? 1 : 0);
        System_Threading_Volatile_void__Write_0__2__refbool_bool(&__thrown, &_tmp_ref_location, Swift.Int32(value ? 1 : 0));
        let _tmp2_location = (_tmp_ref_location) != 0;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.Byte, System.Byte)
// docid: M:System.Threading.Volatile.Write(System.Byte@,System.Byte)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.UInt8, value : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refu8_u8(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.Double, System.Double)
// docid: M:System.Threading.Volatile.Write(System.Double@,System.Double)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.Double, value : Swift.Double) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__reff64_f64(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.Int16, System.Int16)
// docid: M:System.Threading.Volatile.Write(System.Int16@,System.Int16)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.Int16, value : Swift.Int16) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refi16_i16(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.Int32, System.Int32)
// docid: M:System.Threading.Volatile.Write(System.Int32@,System.Int32)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.Int32, value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refi32_i32(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.Int64, System.Int64)
// docid: M:System.Threading.Volatile.Write(System.Int64@,System.Int64)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.Int64, value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refi64_i64(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.IntPtr, System.IntPtr)
// docid: M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout dotnet.System.IntPtr, value : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location.get_value();
        System_Threading_Volatile_void__Write_0__2__refIntPtr_IntPtr(&__thrown, &_tmp_ref_location, value.get_value());
        let _tmp2_location = dotnet.System.IntPtr(val: _tmp_ref_location);
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.SByte, System.SByte)
// docid: M:System.Threading.Volatile.Write(System.SByte@,System.SByte)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.Int8, value : Swift.Int8) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refi8_i8(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.Single, System.Single)
// docid: M:System.Threading.Volatile.Write(System.Single@,System.Single)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.Float, value : Swift.Float) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__reff32_f32(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.UInt16, System.UInt16)
// docid: M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.UInt16, value : Swift.UInt16) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refu16_u16(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.UInt32, System.UInt32)
// docid: M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.UInt32, value : Swift.UInt32) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refu32_u32(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.UInt64, System.UInt64)
// docid: M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout Swift.UInt64, value : Swift.UInt64) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location;
        System_Threading_Volatile_void__Write_0__2__refu64_u64(&__thrown, &_tmp_ref_location, value);
        let _tmp2_location = _tmp_ref_location;
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(ref System.UIntPtr, System.UIntPtr)
// docid: M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)
    /**
    Writes the specified value to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the value is written.
    - Parameter value: The value to write.
    */
    public static func Write(location : inout dotnet.System.UIntPtr, value : dotnet.System.UIntPtr) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location.get_handle();
        System_Threading_Volatile_void__Write_0__2__refUIntPtr_UIntPtr(&__thrown, &_tmp_ref_location, value.get_handle());
        let _tmp2_location = dotnet.System.UIntPtr(hndl: _tmp_ref_location);
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write<T>(ref T, T)
// docid: M:System.Threading.Volatile.Write``1(``0@,``0)
    /**
    Writes the specified object reference to the specified field. On systems that require it, inserts a memory barrier that prevents the processor from reordering memory operations as follows: If a read or write appears before this method in the code, the processor cannot move it after this method.

    - Parameter location: The field where the object reference is written.
    - Parameter value: The object reference to write.
    */
    public static func Write<UT : SGBridgeGenericValue>(location : inout UT, value : UT) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_location = location.to_gval();
        System_Threading_Volatile_void__Write_1__2__refUT_UT(UT.get_type_handle(), &__thrown, &_tmp_ref_location, value.to_gval());
            let _tmp2_location = UT(gval: _tmp_ref_location);
            location = _tmp2_location;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // Volatile


// type: System.Threading.WaitHandleCannotBeOpenedException
    /**
    The exception that is thrown when an attempt is made to open a system mutex, semaphore, or event wait handle that does not exist.

    */
open class WaitHandleCannotBeOpenedException
    :
    dotnet.System.ApplicationException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_WaitHandleCannotBeOpenedException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.WaitHandleCannotBeOpenedException.#ctor
    /**
    Initializes a new instance of the  class with default values.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_WaitHandleCannotBeOpenedException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified error message.

    - Parameter message: The error message that explains the reason for the exception.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_WaitHandleCannotBeOpenedException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: The error message that explains the reason for the exception.
    - Parameter innerException: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_WaitHandleCannotBeOpenedException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // WaitHandleCannotBeOpenedException


}


